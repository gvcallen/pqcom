
./.pio/build/nanoatmega328/firmware.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 64 00 	jmp	0xc8	; 0xc8 <__dtors_end>
       4:	0c 94 0f 38 	jmp	0x701e	; 0x701e <__vector_1>
       8:	0c 94 e8 37 	jmp	0x6fd0	; 0x6fd0 <__vector_2>
       c:	0c 94 8c 00 	jmp	0x118	; 0x118 <__bad_interrupt>
      10:	0c 94 8c 00 	jmp	0x118	; 0x118 <__bad_interrupt>
      14:	0c 94 8c 00 	jmp	0x118	; 0x118 <__bad_interrupt>
      18:	0c 94 8c 00 	jmp	0x118	; 0x118 <__bad_interrupt>
      1c:	0c 94 36 38 	jmp	0x706c	; 0x706c <__vector_7>
      20:	0c 94 8c 00 	jmp	0x118	; 0x118 <__bad_interrupt>
      24:	0c 94 8c 00 	jmp	0x118	; 0x118 <__bad_interrupt>
      28:	0c 94 8c 00 	jmp	0x118	; 0x118 <__bad_interrupt>
      2c:	0c 94 8c 00 	jmp	0x118	; 0x118 <__bad_interrupt>
      30:	0c 94 8c 00 	jmp	0x118	; 0x118 <__bad_interrupt>
      34:	0c 94 8c 00 	jmp	0x118	; 0x118 <__bad_interrupt>
      38:	0c 94 8c 00 	jmp	0x118	; 0x118 <__bad_interrupt>
      3c:	0c 94 8c 00 	jmp	0x118	; 0x118 <__bad_interrupt>
      40:	0c 94 84 37 	jmp	0x6f08	; 0x6f08 <__vector_16>
      44:	0c 94 8c 00 	jmp	0x118	; 0x118 <__bad_interrupt>
      48:	0c 94 b8 38 	jmp	0x7170	; 0x7170 <__vector_18>
      4c:	0c 94 92 38 	jmp	0x7124	; 0x7124 <__vector_19>
      50:	0c 94 8c 00 	jmp	0x118	; 0x118 <__bad_interrupt>
      54:	0c 94 8c 00 	jmp	0x118	; 0x118 <__bad_interrupt>
      58:	0c 94 8c 00 	jmp	0x118	; 0x118 <__bad_interrupt>
      5c:	0c 94 8c 00 	jmp	0x118	; 0x118 <__bad_interrupt>
      60:	0c 94 8c 00 	jmp	0x118	; 0x118 <__bad_interrupt>
      64:	0c 94 8c 00 	jmp	0x118	; 0x118 <__bad_interrupt>

00000068 <__trampolines_end>:
      68:	02 00       	Address 0x0000000000000068 is out of bounds.
.word	0xffff	; ????

00000069 <port_to_output_PGM>:
      69:	00 00 00 00 25 00 28 00 2b 00                       ....%.(.+.

00000073 <digital_pin_to_timer_PGM>:
      73:	00 00 00 08 00 02 01 00 00 03 04 07 00 00 00 00     ................
      83:	00 00 00 00                                         ....

00000087 <port_to_input_PGM>:
      87:	00 00 00 00 23 00 26 00 29 00                       ....#.&.).

00000091 <port_to_mode_PGM>:
      91:	00 00 00 00 24 00 27 00 2a 00                       ....$.'.*.

0000009b <digital_pin_to_bit_mask_PGM>:
      9b:	01 02 04 08 10 20 40 80 01 02 04 08 10 20 01 02     ..... @...... ..
      ab:	04 08 10 20                                         ... 

000000af <digital_pin_to_port_PGM>:
      af:	04 04 04 04 04 04 04 04 02 02 02 02 02 02 03 03     ................
      bf:	03 03 03 03 00                                      .....

000000c4 <__ctors_start>:
      c4:	77 37       	cpi	r23, 0x77	; 119

000000c6 <__ctors_end>:
      c6:	f0 38       	cpi	r31, 0x80	; 128

000000c8 <__dtors_end>:
      c8:	11 24       	eor	r1, r1
      ca:	1f be       	out	0x3f, r1	; 63
      cc:	cf ef       	ldi	r28, 0xFF	; 255
      ce:	d8 e0       	ldi	r29, 0x08	; 8
      d0:	de bf       	out	0x3e, r29	; 62
      d2:	cd bf       	out	0x3d, r28	; 61

000000d4 <__do_clear_bss>:
      d4:	27 e0       	ldi	r18, 0x07	; 7
      d6:	a0 e4       	ldi	r26, 0x40	; 64
      d8:	b3 e0       	ldi	r27, 0x03	; 3
      da:	01 c0       	rjmp	.+2      	; 0xde <.do_clear_bss_start>

000000dc <.do_clear_bss_loop>:
      dc:	1d 92       	st	X+, r1

000000de <.do_clear_bss_start>:
      de:	ad 39       	cpi	r26, 0x9D	; 157
      e0:	b2 07       	cpc	r27, r18
      e2:	e1 f7       	brne	.-8      	; 0xdc <.do_clear_bss_loop>

000000e4 <__do_copy_data>:
      e4:	13 e0       	ldi	r17, 0x03	; 3
      e6:	a0 e0       	ldi	r26, 0x00	; 0
      e8:	b1 e0       	ldi	r27, 0x01	; 1
      ea:	e2 ec       	ldi	r30, 0xC2	; 194
      ec:	fd e7       	ldi	r31, 0x7D	; 125
      ee:	02 c0       	rjmp	.+4      	; 0xf4 <__do_copy_data+0x10>
      f0:	05 90       	lpm	r0, Z+
      f2:	0d 92       	st	X+, r0
      f4:	a0 34       	cpi	r26, 0x40	; 64
      f6:	b1 07       	cpc	r27, r17
      f8:	d9 f7       	brne	.-10     	; 0xf0 <__do_copy_data+0xc>

000000fa <__do_global_ctors>:
      fa:	10 e0       	ldi	r17, 0x00	; 0
      fc:	c3 e6       	ldi	r28, 0x63	; 99
      fe:	d0 e0       	ldi	r29, 0x00	; 0
     100:	04 c0       	rjmp	.+8      	; 0x10a <__do_global_ctors+0x10>
     102:	21 97       	sbiw	r28, 0x01	; 1
     104:	fe 01       	movw	r30, r28
     106:	0e 94 51 3b 	call	0x76a2	; 0x76a2 <__tablejump2__>
     10a:	c2 36       	cpi	r28, 0x62	; 98
     10c:	d1 07       	cpc	r29, r17
     10e:	c9 f7       	brne	.-14     	; 0x102 <__do_global_ctors+0x8>
     110:	0e 94 df 37 	call	0x6fbe	; 0x6fbe <main>
     114:	0c 94 d4 3e 	jmp	0x7da8	; 0x7da8 <__do_global_dtors>

00000118 <__bad_interrupt>:
     118:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000011c <_ZN8SPIClass3endEv>:
  initialized++; // reference count
  SREG = sreg;
}

void SPIClass::end() {
  uint8_t sreg = SREG;
     11c:	9f b7       	in	r25, 0x3f	; 63
  noInterrupts(); // Protect from a scheduler and prevent transactionBegin
     11e:	f8 94       	cli
  // Decrease the reference counter
  if (initialized)
     120:	80 91 98 07 	lds	r24, 0x0798	; 0x800798 <_ZN8SPIClass11initializedE>
     124:	88 23       	and	r24, r24
     126:	19 f0       	breq	.+6      	; 0x12e <_ZN8SPIClass3endEv+0x12>
    initialized--;
     128:	81 50       	subi	r24, 0x01	; 1
     12a:	80 93 98 07 	sts	0x0798, r24	; 0x800798 <_ZN8SPIClass11initializedE>
  // If there are no more references disable SPI
  if (!initialized) {
     12e:	80 91 98 07 	lds	r24, 0x0798	; 0x800798 <_ZN8SPIClass11initializedE>
     132:	81 11       	cpse	r24, r1
     134:	05 c0       	rjmp	.+10     	; 0x140 <_ZN8SPIClass3endEv+0x24>
    SPCR &= ~_BV(SPE);
     136:	8c b5       	in	r24, 0x2c	; 44
     138:	8f 7b       	andi	r24, 0xBF	; 191
     13a:	8c bd       	out	0x2c, r24	; 44
    interruptMode = 0;
     13c:	10 92 97 07 	sts	0x0797, r1	; 0x800797 <_ZN8SPIClass13interruptModeE>
    #ifdef SPI_TRANSACTION_MISMATCH_LED
    inTransactionFlag = 0;
    #endif
  }
  SREG = sreg;
     140:	9f bf       	out	0x3f, r25	; 63
}
     142:	08 95       	ret

00000144 <turnOffPWM>:
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
     144:	83 30       	cpi	r24, 0x03	; 3
     146:	b1 f0       	breq	.+44     	; 0x174 <turnOffPWM+0x30>
     148:	60 f0       	brcs	.+24     	; 0x162 <turnOffPWM+0x1e>
     14a:	87 30       	cpi	r24, 0x07	; 7
     14c:	e9 f0       	breq	.+58     	; 0x188 <turnOffPWM+0x44>
     14e:	88 30       	cpi	r24, 0x08	; 8
     150:	09 f1       	breq	.+66     	; 0x194 <turnOffPWM+0x50>
     152:	84 30       	cpi	r24, 0x04	; 4
     154:	21 f5       	brne	.+72     	; 0x19e <turnOffPWM+0x5a>
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
     156:	e0 e8       	ldi	r30, 0x80	; 128
     158:	f0 e0       	ldi	r31, 0x00	; 0
     15a:	80 81       	ld	r24, Z
     15c:	8f 7d       	andi	r24, 0xDF	; 223
     15e:	80 83       	st	Z, r24
     160:	08 95       	ret
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
     162:	81 30       	cpi	r24, 0x01	; 1
     164:	69 f0       	breq	.+26     	; 0x180 <turnOffPWM+0x3c>
     166:	82 30       	cpi	r24, 0x02	; 2
     168:	21 f4       	brne	.+8      	; 0x172 <turnOffPWM+0x2e>
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
     16a:	84 b5       	in	r24, 0x24	; 36
     16c:	8f 7d       	andi	r24, 0xDF	; 223
     16e:	84 bd       	out	0x24, r24	; 36
     170:	08 95       	ret
     172:	08 95       	ret
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
     174:	e0 e8       	ldi	r30, 0x80	; 128
     176:	f0 e0       	ldi	r31, 0x00	; 0
     178:	80 81       	ld	r24, Z
     17a:	8f 77       	andi	r24, 0x7F	; 127
     17c:	80 83       	st	Z, r24
     17e:	08 95       	ret
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
     180:	84 b5       	in	r24, 0x24	; 36
     182:	8f 77       	andi	r24, 0x7F	; 127
     184:	84 bd       	out	0x24, r24	; 36
     186:	08 95       	ret
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
     188:	e0 eb       	ldi	r30, 0xB0	; 176
     18a:	f0 e0       	ldi	r31, 0x00	; 0
     18c:	80 81       	ld	r24, Z
     18e:	8f 77       	andi	r24, 0x7F	; 127
     190:	80 83       	st	Z, r24
     192:	08 95       	ret
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
     194:	e0 eb       	ldi	r30, 0xB0	; 176
     196:	f0 e0       	ldi	r31, 0x00	; 0
     198:	80 81       	ld	r24, Z
     19a:	8f 7d       	andi	r24, 0xDF	; 223
     19c:	80 83       	st	Z, r24
		case  TIMER5A:  cbi(TCCR5A, COM5A1);    break;
		case  TIMER5B:  cbi(TCCR5A, COM5B1);    break;
		case  TIMER5C:  cbi(TCCR5A, COM5C1);    break;
		#endif
	}
}
     19e:	08 95       	ret

000001a0 <digitalRead>:

	SREG = oldSREG;
}

int digitalRead(uint8_t pin)
{
     1a0:	cf 93       	push	r28
     1a2:	df 93       	push	r29
	uint8_t timer = digitalPinToTimer(pin);
     1a4:	28 2f       	mov	r18, r24
     1a6:	30 e0       	ldi	r19, 0x00	; 0
     1a8:	f9 01       	movw	r30, r18
     1aa:	ed 58       	subi	r30, 0x8D	; 141
     1ac:	ff 4f       	sbci	r31, 0xFF	; 255
     1ae:	84 91       	lpm	r24, Z
	uint8_t bit = digitalPinToBitMask(pin);
     1b0:	f9 01       	movw	r30, r18
     1b2:	e5 56       	subi	r30, 0x65	; 101
     1b4:	ff 4f       	sbci	r31, 0xFF	; 255
     1b6:	d4 91       	lpm	r29, Z
	uint8_t port = digitalPinToPort(pin);
     1b8:	f9 01       	movw	r30, r18
     1ba:	e1 55       	subi	r30, 0x51	; 81
     1bc:	ff 4f       	sbci	r31, 0xFF	; 255
     1be:	c4 91       	lpm	r28, Z

	if (port == NOT_A_PIN) return LOW;
     1c0:	cc 23       	and	r28, r28
     1c2:	b1 f0       	breq	.+44     	; 0x1f0 <digitalRead+0x50>

	// If the pin that support PWM output, we need to turn it off
	// before getting a digital reading.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
     1c4:	81 11       	cpse	r24, r1
     1c6:	0e c0       	rjmp	.+28     	; 0x1e4 <digitalRead+0x44>

	if (*portInputRegister(port) & bit) return HIGH;
     1c8:	ec 2f       	mov	r30, r28
     1ca:	f0 e0       	ldi	r31, 0x00	; 0
     1cc:	ee 0f       	add	r30, r30
     1ce:	ff 1f       	adc	r31, r31
     1d0:	e9 57       	subi	r30, 0x79	; 121
     1d2:	ff 4f       	sbci	r31, 0xFF	; 255
     1d4:	a5 91       	lpm	r26, Z+
     1d6:	b4 91       	lpm	r27, Z
     1d8:	ec 91       	ld	r30, X
     1da:	ed 23       	and	r30, r29
     1dc:	31 f4       	brne	.+12     	; 0x1ea <digitalRead+0x4a>
	return LOW;
     1de:	90 e0       	ldi	r25, 0x00	; 0
     1e0:	80 e0       	ldi	r24, 0x00	; 0
     1e2:	08 c0       	rjmp	.+16     	; 0x1f4 <digitalRead+0x54>

	if (port == NOT_A_PIN) return LOW;

	// If the pin that support PWM output, we need to turn it off
	// before getting a digital reading.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
     1e4:	0e 94 a2 00 	call	0x144	; 0x144 <turnOffPWM>
     1e8:	ef cf       	rjmp	.-34     	; 0x1c8 <digitalRead+0x28>

	if (*portInputRegister(port) & bit) return HIGH;
     1ea:	81 e0       	ldi	r24, 0x01	; 1
     1ec:	90 e0       	ldi	r25, 0x00	; 0
     1ee:	02 c0       	rjmp	.+4      	; 0x1f4 <digitalRead+0x54>
{
	uint8_t timer = digitalPinToTimer(pin);
	uint8_t bit = digitalPinToBitMask(pin);
	uint8_t port = digitalPinToPort(pin);

	if (port == NOT_A_PIN) return LOW;
     1f0:	90 e0       	ldi	r25, 0x00	; 0
     1f2:	80 e0       	ldi	r24, 0x00	; 0
	// before getting a digital reading.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);

	if (*portInputRegister(port) & bit) return HIGH;
	return LOW;
}
     1f4:	df 91       	pop	r29
     1f6:	cf 91       	pop	r28
     1f8:	08 95       	ret

000001fa <digitalWrite>:
		#endif
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
     1fa:	1f 93       	push	r17
     1fc:	cf 93       	push	r28
     1fe:	df 93       	push	r29
	uint8_t timer = digitalPinToTimer(pin);
     200:	28 2f       	mov	r18, r24
     202:	30 e0       	ldi	r19, 0x00	; 0
     204:	f9 01       	movw	r30, r18
     206:	ed 58       	subi	r30, 0x8D	; 141
     208:	ff 4f       	sbci	r31, 0xFF	; 255
     20a:	84 91       	lpm	r24, Z
	uint8_t bit = digitalPinToBitMask(pin);
     20c:	f9 01       	movw	r30, r18
     20e:	e5 56       	subi	r30, 0x65	; 101
     210:	ff 4f       	sbci	r31, 0xFF	; 255
     212:	14 91       	lpm	r17, Z
	uint8_t port = digitalPinToPort(pin);
     214:	f9 01       	movw	r30, r18
     216:	e1 55       	subi	r30, 0x51	; 81
     218:	ff 4f       	sbci	r31, 0xFF	; 255
     21a:	c4 91       	lpm	r28, Z
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
     21c:	cc 23       	and	r28, r28
     21e:	a9 f0       	breq	.+42     	; 0x24a <digitalWrite+0x50>
     220:	d6 2f       	mov	r29, r22

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
     222:	81 11       	cpse	r24, r1
     224:	16 c0       	rjmp	.+44     	; 0x252 <digitalWrite+0x58>

	out = portOutputRegister(port);
     226:	ec 2f       	mov	r30, r28
     228:	f0 e0       	ldi	r31, 0x00	; 0
     22a:	ee 0f       	add	r30, r30
     22c:	ff 1f       	adc	r31, r31
     22e:	e7 59       	subi	r30, 0x97	; 151
     230:	ff 4f       	sbci	r31, 0xFF	; 255
     232:	a5 91       	lpm	r26, Z+
     234:	b4 91       	lpm	r27, Z

	uint8_t oldSREG = SREG;
     236:	8f b7       	in	r24, 0x3f	; 63
	cli();
     238:	f8 94       	cli

	if (val == LOW) {
     23a:	d1 11       	cpse	r29, r1
     23c:	0d c0       	rjmp	.+26     	; 0x258 <digitalWrite+0x5e>
		*out &= ~bit;
     23e:	9c 91       	ld	r25, X
     240:	e1 2f       	mov	r30, r17
     242:	e0 95       	com	r30
     244:	e9 23       	and	r30, r25
     246:	ec 93       	st	X, r30
	} else {
		*out |= bit;
	}

	SREG = oldSREG;
     248:	8f bf       	out	0x3f, r24	; 63
}
     24a:	df 91       	pop	r29
     24c:	cf 91       	pop	r28
     24e:	1f 91       	pop	r17
     250:	08 95       	ret

	if (port == NOT_A_PIN) return;

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
     252:	0e 94 a2 00 	call	0x144	; 0x144 <turnOffPWM>
     256:	e7 cf       	rjmp	.-50     	; 0x226 <digitalWrite+0x2c>
	cli();

	if (val == LOW) {
		*out &= ~bit;
	} else {
		*out |= bit;
     258:	ec 91       	ld	r30, X
     25a:	e1 2b       	or	r30, r17
     25c:	ec 93       	st	X, r30
     25e:	f4 cf       	rjmp	.-24     	; 0x248 <digitalWrite+0x4e>

00000260 <pinMode>:
#define ARDUINO_MAIN
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
     260:	cf 93       	push	r28
     262:	df 93       	push	r29
	uint8_t bit = digitalPinToBitMask(pin);
     264:	90 e0       	ldi	r25, 0x00	; 0
     266:	fc 01       	movw	r30, r24
     268:	e5 56       	subi	r30, 0x65	; 101
     26a:	ff 4f       	sbci	r31, 0xFF	; 255
     26c:	24 91       	lpm	r18, Z
	uint8_t port = digitalPinToPort(pin);
     26e:	81 55       	subi	r24, 0x51	; 81
     270:	9f 4f       	sbci	r25, 0xFF	; 255
     272:	fc 01       	movw	r30, r24
     274:	84 91       	lpm	r24, Z
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
     276:	88 23       	and	r24, r24
     278:	19 f1       	breq	.+70     	; 0x2c0 <pinMode+0x60>

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
     27a:	90 e0       	ldi	r25, 0x00	; 0
     27c:	88 0f       	add	r24, r24
     27e:	99 1f       	adc	r25, r25
     280:	fc 01       	movw	r30, r24
     282:	ef 56       	subi	r30, 0x6F	; 111
     284:	ff 4f       	sbci	r31, 0xFF	; 255
     286:	a5 91       	lpm	r26, Z+
     288:	b4 91       	lpm	r27, Z
	out = portOutputRegister(port);
     28a:	fc 01       	movw	r30, r24
     28c:	e7 59       	subi	r30, 0x97	; 151
     28e:	ff 4f       	sbci	r31, 0xFF	; 255
     290:	c5 91       	lpm	r28, Z+
     292:	d4 91       	lpm	r29, Z

	if (mode == INPUT) { 
     294:	66 23       	and	r22, r22
     296:	49 f0       	breq	.+18     	; 0x2aa <pinMode+0x4a>
		uint8_t oldSREG = SREG;
                cli();
		*reg &= ~bit;
		*out &= ~bit;
		SREG = oldSREG;
	} else if (mode == INPUT_PULLUP) {
     298:	62 30       	cpi	r22, 0x02	; 2
     29a:	a9 f0       	breq	.+42     	; 0x2c6 <pinMode+0x66>
                cli();
		*reg &= ~bit;
		*out |= bit;
		SREG = oldSREG;
	} else {
		uint8_t oldSREG = SREG;
     29c:	8f b7       	in	r24, 0x3f	; 63
                cli();
     29e:	f8 94       	cli
		*reg |= bit;
     2a0:	ec 91       	ld	r30, X
     2a2:	e2 2b       	or	r30, r18
     2a4:	ec 93       	st	X, r30
		SREG = oldSREG;
     2a6:	8f bf       	out	0x3f, r24	; 63
     2a8:	0b c0       	rjmp	.+22     	; 0x2c0 <pinMode+0x60>
	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
	out = portOutputRegister(port);

	if (mode == INPUT) { 
		uint8_t oldSREG = SREG;
     2aa:	9f b7       	in	r25, 0x3f	; 63
                cli();
     2ac:	f8 94       	cli
		*reg &= ~bit;
     2ae:	8c 91       	ld	r24, X
     2b0:	e2 2f       	mov	r30, r18
     2b2:	e0 95       	com	r30
     2b4:	8e 23       	and	r24, r30
     2b6:	8c 93       	st	X, r24
		*out &= ~bit;
     2b8:	88 81       	ld	r24, Y
     2ba:	e8 23       	and	r30, r24
     2bc:	e8 83       	st	Y, r30
		SREG = oldSREG;
     2be:	9f bf       	out	0x3f, r25	; 63
		uint8_t oldSREG = SREG;
                cli();
		*reg |= bit;
		SREG = oldSREG;
	}
}
     2c0:	df 91       	pop	r29
     2c2:	cf 91       	pop	r28
     2c4:	08 95       	ret
                cli();
		*reg &= ~bit;
		*out &= ~bit;
		SREG = oldSREG;
	} else if (mode == INPUT_PULLUP) {
		uint8_t oldSREG = SREG;
     2c6:	9f b7       	in	r25, 0x3f	; 63
                cli();
     2c8:	f8 94       	cli
		*reg &= ~bit;
     2ca:	3c 91       	ld	r19, X
     2cc:	82 2f       	mov	r24, r18
     2ce:	80 95       	com	r24
     2d0:	83 23       	and	r24, r19
     2d2:	8c 93       	st	X, r24
		*out |= bit;
     2d4:	e8 81       	ld	r30, Y
     2d6:	e2 2b       	or	r30, r18
     2d8:	e8 83       	st	Y, r30
		SREG = oldSREG;
     2da:	9f bf       	out	0x3f, r25	; 63
     2dc:	f1 cf       	rjmp	.-30     	; 0x2c0 <pinMode+0x60>

000002de <_ZN8SPIClass5beginEv>:
#ifdef SPI_TRANSACTION_MISMATCH_LED
uint8_t SPIClass::inTransactionFlag = 0;
#endif

void SPIClass::begin()
{
     2de:	cf 93       	push	r28
  uint8_t sreg = SREG;
     2e0:	cf b7       	in	r28, 0x3f	; 63
  noInterrupts(); // Protect from a scheduler and prevent transactionBegin
     2e2:	f8 94       	cli
  if (!initialized) {
     2e4:	80 91 98 07 	lds	r24, 0x0798	; 0x800798 <_ZN8SPIClass11initializedE>
     2e8:	81 11       	cpse	r24, r1
     2ea:	23 c0       	rjmp	.+70     	; 0x332 <_ZN8SPIClass5beginEv+0x54>
    // Set SS to high so a connected chip will be "deselected" by default
    uint8_t port = digitalPinToPort(SS);
     2ec:	e9 eb       	ldi	r30, 0xB9	; 185
     2ee:	f0 e0       	ldi	r31, 0x00	; 0
     2f0:	84 91       	lpm	r24, Z
    uint8_t bit = digitalPinToBitMask(SS);
     2f2:	e5 ea       	ldi	r30, 0xA5	; 165
     2f4:	f0 e0       	ldi	r31, 0x00	; 0
     2f6:	94 91       	lpm	r25, Z
    volatile uint8_t *reg = portModeRegister(port);
     2f8:	e8 2f       	mov	r30, r24
     2fa:	f0 e0       	ldi	r31, 0x00	; 0
     2fc:	ee 0f       	add	r30, r30
     2fe:	ff 1f       	adc	r31, r31
     300:	ef 56       	subi	r30, 0x6F	; 111
     302:	ff 4f       	sbci	r31, 0xFF	; 255
     304:	a5 91       	lpm	r26, Z+
     306:	b4 91       	lpm	r27, Z

    // if the SS pin is not already configured as an output
    // then set it high (to enable the internal pull-up resistor)
    if(!(*reg & bit)){
     308:	ec 91       	ld	r30, X
     30a:	e9 23       	and	r30, r25
     30c:	d1 f0       	breq	.+52     	; 0x342 <_ZN8SPIClass5beginEv+0x64>
    }

    // When the SS pin is set as OUTPUT, it can be used as
    // a general purpose output port (it doesn't influence
    // SPI operations).
    pinMode(SS, OUTPUT);
     30e:	61 e0       	ldi	r22, 0x01	; 1
     310:	8a e0       	ldi	r24, 0x0A	; 10
     312:	0e 94 30 01 	call	0x260	; 0x260 <pinMode>

    // Warning: if the SS pin ever becomes a LOW INPUT then SPI
    // automatically switches to Slave, so the data direction of
    // the SS pin MUST be kept as OUTPUT.
    SPCR |= _BV(MSTR);
     316:	8c b5       	in	r24, 0x2c	; 44
     318:	80 61       	ori	r24, 0x10	; 16
     31a:	8c bd       	out	0x2c, r24	; 44
    SPCR |= _BV(SPE);
     31c:	8c b5       	in	r24, 0x2c	; 44
     31e:	80 64       	ori	r24, 0x40	; 64
     320:	8c bd       	out	0x2c, r24	; 44
    // MISO pin automatically overrides to INPUT.
    // By doing this AFTER enabling SPI, we avoid accidentally
    // clocking in a single bit since the lines go directly
    // from "input" to SPI control.
    // http://code.google.com/p/arduino/issues/detail?id=888
    pinMode(SCK, OUTPUT);
     322:	61 e0       	ldi	r22, 0x01	; 1
     324:	8d e0       	ldi	r24, 0x0D	; 13
     326:	0e 94 30 01 	call	0x260	; 0x260 <pinMode>
    pinMode(MOSI, OUTPUT);
     32a:	61 e0       	ldi	r22, 0x01	; 1
     32c:	8b e0       	ldi	r24, 0x0B	; 11
     32e:	0e 94 30 01 	call	0x260	; 0x260 <pinMode>
  }
  initialized++; // reference count
     332:	80 91 98 07 	lds	r24, 0x0798	; 0x800798 <_ZN8SPIClass11initializedE>
     336:	8f 5f       	subi	r24, 0xFF	; 255
     338:	80 93 98 07 	sts	0x0798, r24	; 0x800798 <_ZN8SPIClass11initializedE>
  SREG = sreg;
     33c:	cf bf       	out	0x3f, r28	; 63
}
     33e:	cf 91       	pop	r28
     340:	08 95       	ret
    volatile uint8_t *reg = portModeRegister(port);

    // if the SS pin is not already configured as an output
    // then set it high (to enable the internal pull-up resistor)
    if(!(*reg & bit)){
      digitalWrite(SS, HIGH);
     342:	61 e0       	ldi	r22, 0x01	; 1
     344:	8a e0       	ldi	r24, 0x0A	; 10
     346:	0e 94 fd 00 	call	0x1fa	; 0x1fa <digitalWrite>
     34a:	e1 cf       	rjmp	.-62     	; 0x30e <_ZN8SPIClass5beginEv+0x30>

0000034c <init>:

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
     34c:	78 94       	sei
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
     34e:	84 b5       	in	r24, 0x24	; 36
     350:	82 60       	ori	r24, 0x02	; 2
     352:	84 bd       	out	0x24, r24	; 36
	sbi(TCCR0A, WGM00);
     354:	84 b5       	in	r24, 0x24	; 36
     356:	81 60       	ori	r24, 0x01	; 1
     358:	84 bd       	out	0x24, r24	; 36
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
     35a:	85 b5       	in	r24, 0x25	; 37
     35c:	82 60       	ori	r24, 0x02	; 2
     35e:	85 bd       	out	0x25, r24	; 37
	sbi(TCCR0B, CS00);
     360:	85 b5       	in	r24, 0x25	; 37
     362:	81 60       	ori	r24, 0x01	; 1
     364:	85 bd       	out	0x25, r24	; 37

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
     366:	ee e6       	ldi	r30, 0x6E	; 110
     368:	f0 e0       	ldi	r31, 0x00	; 0
     36a:	80 81       	ld	r24, Z
     36c:	81 60       	ori	r24, 0x01	; 1
     36e:	80 83       	st	Z, r24
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
     370:	e1 e8       	ldi	r30, 0x81	; 129
     372:	f0 e0       	ldi	r31, 0x00	; 0
     374:	10 82       	st	Z, r1

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
     376:	80 81       	ld	r24, Z
     378:	82 60       	ori	r24, 0x02	; 2
     37a:	80 83       	st	Z, r24
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
     37c:	80 81       	ld	r24, Z
     37e:	81 60       	ori	r24, 0x01	; 1
     380:	80 83       	st	Z, r24
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
     382:	e0 e8       	ldi	r30, 0x80	; 128
     384:	f0 e0       	ldi	r31, 0x00	; 0
     386:	80 81       	ld	r24, Z
     388:	81 60       	ori	r24, 0x01	; 1
     38a:	80 83       	st	Z, r24

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
     38c:	e1 eb       	ldi	r30, 0xB1	; 177
     38e:	f0 e0       	ldi	r31, 0x00	; 0
     390:	80 81       	ld	r24, Z
     392:	84 60       	ori	r24, 0x04	; 4
     394:	80 83       	st	Z, r24

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
     396:	e0 eb       	ldi	r30, 0xB0	; 176
     398:	f0 e0       	ldi	r31, 0x00	; 0
     39a:	80 81       	ld	r24, Z
     39c:	81 60       	ori	r24, 0x01	; 1
     39e:	80 83       	st	Z, r24
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
     3a0:	ea e7       	ldi	r30, 0x7A	; 122
     3a2:	f0 e0       	ldi	r31, 0x00	; 0
     3a4:	80 81       	ld	r24, Z
     3a6:	84 60       	ori	r24, 0x04	; 4
     3a8:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS1);
     3aa:	80 81       	ld	r24, Z
     3ac:	82 60       	ori	r24, 0x02	; 2
     3ae:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS0);
     3b0:	80 81       	ld	r24, Z
     3b2:	81 60       	ori	r24, 0x01	; 1
     3b4:	80 83       	st	Z, r24
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
     3b6:	80 81       	ld	r24, Z
     3b8:	80 68       	ori	r24, 0x80	; 128
     3ba:	80 83       	st	Z, r24
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
     3bc:	10 92 c1 00 	sts	0x00C1, r1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
#endif
}
     3c0:	08 95       	ret

000003c2 <delayMicroseconds>:
#elif F_CPU >= 16000000L
	// for the 16 MHz clock on most Arduino boards

	// for a one-microsecond delay, simply return.  the overhead
	// of the function call takes 14 (16) cycles, which is 1us
	if (us <= 1) return; //  = 3 cycles, (4 when true)
     3c2:	82 30       	cpi	r24, 0x02	; 2
     3c4:	91 05       	cpc	r25, r1
     3c6:	38 f0       	brcs	.+14     	; 0x3d6 <delayMicroseconds+0x14>

	// the following loop takes 1/4 of a microsecond (4 cycles)
	// per iteration, so execute it four times for each microsecond of
	// delay requested.
	us <<= 2; // x4 us, = 4 cycles
     3c8:	88 0f       	add	r24, r24
     3ca:	99 1f       	adc	r25, r25
     3cc:	88 0f       	add	r24, r24
     3ce:	99 1f       	adc	r25, r25

	// account for the time taken in the preceeding commands.
	// we just burned 19 (21) cycles above, remove 5, (5*4=20)
	// us is at least 8 so we can substract 5
	us -= 5; // = 2 cycles,
     3d0:	05 97       	sbiw	r24, 0x05	; 5
	

#endif

	// busy wait
	__asm__ __volatile__ (
     3d2:	01 97       	sbiw	r24, 0x01	; 1
     3d4:	f1 f7       	brne	.-4      	; 0x3d2 <delayMicroseconds+0x10>
		"1: sbiw %0,1" "\n\t" // 2 cycles
		"brne 1b" : "=w" (us) : "0" (us) // 2 cycles
	);
	// return = 4 cycles
}
     3d6:	08 95       	ret

000003d8 <micros>:
	return m;
}

unsigned long micros() {
	unsigned long m;
	uint8_t oldSREG = SREG, t;
     3d8:	3f b7       	in	r19, 0x3f	; 63
	
	cli();
     3da:	f8 94       	cli
	m = timer0_overflow_count;
     3dc:	80 91 93 07 	lds	r24, 0x0793	; 0x800793 <timer0_overflow_count>
     3e0:	90 91 94 07 	lds	r25, 0x0794	; 0x800794 <timer0_overflow_count+0x1>
     3e4:	a0 91 95 07 	lds	r26, 0x0795	; 0x800795 <timer0_overflow_count+0x2>
     3e8:	b0 91 96 07 	lds	r27, 0x0796	; 0x800796 <timer0_overflow_count+0x3>
#if defined(TCNT0)
	t = TCNT0;
     3ec:	26 b5       	in	r18, 0x26	; 38
#else
	#error TIMER 0 not defined
#endif

#ifdef TIFR0
	if ((TIFR0 & _BV(TOV0)) && (t < 255))
     3ee:	a8 9b       	sbis	0x15, 0	; 21
     3f0:	05 c0       	rjmp	.+10     	; 0x3fc <micros+0x24>
     3f2:	2f 3f       	cpi	r18, 0xFF	; 255
     3f4:	19 f0       	breq	.+6      	; 0x3fc <micros+0x24>
		m++;
     3f6:	01 96       	adiw	r24, 0x01	; 1
     3f8:	a1 1d       	adc	r26, r1
     3fa:	b1 1d       	adc	r27, r1
#else
	if ((TIFR & _BV(TOV0)) && (t < 255))
		m++;
#endif

	SREG = oldSREG;
     3fc:	3f bf       	out	0x3f, r19	; 63
	
	return ((m << 8) + t) * (64 / clockCyclesPerMicrosecond());
     3fe:	ba 2f       	mov	r27, r26
     400:	a9 2f       	mov	r26, r25
     402:	98 2f       	mov	r25, r24
     404:	88 27       	eor	r24, r24
     406:	bc 01       	movw	r22, r24
     408:	cd 01       	movw	r24, r26
     40a:	62 0f       	add	r22, r18
     40c:	71 1d       	adc	r23, r1
     40e:	81 1d       	adc	r24, r1
     410:	91 1d       	adc	r25, r1
     412:	66 0f       	add	r22, r22
     414:	77 1f       	adc	r23, r23
     416:	88 1f       	adc	r24, r24
     418:	99 1f       	adc	r25, r25
     41a:	66 0f       	add	r22, r22
     41c:	77 1f       	adc	r23, r23
     41e:	88 1f       	adc	r24, r24
     420:	99 1f       	adc	r25, r25
}
     422:	08 95       	ret

00000424 <millis>:
}

unsigned long millis()
{
	unsigned long m;
	uint8_t oldSREG = SREG;
     424:	2f b7       	in	r18, 0x3f	; 63

	// disable interrupts while we read timer0_millis or we might get an
	// inconsistent value (e.g. in the middle of a write to timer0_millis)
	cli();
     426:	f8 94       	cli
	m = timer0_millis;
     428:	60 91 8f 07 	lds	r22, 0x078F	; 0x80078f <timer0_millis>
     42c:	70 91 90 07 	lds	r23, 0x0790	; 0x800790 <timer0_millis+0x1>
     430:	80 91 91 07 	lds	r24, 0x0791	; 0x800791 <timer0_millis+0x2>
     434:	90 91 92 07 	lds	r25, 0x0792	; 0x800792 <timer0_millis+0x3>
	SREG = oldSREG;
     438:	2f bf       	out	0x3f, r18	; 63

	return m;
}
     43a:	08 95       	ret

0000043c <_ZnwjPv>:

void *operator new[](size_t size) {
  return malloc(size);
}

void * operator new(size_t size, void * ptr) noexcept {
     43c:	cb 01       	movw	r24, r22
  (void)size;
  return ptr;
}
     43e:	08 95       	ret

00000440 <initVariant>:
int atexit(void (* /*func*/ )()) { return 0; }

// Weak empty variant initialization function.
// May be redefined by variant files.
void initVariant() __attribute__((weak));
void initVariant() { }
     440:	08 95       	ret

00000442 <__empty>:
 * Its defined as a weak symbol and it can be redefined to implement a
 * real cooperative scheduler.
 */
static void __empty() {
	// Empty
}
     442:	08 95       	ret

00000444 <delay>:
	
	return ((m << 8) + t) * (64 / clockCyclesPerMicrosecond());
}

void delay(unsigned long ms)
{
     444:	8f 92       	push	r8
     446:	9f 92       	push	r9
     448:	af 92       	push	r10
     44a:	bf 92       	push	r11
     44c:	cf 92       	push	r12
     44e:	df 92       	push	r13
     450:	ef 92       	push	r14
     452:	ff 92       	push	r15
     454:	6b 01       	movw	r12, r22
     456:	7c 01       	movw	r14, r24
	uint32_t start = micros();
     458:	0e 94 ec 01 	call	0x3d8	; 0x3d8 <micros>
     45c:	4b 01       	movw	r8, r22
     45e:	5c 01       	movw	r10, r24
     460:	1b c0       	rjmp	.+54     	; 0x498 <delay+0x54>

	while (ms > 0) {
		yield();
		while ( ms > 0 && (micros() - start) >= 1000) {
			ms--;
     462:	21 e0       	ldi	r18, 0x01	; 1
     464:	c2 1a       	sub	r12, r18
     466:	d1 08       	sbc	r13, r1
     468:	e1 08       	sbc	r14, r1
     46a:	f1 08       	sbc	r15, r1
			start += 1000;
     46c:	88 ee       	ldi	r24, 0xE8	; 232
     46e:	88 0e       	add	r8, r24
     470:	83 e0       	ldi	r24, 0x03	; 3
     472:	98 1e       	adc	r9, r24
     474:	a1 1c       	adc	r10, r1
     476:	b1 1c       	adc	r11, r1
{
	uint32_t start = micros();

	while (ms > 0) {
		yield();
		while ( ms > 0 && (micros() - start) >= 1000) {
     478:	c1 14       	cp	r12, r1
     47a:	d1 04       	cpc	r13, r1
     47c:	e1 04       	cpc	r14, r1
     47e:	f1 04       	cpc	r15, r1
     480:	59 f0       	breq	.+22     	; 0x498 <delay+0x54>
     482:	0e 94 ec 01 	call	0x3d8	; 0x3d8 <micros>
     486:	68 19       	sub	r22, r8
     488:	79 09       	sbc	r23, r9
     48a:	8a 09       	sbc	r24, r10
     48c:	9b 09       	sbc	r25, r11
     48e:	68 3e       	cpi	r22, 0xE8	; 232
     490:	73 40       	sbci	r23, 0x03	; 3
     492:	81 05       	cpc	r24, r1
     494:	91 05       	cpc	r25, r1
     496:	28 f7       	brcc	.-54     	; 0x462 <delay+0x1e>

void delay(unsigned long ms)
{
	uint32_t start = micros();

	while (ms > 0) {
     498:	c1 14       	cp	r12, r1
     49a:	d1 04       	cpc	r13, r1
     49c:	e1 04       	cpc	r14, r1
     49e:	f1 04       	cpc	r15, r1
     4a0:	59 f7       	brne	.-42     	; 0x478 <delay+0x34>
		while ( ms > 0 && (micros() - start) >= 1000) {
			ms--;
			start += 1000;
		}
	}
}
     4a2:	ff 90       	pop	r15
     4a4:	ef 90       	pop	r14
     4a6:	df 90       	pop	r13
     4a8:	cf 90       	pop	r12
     4aa:	bf 90       	pop	r11
     4ac:	af 90       	pop	r10
     4ae:	9f 90       	pop	r9
     4b0:	8f 90       	pop	r8
     4b2:	08 95       	ret

000004b4 <_ZNK6String14StringIfHelperEv>:
{
	// use a function pointer to allow for "if (s)" without the
	// complications of an operator bool(). for more information, see:
	// http://www.artima.com/cppsource/safebool.html
	typedef void (String::*StringIfHelperType)() const;
	void StringIfHelper() const {}
     4b4:	08 95       	ret

000004b6 <detachInterrupt>:
    }
  }
}

void detachInterrupt(uint8_t interruptNum) {
  if(interruptNum < EXTERNAL_NUM_INTERRUPTS) {
     4b6:	82 30       	cpi	r24, 0x02	; 2
     4b8:	08 f0       	brcs	.+2      	; 0x4bc <detachInterrupt+0x6>
#endif
    }
      
    intFunc[interruptNum] = nothing;
  }
}
     4ba:	08 95       	ret
void detachInterrupt(uint8_t interruptNum) {
  if(interruptNum < EXTERNAL_NUM_INTERRUPTS) {
    // Disable the interrupt.  (We can't assume that interruptNum is equal
    // to the number of the EIMSK bit to clear, as this isn't true on the 
    // ATmega8.  There, INT0 is 6 and INT1 is 7.)
    switch (interruptNum) {
     4bc:	e8 2f       	mov	r30, r24
     4be:	f0 e0       	ldi	r31, 0x00	; 0
     4c0:	88 23       	and	r24, r24
     4c2:	59 f0       	breq	.+22     	; 0x4da <detachInterrupt+0x24>
     4c4:	81 30       	cpi	r24, 0x01	; 1
     4c6:	69 f0       	breq	.+26     	; 0x4e2 <detachInterrupt+0x2c>
    #endif
      break;       
#endif
    }
      
    intFunc[interruptNum] = nothing;
     4c8:	ee 0f       	add	r30, r30
     4ca:	ff 1f       	adc	r31, r31
     4cc:	ef 5f       	subi	r30, 0xFF	; 255
     4ce:	fe 4f       	sbci	r31, 0xFE	; 254
     4d0:	85 e7       	ldi	r24, 0x75	; 117
     4d2:	92 e0       	ldi	r25, 0x02	; 2
     4d4:	91 83       	std	Z+1, r25	; 0x01
     4d6:	80 83       	st	Z, r24
     4d8:	f0 cf       	rjmp	.-32     	; 0x4ba <detachInterrupt+0x4>
      EIMSK &= ~(1 << INT7);
      break;
#else
    case 0:
    #if defined(EIMSK) && defined(INT0)
      EIMSK &= ~(1 << INT0);
     4da:	8d b3       	in	r24, 0x1d	; 29
     4dc:	8e 7f       	andi	r24, 0xFE	; 254
     4de:	8d bb       	out	0x1d, r24	; 29
     4e0:	f3 cf       	rjmp	.-26     	; 0x4c8 <detachInterrupt+0x12>
    #endif
      break;

    case 1:
    #if defined(EIMSK) && defined(INT1)
      EIMSK &= ~(1 << INT1);
     4e2:	8d b3       	in	r24, 0x1d	; 29
     4e4:	8d 7f       	andi	r24, 0xFD	; 253
     4e6:	8d bb       	out	0x1d, r24	; 29
     4e8:	ef cf       	rjmp	.-34     	; 0x4c8 <detachInterrupt+0x12>

000004ea <nothing>:
#include <stdio.h>

#include "wiring_private.h"

static void nothing(void) {
}
     4ea:	08 95       	ret

000004ec <attachInterrupt>:
    nothing,
#endif
};

void attachInterrupt(uint8_t interruptNum, void (*userFunc)(void), int mode) {
  if(interruptNum < EXTERNAL_NUM_INTERRUPTS) {
     4ec:	82 30       	cpi	r24, 0x02	; 2
     4ee:	08 f0       	brcs	.+2      	; 0x4f2 <attachInterrupt+0x6>
    #endif
      break;
#endif
    }
  }
}
     4f0:	08 95       	ret
#endif
};

void attachInterrupt(uint8_t interruptNum, void (*userFunc)(void), int mode) {
  if(interruptNum < EXTERNAL_NUM_INTERRUPTS) {
    intFunc[interruptNum] = userFunc;
     4f2:	e8 2f       	mov	r30, r24
     4f4:	f0 e0       	ldi	r31, 0x00	; 0
     4f6:	ee 0f       	add	r30, r30
     4f8:	ff 1f       	adc	r31, r31
     4fa:	ef 5f       	subi	r30, 0xFF	; 255
     4fc:	fe 4f       	sbci	r31, 0xFE	; 254
     4fe:	71 83       	std	Z+1, r23	; 0x01
     500:	60 83       	st	Z, r22
    // to the configuration bits in the hardware register, so we simply shift
    // the mode into place.
      
    // Enable the interrupt.
      
    switch (interruptNum) {
     502:	88 23       	and	r24, r24
     504:	19 f0       	breq	.+6      	; 0x50c <attachInterrupt+0x20>
     506:	81 30       	cpi	r24, 0x01	; 1
     508:	59 f0       	breq	.+22     	; 0x520 <attachInterrupt+0x34>
     50a:	08 95       	ret
      EIMSK |= (1 << INT7);
      break;
#else		
    case 0:
    #if defined(EICRA) && defined(ISC00) && defined(EIMSK)
      EICRA = (EICRA & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);
     50c:	e9 e6       	ldi	r30, 0x69	; 105
     50e:	f0 e0       	ldi	r31, 0x00	; 0
     510:	80 81       	ld	r24, Z
     512:	8c 7f       	andi	r24, 0xFC	; 252
     514:	48 2b       	or	r20, r24
     516:	40 83       	st	Z, r20
      EIMSK |= (1 << INT0);
     518:	8d b3       	in	r24, 0x1d	; 29
     51a:	81 60       	ori	r24, 0x01	; 1
     51c:	8d bb       	out	0x1d, r24	; 29
     51e:	08 95       	ret
    #endif
      break;

    case 1:
    #if defined(EICRA) && defined(ISC10) && defined(ISC11) && defined(EIMSK)
      EICRA = (EICRA & ~((1 << ISC10) | (1 << ISC11))) | (mode << ISC10);
     520:	e9 e6       	ldi	r30, 0x69	; 105
     522:	f0 e0       	ldi	r31, 0x00	; 0
     524:	80 81       	ld	r24, Z
     526:	83 7f       	andi	r24, 0xF3	; 243
     528:	44 0f       	add	r20, r20
     52a:	55 1f       	adc	r21, r21
     52c:	44 0f       	add	r20, r20
     52e:	55 1f       	adc	r21, r21
     530:	48 2b       	or	r20, r24
     532:	40 83       	st	Z, r20
      EIMSK |= (1 << INT1);
     534:	8d b3       	in	r24, 0x1d	; 29
     536:	82 60       	ori	r24, 0x02	; 2
     538:	8d bb       	out	0x1d, r24	; 29
     53a:	da cf       	rjmp	.-76     	; 0x4f0 <attachInterrupt+0x4>

0000053c <_Z12disableTimerh>:
// XXX: this function only works properly for timer 2 (the only one we use
// currently).  for the others, it should end the tone, but won't restore
// proper PWM functionality for the timer.
void disableTimer(uint8_t _timer)
{
  switch (_timer)
     53c:	81 30       	cpi	r24, 0x01	; 1
     53e:	39 f0       	breq	.+14     	; 0x54e <_Z12disableTimerh+0x12>
     540:	18 f0       	brcs	.+6      	; 0x548 <_Z12disableTimerh+0xc>
     542:	82 30       	cpi	r24, 0x02	; 2
     544:	51 f0       	breq	.+20     	; 0x55a <_Z12disableTimerh+0x1e>
     546:	08 95       	ret
  {
    case 0:
      #if defined(TIMSK0)
        TIMSK0 = 0;
     548:	10 92 6e 00 	sts	0x006E, r1	; 0x80006e <__TEXT_REGION_LENGTH__+0x7e006e>
     54c:	08 95       	ret
      #endif
      break;

#if defined(TIMSK1) && defined(OCIE1A)
    case 1:
      bitWrite(TIMSK1, OCIE1A, 0);
     54e:	ef e6       	ldi	r30, 0x6F	; 111
     550:	f0 e0       	ldi	r31, 0x00	; 0
     552:	80 81       	ld	r24, Z
     554:	8d 7f       	andi	r24, 0xFD	; 253
     556:	80 83       	st	Z, r24
     558:	08 95       	ret
      break;
#endif

    case 2:
      #if defined(TIMSK2) && defined(OCIE2A)
        bitWrite(TIMSK2, OCIE2A, 0); // disable interrupt
     55a:	e0 e7       	ldi	r30, 0x70	; 112
     55c:	f0 e0       	ldi	r31, 0x00	; 0
     55e:	80 81       	ld	r24, Z
     560:	8d 7f       	andi	r24, 0xFD	; 253
     562:	80 83       	st	Z, r24
      #endif
      #if defined(TCCR2A) && defined(WGM20)
        TCCR2A = (1 << WGM20);
     564:	81 e0       	ldi	r24, 0x01	; 1
     566:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7e00b0>
      #endif
      #if defined(TCCR2B) && defined(CS22)
        TCCR2B = (TCCR2B & 0b11111000) | (1 << CS22);
     56a:	e1 eb       	ldi	r30, 0xB1	; 177
     56c:	f0 e0       	ldi	r31, 0x00	; 0
     56e:	80 81       	ld	r24, Z
     570:	88 7f       	andi	r24, 0xF8	; 248
     572:	84 60       	ori	r24, 0x04	; 4
     574:	80 83       	st	Z, r24
      #endif
      #if defined(OCR2A)
        OCR2A = 0;
     576:	10 92 b3 00 	sts	0x00B3, r1	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7e00b3>
    case 5:
      bitWrite(TIMSK5, OCIE5A, 0);
      break;
#endif
  }
}
     57a:	08 95       	ret

0000057c <_Z6noToneh>:


void noTone(uint8_t _pin)
{
     57c:	cf 93       	push	r28
     57e:	c8 2f       	mov	r28, r24
  int8_t _timer = -1;
  
  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
     580:	30 e0       	ldi	r19, 0x00	; 0
     582:	20 e0       	ldi	r18, 0x00	; 0
     584:	12 16       	cp	r1, r18
     586:	13 06       	cpc	r1, r19
     588:	9c f0       	brlt	.+38     	; 0x5b0 <_Z6noToneh+0x34>
    if (tone_pins[i] == _pin) {
     58a:	f9 01       	movw	r30, r18
     58c:	e0 50       	subi	r30, 0x00	; 0
     58e:	ff 4f       	sbci	r31, 0xFF	; 255
     590:	80 81       	ld	r24, Z
     592:	8c 17       	cp	r24, r28
     594:	19 f0       	breq	.+6      	; 0x59c <_Z6noToneh+0x20>

void noTone(uint8_t _pin)
{
  int8_t _timer = -1;
  
  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
     596:	2f 5f       	subi	r18, 0xFF	; 255
     598:	3f 4f       	sbci	r19, 0xFF	; 255
     59a:	f4 cf       	rjmp	.-24     	; 0x584 <_Z6noToneh+0x8>
    if (tone_pins[i] == _pin) {
      _timer = pgm_read_byte(tone_pin_to_timer_PGM + i);
     59c:	f9 01       	movw	r30, r18
     59e:	e8 59       	subi	r30, 0x98	; 152
     5a0:	ff 4f       	sbci	r31, 0xFF	; 255
     5a2:	84 91       	lpm	r24, Z
      tone_pins[i] = 255;
     5a4:	20 50       	subi	r18, 0x00	; 0
     5a6:	3f 4f       	sbci	r19, 0xFF	; 255
     5a8:	9f ef       	ldi	r25, 0xFF	; 255
     5aa:	f9 01       	movw	r30, r18
     5ac:	90 83       	st	Z, r25
     5ae:	01 c0       	rjmp	.+2      	; 0x5b2 <_Z6noToneh+0x36>
}


void noTone(uint8_t _pin)
{
  int8_t _timer = -1;
     5b0:	8f ef       	ldi	r24, 0xFF	; 255
      tone_pins[i] = 255;
      break;
    }
  }
  
  disableTimer(_timer);
     5b2:	0e 94 9e 02 	call	0x53c	; 0x53c <_Z12disableTimerh>

  digitalWrite(_pin, 0);
     5b6:	60 e0       	ldi	r22, 0x00	; 0
     5b8:	8c 2f       	mov	r24, r28
     5ba:	0e 94 fd 00 	call	0x1fa	; 0x1fa <digitalWrite>
}
     5be:	cf 91       	pop	r28
     5c0:	08 95       	ret

000005c2 <_ZL9toneBeginh>:
#endif



static int8_t toneBegin(uint8_t _pin)
{
     5c2:	28 2f       	mov	r18, r24
  int8_t _timer = -1;

  // if we're already using the pin, the timer should be configured.  
  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
     5c4:	f0 e0       	ldi	r31, 0x00	; 0
     5c6:	e0 e0       	ldi	r30, 0x00	; 0
     5c8:	1e 16       	cp	r1, r30
     5ca:	1f 06       	cpc	r1, r31
     5cc:	64 f0       	brlt	.+24     	; 0x5e6 <_ZL9toneBeginh+0x24>
    if (tone_pins[i] == _pin) {
     5ce:	df 01       	movw	r26, r30
     5d0:	a0 50       	subi	r26, 0x00	; 0
     5d2:	bf 4f       	sbci	r27, 0xFF	; 255
     5d4:	9c 91       	ld	r25, X
     5d6:	92 17       	cp	r25, r18
     5d8:	11 f0       	breq	.+4      	; 0x5de <_ZL9toneBeginh+0x1c>
static int8_t toneBegin(uint8_t _pin)
{
  int8_t _timer = -1;

  // if we're already using the pin, the timer should be configured.  
  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
     5da:	31 96       	adiw	r30, 0x01	; 1
     5dc:	f5 cf       	rjmp	.-22     	; 0x5c8 <_ZL9toneBeginh+0x6>
    if (tone_pins[i] == _pin) {
      return pgm_read_byte(tone_pin_to_timer_PGM + i);
     5de:	e8 59       	subi	r30, 0x98	; 152
     5e0:	ff 4f       	sbci	r31, 0xFF	; 255
     5e2:	84 91       	lpm	r24, Z
     5e4:	08 95       	ret
    }
  }
  
  // search for an unused timer.
  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
     5e6:	f0 e0       	ldi	r31, 0x00	; 0
     5e8:	e0 e0       	ldi	r30, 0x00	; 0
     5ea:	1e 16       	cp	r1, r30
     5ec:	1f 06       	cpc	r1, r31
     5ee:	8c f0       	brlt	.+34     	; 0x612 <_ZL9toneBeginh+0x50>
    if (tone_pins[i] == 255) {
     5f0:	df 01       	movw	r26, r30
     5f2:	a0 50       	subi	r26, 0x00	; 0
     5f4:	bf 4f       	sbci	r27, 0xFF	; 255
     5f6:	9c 91       	ld	r25, X
     5f8:	9f 3f       	cpi	r25, 0xFF	; 255
     5fa:	11 f0       	breq	.+4      	; 0x600 <_ZL9toneBeginh+0x3e>
      return pgm_read_byte(tone_pin_to_timer_PGM + i);
    }
  }
  
  // search for an unused timer.
  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
     5fc:	31 96       	adiw	r30, 0x01	; 1
     5fe:	f5 cf       	rjmp	.-22     	; 0x5ea <_ZL9toneBeginh+0x28>
    if (tone_pins[i] == 255) {
      tone_pins[i] = _pin;
     600:	df 01       	movw	r26, r30
     602:	a0 50       	subi	r26, 0x00	; 0
     604:	bf 4f       	sbci	r27, 0xFF	; 255
     606:	2c 93       	st	X, r18
      _timer = pgm_read_byte(tone_pin_to_timer_PGM + i);
     608:	e8 59       	subi	r30, 0x98	; 152
     60a:	ff 4f       	sbci	r31, 0xFF	; 255
     60c:	e4 91       	lpm	r30, Z
     60e:	8e 2f       	mov	r24, r30
     610:	01 c0       	rjmp	.+2      	; 0x614 <_ZL9toneBeginh+0x52>



static int8_t toneBegin(uint8_t _pin)
{
  int8_t _timer = -1;
     612:	8f ef       	ldi	r24, 0xFF	; 255
      _timer = pgm_read_byte(tone_pin_to_timer_PGM + i);
      break;
    }
  }
  
  if (_timer != -1)
     614:	8f 3f       	cpi	r24, 0xFF	; 255
     616:	31 f0       	breq	.+12     	; 0x624 <_ZL9toneBeginh+0x62>
  {
    // Set timer specific stuff
    // All timers in CTC mode
    // 8 bit timers will require changing prescalar values,
    // whereas 16 bit timers are set to either ck/1 or ck/64 prescalar
    switch (_timer)
     618:	81 30       	cpi	r24, 0x01	; 1
     61a:	01 f1       	breq	.+64     	; 0x65c <_ZL9toneBeginh+0x9a>
     61c:	82 30       	cpi	r24, 0x02	; 2
     61e:	09 f4       	brne	.+2      	; 0x622 <_ZL9toneBeginh+0x60>
     620:	3b c0       	rjmp	.+118    	; 0x698 <_ZL9toneBeginh+0xd6>
     622:	81 11       	cpse	r24, r1
      #endif
    }
  }

  return _timer;
}
     624:	08 95       	ret
    switch (_timer)
    {
      #if defined(TCCR0A) && defined(TCCR0B) && defined(WGM01)
      case 0:
        // 8 bit timer
        TCCR0A = 0;
     626:	14 bc       	out	0x24, r1	; 36
        TCCR0B = 0;
     628:	15 bc       	out	0x25, r1	; 37
        bitWrite(TCCR0A, WGM01, 1);
     62a:	94 b5       	in	r25, 0x24	; 36
     62c:	92 60       	ori	r25, 0x02	; 2
     62e:	94 bd       	out	0x24, r25	; 36
        bitWrite(TCCR0B, CS00, 1);
     630:	95 b5       	in	r25, 0x25	; 37
     632:	91 60       	ori	r25, 0x01	; 1
     634:	95 bd       	out	0x25, r25	; 37
        timer0_pin_port = portOutputRegister(digitalPinToPort(_pin));
     636:	30 e0       	ldi	r19, 0x00	; 0
     638:	f9 01       	movw	r30, r18
     63a:	e1 55       	subi	r30, 0x51	; 81
     63c:	ff 4f       	sbci	r31, 0xFF	; 255
     63e:	e4 91       	lpm	r30, Z
     640:	f0 e0       	ldi	r31, 0x00	; 0
     642:	ee 0f       	add	r30, r30
     644:	ff 1f       	adc	r31, r31
     646:	e7 59       	subi	r30, 0x97	; 151
     648:	ff 4f       	sbci	r31, 0xFF	; 255
     64a:	45 91       	lpm	r20, Z+
     64c:	54 91       	lpm	r21, Z
        timer0_pin_mask = digitalPinToBitMask(_pin);
     64e:	25 56       	subi	r18, 0x65	; 101
     650:	3f 4f       	sbci	r19, 0xFF	; 255
     652:	f9 01       	movw	r30, r18
     654:	24 91       	lpm	r18, Z
     656:	20 93 7e 07 	sts	0x077E, r18	; 0x80077e <timer0_pin_mask>
     65a:	08 95       	ret
      #endif

      #if defined(TCCR1A) && defined(TCCR1B) && defined(WGM12)
      case 1:
        // 16 bit timer
        TCCR1A = 0;
     65c:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
        TCCR1B = 0;
     660:	e1 e8       	ldi	r30, 0x81	; 129
     662:	f0 e0       	ldi	r31, 0x00	; 0
     664:	10 82       	st	Z, r1
        bitWrite(TCCR1B, WGM12, 1);
     666:	90 81       	ld	r25, Z
     668:	98 60       	ori	r25, 0x08	; 8
     66a:	90 83       	st	Z, r25
        bitWrite(TCCR1B, CS10, 1);
     66c:	90 81       	ld	r25, Z
     66e:	91 60       	ori	r25, 0x01	; 1
     670:	90 83       	st	Z, r25
        timer1_pin_port = portOutputRegister(digitalPinToPort(_pin));
     672:	30 e0       	ldi	r19, 0x00	; 0
     674:	f9 01       	movw	r30, r18
     676:	e1 55       	subi	r30, 0x51	; 81
     678:	ff 4f       	sbci	r31, 0xFF	; 255
     67a:	e4 91       	lpm	r30, Z
     67c:	f0 e0       	ldi	r31, 0x00	; 0
     67e:	ee 0f       	add	r30, r30
     680:	ff 1f       	adc	r31, r31
     682:	e7 59       	subi	r30, 0x97	; 151
     684:	ff 4f       	sbci	r31, 0xFF	; 255
     686:	45 91       	lpm	r20, Z+
     688:	54 91       	lpm	r21, Z
        timer1_pin_mask = digitalPinToBitMask(_pin);
     68a:	25 56       	subi	r18, 0x65	; 101
     68c:	3f 4f       	sbci	r19, 0xFF	; 255
     68e:	f9 01       	movw	r30, r18
     690:	24 91       	lpm	r18, Z
     692:	20 93 7d 07 	sts	0x077D, r18	; 0x80077d <timer1_pin_mask>
     696:	08 95       	ret
      #endif

      #if defined(TCCR2A) && defined(TCCR2B)
      case 2:
        // 8 bit timer
        TCCR2A = 0;
     698:	a0 eb       	ldi	r26, 0xB0	; 176
     69a:	b0 e0       	ldi	r27, 0x00	; 0
     69c:	1c 92       	st	X, r1
        TCCR2B = 0;
     69e:	e1 eb       	ldi	r30, 0xB1	; 177
     6a0:	f0 e0       	ldi	r31, 0x00	; 0
     6a2:	10 82       	st	Z, r1
        bitWrite(TCCR2A, WGM21, 1);
     6a4:	9c 91       	ld	r25, X
     6a6:	92 60       	ori	r25, 0x02	; 2
     6a8:	9c 93       	st	X, r25
        bitWrite(TCCR2B, CS20, 1);
     6aa:	90 81       	ld	r25, Z
     6ac:	91 60       	ori	r25, 0x01	; 1
     6ae:	90 83       	st	Z, r25
        timer2_pin_port = portOutputRegister(digitalPinToPort(_pin));
     6b0:	30 e0       	ldi	r19, 0x00	; 0
     6b2:	f9 01       	movw	r30, r18
     6b4:	e1 55       	subi	r30, 0x51	; 81
     6b6:	ff 4f       	sbci	r31, 0xFF	; 255
     6b8:	e4 91       	lpm	r30, Z
     6ba:	f0 e0       	ldi	r31, 0x00	; 0
     6bc:	ee 0f       	add	r30, r30
     6be:	ff 1f       	adc	r31, r31
     6c0:	e7 59       	subi	r30, 0x97	; 151
     6c2:	ff 4f       	sbci	r31, 0xFF	; 255
     6c4:	45 91       	lpm	r20, Z+
     6c6:	54 91       	lpm	r21, Z
     6c8:	50 93 88 07 	sts	0x0788, r21	; 0x800788 <timer2_pin_port+0x1>
     6cc:	40 93 87 07 	sts	0x0787, r20	; 0x800787 <timer2_pin_port>
        timer2_pin_mask = digitalPinToBitMask(_pin);
     6d0:	25 56       	subi	r18, 0x65	; 101
     6d2:	3f 4f       	sbci	r19, 0xFF	; 255
     6d4:	f9 01       	movw	r30, r18
     6d6:	24 91       	lpm	r18, Z
     6d8:	20 93 89 07 	sts	0x0789, r18	; 0x800789 <timer2_pin_mask>
     6dc:	a3 cf       	rjmp	.-186    	; 0x624 <_ZL9toneBeginh+0x62>

000006de <_Z4tonehjm>:


// frequency (in hertz) and duration (in milliseconds).

void tone(uint8_t _pin, unsigned int frequency, unsigned long duration)
{
     6de:	4f 92       	push	r4
     6e0:	5f 92       	push	r5
     6e2:	6f 92       	push	r6
     6e4:	7f 92       	push	r7
     6e6:	8f 92       	push	r8
     6e8:	9f 92       	push	r9
     6ea:	af 92       	push	r10
     6ec:	bf 92       	push	r11
     6ee:	cf 92       	push	r12
     6f0:	df 92       	push	r13
     6f2:	ef 92       	push	r14
     6f4:	ff 92       	push	r15
     6f6:	0f 93       	push	r16
     6f8:	1f 93       	push	r17
     6fa:	cf 93       	push	r28
     6fc:	df 93       	push	r29
     6fe:	00 d0       	rcall	.+0      	; 0x700 <_Z4tonehjm+0x22>
     700:	00 d0       	rcall	.+0      	; 0x702 <_Z4tonehjm+0x24>
     702:	1f 92       	push	r1
     704:	cd b7       	in	r28, 0x3d	; 61
     706:	de b7       	in	r29, 0x3e	; 62
     708:	f8 2e       	mov	r15, r24
     70a:	8b 01       	movw	r16, r22
     70c:	49 01       	movw	r8, r18
     70e:	5a 01       	movw	r10, r20
  uint8_t prescalarbits = 0b001;
  long toggle_count = 0;
  uint32_t ocr = 0;
  int8_t _timer;

  _timer = toneBegin(_pin);
     710:	0e 94 e1 02 	call	0x5c2	; 0x5c2 <_ZL9toneBeginh>
     714:	8d 83       	std	Y+5, r24	; 0x05

  if (_timer >= 0)
     716:	88 23       	and	r24, r24
     718:	0c f4       	brge	.+2      	; 0x71c <_Z4tonehjm+0x3e>
     71a:	18 c1       	rjmp	.+560    	; 0x94c <__stack+0x4d>
  {
    // Set the pinMode as OUTPUT
    pinMode(_pin, OUTPUT);
     71c:	61 e0       	ldi	r22, 0x01	; 1
     71e:	8f 2d       	mov	r24, r15
     720:	0e 94 30 01 	call	0x260	; 0x260 <pinMode>
    
    // if we are using an 8 bit timer, scan through prescalars to find the best fit
    if (_timer == 0 || _timer == 2)
     724:	8d 81       	ldd	r24, Y+5	; 0x05
     726:	88 23       	and	r24, r24
     728:	59 f1       	breq	.+86     	; 0x780 <_Z4tonehjm+0xa2>
     72a:	82 30       	cpi	r24, 0x02	; 2
     72c:	49 f1       	breq	.+82     	; 0x780 <_Z4tonehjm+0xa2>
#endif
    }
    else
    {
      // two choices for the 16 bit timers: ck/1 or ck/64
      ocr = F_CPU / frequency / 2 - 1;
     72e:	71 2c       	mov	r7, r1
     730:	61 2c       	mov	r6, r1
     732:	60 e0       	ldi	r22, 0x00	; 0
     734:	72 e1       	ldi	r23, 0x12	; 18
     736:	8a e7       	ldi	r24, 0x7A	; 122
     738:	90 e0       	ldi	r25, 0x00	; 0
     73a:	a3 01       	movw	r20, r6
     73c:	98 01       	movw	r18, r16
     73e:	0e 94 32 3b 	call	0x7664	; 0x7664 <__divmodsi4>
     742:	69 01       	movw	r12, r18
     744:	7a 01       	movw	r14, r20
     746:	81 e0       	ldi	r24, 0x01	; 1
     748:	c8 1a       	sub	r12, r24
     74a:	d1 08       	sbc	r13, r1
     74c:	e1 08       	sbc	r14, r1
     74e:	f1 08       	sbc	r15, r1

      prescalarbits = 0b001;
      if (ocr > 0xffff)
     750:	c1 14       	cp	r12, r1
     752:	d1 04       	cpc	r13, r1
     754:	81 e0       	ldi	r24, 0x01	; 1
     756:	e8 06       	cpc	r14, r24
     758:	f1 04       	cpc	r15, r1
     75a:	08 f4       	brcc	.+2      	; 0x75e <_Z4tonehjm+0x80>
     75c:	16 c1       	rjmp	.+556    	; 0x98a <__stack+0x8b>
      {
        ocr = F_CPU / frequency / 2 / 64 - 1;
     75e:	68 e4       	ldi	r22, 0x48	; 72
     760:	78 ee       	ldi	r23, 0xE8	; 232
     762:	81 e0       	ldi	r24, 0x01	; 1
     764:	90 e0       	ldi	r25, 0x00	; 0
     766:	a3 01       	movw	r20, r6
     768:	98 01       	movw	r18, r16
     76a:	0e 94 32 3b 	call	0x7664	; 0x7664 <__divmodsi4>
     76e:	69 01       	movw	r12, r18
     770:	7a 01       	movw	r14, r20
     772:	81 e0       	ldi	r24, 0x01	; 1
     774:	c8 1a       	sub	r12, r24
     776:	d1 08       	sbc	r13, r1
     778:	e1 08       	sbc	r14, r1
     77a:	f1 08       	sbc	r15, r1
        prescalarbits = 0b011;
     77c:	93 e0       	ldi	r25, 0x03	; 3
     77e:	06 c1       	rjmp	.+524    	; 0x98c <__stack+0x8d>
    pinMode(_pin, OUTPUT);
    
    // if we are using an 8 bit timer, scan through prescalars to find the best fit
    if (_timer == 0 || _timer == 2)
    {
      ocr = F_CPU / frequency / 2 - 1;
     780:	28 01       	movw	r4, r16
     782:	71 2c       	mov	r7, r1
     784:	61 2c       	mov	r6, r1
     786:	60 e0       	ldi	r22, 0x00	; 0
     788:	72 e1       	ldi	r23, 0x12	; 18
     78a:	8a e7       	ldi	r24, 0x7A	; 122
     78c:	90 e0       	ldi	r25, 0x00	; 0
     78e:	a3 01       	movw	r20, r6
     790:	98 01       	movw	r18, r16
     792:	0e 94 32 3b 	call	0x7664	; 0x7664 <__divmodsi4>
     796:	29 83       	std	Y+1, r18	; 0x01
     798:	3a 83       	std	Y+2, r19	; 0x02
     79a:	4b 83       	std	Y+3, r20	; 0x03
     79c:	5c 83       	std	Y+4, r21	; 0x04
     79e:	69 01       	movw	r12, r18
     7a0:	7a 01       	movw	r14, r20
     7a2:	81 e0       	ldi	r24, 0x01	; 1
     7a4:	c8 1a       	sub	r12, r24
     7a6:	d1 08       	sbc	r13, r1
     7a8:	e1 08       	sbc	r14, r1
     7aa:	f1 08       	sbc	r15, r1
      prescalarbits = 0b001;  // ck/1: same for both timers
      if (ocr > 255)
     7ac:	8f ef       	ldi	r24, 0xFF	; 255
     7ae:	c8 16       	cp	r12, r24
     7b0:	d1 04       	cpc	r13, r1
     7b2:	e1 04       	cpc	r14, r1
     7b4:	f1 04       	cpc	r15, r1
     7b6:	09 f0       	breq	.+2      	; 0x7ba <_Z4tonehjm+0xdc>
     7b8:	08 f4       	brcc	.+2      	; 0x7bc <_Z4tonehjm+0xde>
     7ba:	a4 c0       	rjmp	.+328    	; 0x904 <__stack+0x5>
      {
        ocr = F_CPU / frequency / 2 / 8 - 1;
     7bc:	60 e4       	ldi	r22, 0x40	; 64
     7be:	72 e4       	ldi	r23, 0x42	; 66
     7c0:	8f e0       	ldi	r24, 0x0F	; 15
     7c2:	90 e0       	ldi	r25, 0x00	; 0
     7c4:	a3 01       	movw	r20, r6
     7c6:	98 01       	movw	r18, r16
     7c8:	0e 94 32 3b 	call	0x7664	; 0x7664 <__divmodsi4>
     7cc:	69 01       	movw	r12, r18
     7ce:	7a 01       	movw	r14, r20
     7d0:	81 e0       	ldi	r24, 0x01	; 1
     7d2:	c8 1a       	sub	r12, r24
     7d4:	d1 08       	sbc	r13, r1
     7d6:	e1 08       	sbc	r14, r1
     7d8:	f1 08       	sbc	r15, r1
        prescalarbits = 0b010;  // ck/8: same for both timers

        if (_timer == 2 && ocr > 255)
     7da:	8d 81       	ldd	r24, Y+5	; 0x05
     7dc:	82 30       	cpi	r24, 0x02	; 2
     7de:	09 f4       	brne	.+2      	; 0x7e2 <_Z4tonehjm+0x104>
     7e0:	5a c0       	rjmp	.+180    	; 0x896 <_Z4tonehjm+0x1b8>
      ocr = F_CPU / frequency / 2 - 1;
      prescalarbits = 0b001;  // ck/1: same for both timers
      if (ocr > 255)
      {
        ocr = F_CPU / frequency / 2 / 8 - 1;
        prescalarbits = 0b010;  // ck/8: same for both timers
     7e2:	92 e0       	ldi	r25, 0x02	; 2
        {
          ocr = F_CPU / frequency / 2 / 32 - 1;
          prescalarbits = 0b011;
        }

        if (ocr > 255)
     7e4:	8f ef       	ldi	r24, 0xFF	; 255
     7e6:	c8 16       	cp	r12, r24
     7e8:	d1 04       	cpc	r13, r1
     7ea:	e1 04       	cpc	r14, r1
     7ec:	f1 04       	cpc	r15, r1
     7ee:	09 f0       	breq	.+2      	; 0x7f2 <_Z4tonehjm+0x114>
     7f0:	08 f4       	brcc	.+2      	; 0x7f4 <_Z4tonehjm+0x116>
     7f2:	89 c0       	rjmp	.+274    	; 0x906 <__stack+0x7>
        {
          ocr = F_CPU / frequency / 2 / 64 - 1;
     7f4:	68 e4       	ldi	r22, 0x48	; 72
     7f6:	78 ee       	ldi	r23, 0xE8	; 232
     7f8:	81 e0       	ldi	r24, 0x01	; 1
     7fa:	90 e0       	ldi	r25, 0x00	; 0
     7fc:	a3 01       	movw	r20, r6
     7fe:	92 01       	movw	r18, r4
     800:	0e 94 32 3b 	call	0x7664	; 0x7664 <__divmodsi4>
     804:	69 01       	movw	r12, r18
     806:	7a 01       	movw	r14, r20
     808:	81 e0       	ldi	r24, 0x01	; 1
     80a:	c8 1a       	sub	r12, r24
     80c:	d1 08       	sbc	r13, r1
     80e:	e1 08       	sbc	r14, r1
     810:	f1 08       	sbc	r15, r1
          prescalarbits = _timer == 0 ? 0b011 : 0b100;
     812:	8d 81       	ldd	r24, Y+5	; 0x05
     814:	81 11       	cpse	r24, r1
     816:	59 c0       	rjmp	.+178    	; 0x8ca <_Z4tonehjm+0x1ec>
     818:	93 e0       	ldi	r25, 0x03	; 3

          if (_timer == 2 && ocr > 255)
     81a:	8d 81       	ldd	r24, Y+5	; 0x05
     81c:	82 30       	cpi	r24, 0x02	; 2
     81e:	09 f4       	brne	.+2      	; 0x822 <_Z4tonehjm+0x144>
     820:	56 c0       	rjmp	.+172    	; 0x8ce <_Z4tonehjm+0x1f0>
          {
            ocr = F_CPU / frequency / 2 / 128 - 1;
            prescalarbits = 0b101;
          }

          if (ocr > 255)
     822:	8f ef       	ldi	r24, 0xFF	; 255
     824:	c8 16       	cp	r12, r24
     826:	d1 04       	cpc	r13, r1
     828:	e1 04       	cpc	r14, r1
     82a:	f1 04       	cpc	r15, r1
     82c:	09 f0       	breq	.+2      	; 0x830 <_Z4tonehjm+0x152>
     82e:	08 f4       	brcc	.+2      	; 0x832 <_Z4tonehjm+0x154>
     830:	6a c0       	rjmp	.+212    	; 0x906 <__stack+0x7>
          {
            ocr = F_CPU / frequency / 2 / 256 - 1;
     832:	62 e1       	ldi	r22, 0x12	; 18
     834:	7a e7       	ldi	r23, 0x7A	; 122
     836:	80 e0       	ldi	r24, 0x00	; 0
     838:	90 e0       	ldi	r25, 0x00	; 0
     83a:	a3 01       	movw	r20, r6
     83c:	92 01       	movw	r18, r4
     83e:	0e 94 32 3b 	call	0x7664	; 0x7664 <__divmodsi4>
     842:	69 01       	movw	r12, r18
     844:	7a 01       	movw	r14, r20
     846:	81 e0       	ldi	r24, 0x01	; 1
     848:	c8 1a       	sub	r12, r24
     84a:	d1 08       	sbc	r13, r1
     84c:	e1 08       	sbc	r14, r1
     84e:	f1 08       	sbc	r15, r1
            prescalarbits = _timer == 0 ? 0b100 : 0b110;
     850:	8d 81       	ldd	r24, Y+5	; 0x05
     852:	81 11       	cpse	r24, r1
     854:	55 c0       	rjmp	.+170    	; 0x900 <__stack+0x1>
     856:	94 e0       	ldi	r25, 0x04	; 4
            if (ocr > 255)
     858:	8f ef       	ldi	r24, 0xFF	; 255
     85a:	c8 16       	cp	r12, r24
     85c:	d1 04       	cpc	r13, r1
     85e:	e1 04       	cpc	r14, r1
     860:	f1 04       	cpc	r15, r1
     862:	09 f0       	breq	.+2      	; 0x866 <_Z4tonehjm+0x188>
     864:	08 f4       	brcc	.+2      	; 0x868 <_Z4tonehjm+0x18a>
     866:	4f c0       	rjmp	.+158    	; 0x906 <__stack+0x7>
            {
              // can't do any better than /1024
              ocr = F_CPU / frequency / 2 / 1024 - 1;
     868:	c9 80       	ldd	r12, Y+1	; 0x01
     86a:	da 80       	ldd	r13, Y+2	; 0x02
     86c:	eb 80       	ldd	r14, Y+3	; 0x03
     86e:	fc 80       	ldd	r15, Y+4	; 0x04
     870:	0b 2e       	mov	r0, r27
     872:	ba e0       	ldi	r27, 0x0A	; 10
     874:	f5 94       	asr	r15
     876:	e7 94       	ror	r14
     878:	d7 94       	ror	r13
     87a:	c7 94       	ror	r12
     87c:	ba 95       	dec	r27
     87e:	d1 f7       	brne	.-12     	; 0x874 <_Z4tonehjm+0x196>
     880:	b0 2d       	mov	r27, r0
     882:	81 e0       	ldi	r24, 0x01	; 1
     884:	c8 1a       	sub	r12, r24
     886:	d1 08       	sbc	r13, r1
     888:	e1 08       	sbc	r14, r1
     88a:	f1 08       	sbc	r15, r1
              prescalarbits = _timer == 0 ? 0b101 : 0b111;
     88c:	8d 81       	ldd	r24, Y+5	; 0x05
     88e:	81 11       	cpse	r24, r1
     890:	73 c0       	rjmp	.+230    	; 0x978 <__stack+0x79>
     892:	95 e0       	ldi	r25, 0x05	; 5
     894:	38 c0       	rjmp	.+112    	; 0x906 <__stack+0x7>
      if (ocr > 255)
      {
        ocr = F_CPU / frequency / 2 / 8 - 1;
        prescalarbits = 0b010;  // ck/8: same for both timers

        if (_timer == 2 && ocr > 255)
     896:	8f ef       	ldi	r24, 0xFF	; 255
     898:	c8 16       	cp	r12, r24
     89a:	d1 04       	cpc	r13, r1
     89c:	e1 04       	cpc	r14, r1
     89e:	f1 04       	cpc	r15, r1
     8a0:	91 f0       	breq	.+36     	; 0x8c6 <_Z4tonehjm+0x1e8>
     8a2:	88 f0       	brcs	.+34     	; 0x8c6 <_Z4tonehjm+0x1e8>
        {
          ocr = F_CPU / frequency / 2 / 32 - 1;
     8a4:	60 e9       	ldi	r22, 0x90	; 144
     8a6:	70 ed       	ldi	r23, 0xD0	; 208
     8a8:	83 e0       	ldi	r24, 0x03	; 3
     8aa:	90 e0       	ldi	r25, 0x00	; 0
     8ac:	a3 01       	movw	r20, r6
     8ae:	98 01       	movw	r18, r16
     8b0:	0e 94 32 3b 	call	0x7664	; 0x7664 <__divmodsi4>
     8b4:	69 01       	movw	r12, r18
     8b6:	7a 01       	movw	r14, r20
     8b8:	81 e0       	ldi	r24, 0x01	; 1
     8ba:	c8 1a       	sub	r12, r24
     8bc:	d1 08       	sbc	r13, r1
     8be:	e1 08       	sbc	r14, r1
     8c0:	f1 08       	sbc	r15, r1
          prescalarbits = 0b011;
     8c2:	93 e0       	ldi	r25, 0x03	; 3
     8c4:	8f cf       	rjmp	.-226    	; 0x7e4 <_Z4tonehjm+0x106>
      ocr = F_CPU / frequency / 2 - 1;
      prescalarbits = 0b001;  // ck/1: same for both timers
      if (ocr > 255)
      {
        ocr = F_CPU / frequency / 2 / 8 - 1;
        prescalarbits = 0b010;  // ck/8: same for both timers
     8c6:	92 e0       	ldi	r25, 0x02	; 2
     8c8:	8d cf       	rjmp	.-230    	; 0x7e4 <_Z4tonehjm+0x106>
        }

        if (ocr > 255)
        {
          ocr = F_CPU / frequency / 2 / 64 - 1;
          prescalarbits = _timer == 0 ? 0b011 : 0b100;
     8ca:	94 e0       	ldi	r25, 0x04	; 4
     8cc:	a6 cf       	rjmp	.-180    	; 0x81a <_Z4tonehjm+0x13c>

          if (_timer == 2 && ocr > 255)
     8ce:	8f ef       	ldi	r24, 0xFF	; 255
     8d0:	c8 16       	cp	r12, r24
     8d2:	d1 04       	cpc	r13, r1
     8d4:	e1 04       	cpc	r14, r1
     8d6:	f1 04       	cpc	r15, r1
     8d8:	09 f0       	breq	.+2      	; 0x8dc <_Z4tonehjm+0x1fe>
     8da:	08 f4       	brcc	.+2      	; 0x8de <_Z4tonehjm+0x200>
     8dc:	a2 cf       	rjmp	.-188    	; 0x822 <_Z4tonehjm+0x144>
          {
            ocr = F_CPU / frequency / 2 / 128 - 1;
     8de:	64 e2       	ldi	r22, 0x24	; 36
     8e0:	74 ef       	ldi	r23, 0xF4	; 244
     8e2:	80 e0       	ldi	r24, 0x00	; 0
     8e4:	90 e0       	ldi	r25, 0x00	; 0
     8e6:	a3 01       	movw	r20, r6
     8e8:	92 01       	movw	r18, r4
     8ea:	0e 94 32 3b 	call	0x7664	; 0x7664 <__divmodsi4>
     8ee:	69 01       	movw	r12, r18
     8f0:	7a 01       	movw	r14, r20
     8f2:	81 e0       	ldi	r24, 0x01	; 1
     8f4:	c8 1a       	sub	r12, r24
     8f6:	d1 08       	sbc	r13, r1
     8f8:	e1 08       	sbc	r14, r1
     8fa:	f1 08       	sbc	r15, r1
            prescalarbits = 0b101;
     8fc:	95 e0       	ldi	r25, 0x05	; 5
     8fe:	91 cf       	rjmp	.-222    	; 0x822 <_Z4tonehjm+0x144>
          }

          if (ocr > 255)
          {
            ocr = F_CPU / frequency / 2 / 256 - 1;
            prescalarbits = _timer == 0 ? 0b100 : 0b110;
     900:	96 e0       	ldi	r25, 0x06	; 6
     902:	aa cf       	rjmp	.-172    	; 0x858 <_Z4tonehjm+0x17a>
    
    // if we are using an 8 bit timer, scan through prescalars to find the best fit
    if (_timer == 0 || _timer == 2)
    {
      ocr = F_CPU / frequency / 2 - 1;
      prescalarbits = 0b001;  // ck/1: same for both timers
     904:	91 e0       	ldi	r25, 0x01	; 1
          }
        }
      }

#if defined(TCCR0B)
      if (_timer == 0)
     906:	8d 81       	ldd	r24, Y+5	; 0x05
     908:	81 11       	cpse	r24, r1
     90a:	38 c0       	rjmp	.+112    	; 0x97c <__stack+0x7d>
      {
        TCCR0B = (TCCR0B & 0b11111000) | prescalarbits;
     90c:	85 b5       	in	r24, 0x25	; 37
     90e:	88 7f       	andi	r24, 0xF8	; 248
     910:	89 2b       	or	r24, r25
     912:	85 bd       	out	0x25, r24	; 37

    }
    

    // Calculate the toggle count
    if (duration > 0)
     914:	81 14       	cp	r8, r1
     916:	91 04       	cpc	r9, r1
     918:	a1 04       	cpc	r10, r1
     91a:	b1 04       	cpc	r11, r1
     91c:	09 f4       	brne	.+2      	; 0x920 <__stack+0x21>
     91e:	40 c0       	rjmp	.+128    	; 0x9a0 <__stack+0xa1>
    {
      toggle_count = 2 * frequency * duration / 1000;
     920:	d8 01       	movw	r26, r16
     922:	aa 0f       	add	r26, r26
     924:	bb 1f       	adc	r27, r27
     926:	a5 01       	movw	r20, r10
     928:	94 01       	movw	r18, r8
     92a:	0e 94 ab 3a 	call	0x7556	; 0x7556 <__muluhisi3>
     92e:	28 ee       	ldi	r18, 0xE8	; 232
     930:	33 e0       	ldi	r19, 0x03	; 3
     932:	40 e0       	ldi	r20, 0x00	; 0
     934:	50 e0       	ldi	r21, 0x00	; 0
     936:	0e 94 10 3b 	call	0x7620	; 0x7620 <__udivmodsi4>
    }

    // Set the OCR for the given timer,
    // set the toggle count,
    // then turn on the interrupts
    switch (_timer)
     93a:	8d 81       	ldd	r24, Y+5	; 0x05
     93c:	81 30       	cpi	r24, 0x01	; 1
     93e:	09 f4       	brne	.+2      	; 0x942 <__stack+0x43>
     940:	42 c0       	rjmp	.+132    	; 0x9c6 <__stack+0xc7>
     942:	82 30       	cpi	r24, 0x02	; 2
     944:	09 f4       	brne	.+2      	; 0x948 <__stack+0x49>
     946:	51 c0       	rjmp	.+162    	; 0x9ea <__stack+0xeb>
     948:	88 23       	and	r24, r24
     94a:	71 f1       	breq	.+92     	; 0x9a8 <__stack+0xa9>
        break;
#endif

    }
  }
}
     94c:	0f 90       	pop	r0
     94e:	0f 90       	pop	r0
     950:	0f 90       	pop	r0
     952:	0f 90       	pop	r0
     954:	0f 90       	pop	r0
     956:	df 91       	pop	r29
     958:	cf 91       	pop	r28
     95a:	1f 91       	pop	r17
     95c:	0f 91       	pop	r16
     95e:	ff 90       	pop	r15
     960:	ef 90       	pop	r14
     962:	df 90       	pop	r13
     964:	cf 90       	pop	r12
     966:	bf 90       	pop	r11
     968:	af 90       	pop	r10
     96a:	9f 90       	pop	r9
     96c:	8f 90       	pop	r8
     96e:	7f 90       	pop	r7
     970:	6f 90       	pop	r6
     972:	5f 90       	pop	r5
     974:	4f 90       	pop	r4
     976:	08 95       	ret
            prescalarbits = _timer == 0 ? 0b100 : 0b110;
            if (ocr > 255)
            {
              // can't do any better than /1024
              ocr = F_CPU / frequency / 2 / 1024 - 1;
              prescalarbits = _timer == 0 ? 0b101 : 0b111;
     978:	97 e0       	ldi	r25, 0x07	; 7
     97a:	c5 cf       	rjmp	.-118    	; 0x906 <__stack+0x7>
      }
      else
#endif
#if defined(TCCR2B)
      {
        TCCR2B = (TCCR2B & 0b11111000) | prescalarbits;
     97c:	e1 eb       	ldi	r30, 0xB1	; 177
     97e:	f0 e0       	ldi	r31, 0x00	; 0
     980:	80 81       	ld	r24, Z
     982:	88 7f       	andi	r24, 0xF8	; 248
     984:	89 2b       	or	r24, r25
     986:	80 83       	st	Z, r24
     988:	c5 cf       	rjmp	.-118    	; 0x914 <__stack+0x15>
    else
    {
      // two choices for the 16 bit timers: ck/1 or ck/64
      ocr = F_CPU / frequency / 2 - 1;

      prescalarbits = 0b001;
     98a:	91 e0       	ldi	r25, 0x01	; 1
      {
        ocr = F_CPU / frequency / 2 / 64 - 1;
        prescalarbits = 0b011;
      }

      if (_timer == 1)
     98c:	8d 81       	ldd	r24, Y+5	; 0x05
     98e:	81 30       	cpi	r24, 0x01	; 1
     990:	09 f6       	brne	.-126    	; 0x914 <__stack+0x15>
      {
#if defined(TCCR1B)
        TCCR1B = (TCCR1B & 0b11111000) | prescalarbits;
     992:	e1 e8       	ldi	r30, 0x81	; 129
     994:	f0 e0       	ldi	r31, 0x00	; 0
     996:	80 81       	ld	r24, Z
     998:	88 7f       	andi	r24, 0xF8	; 248
     99a:	89 2b       	or	r24, r25
     99c:	80 83       	st	Z, r24
     99e:	ba cf       	rjmp	.-140    	; 0x914 <__stack+0x15>
    {
      toggle_count = 2 * frequency * duration / 1000;
    }
    else
    {
      toggle_count = -1;
     9a0:	2f ef       	ldi	r18, 0xFF	; 255
     9a2:	3f ef       	ldi	r19, 0xFF	; 255
     9a4:	a9 01       	movw	r20, r18
     9a6:	c9 cf       	rjmp	.-110    	; 0x93a <__stack+0x3b>
    switch (_timer)
    {

#if defined(OCR0A) && defined(TIMSK0) && defined(OCIE0A)
      case 0:
        OCR0A = ocr;
     9a8:	c7 bc       	out	0x27, r12	; 39
        timer0_toggle_count = toggle_count;
     9aa:	20 93 83 07 	sts	0x0783, r18	; 0x800783 <timer0_toggle_count>
     9ae:	30 93 84 07 	sts	0x0784, r19	; 0x800784 <timer0_toggle_count+0x1>
     9b2:	40 93 85 07 	sts	0x0785, r20	; 0x800785 <timer0_toggle_count+0x2>
     9b6:	50 93 86 07 	sts	0x0786, r21	; 0x800786 <timer0_toggle_count+0x3>
        bitWrite(TIMSK0, OCIE0A, 1);
     9ba:	ee e6       	ldi	r30, 0x6E	; 110
     9bc:	f0 e0       	ldi	r31, 0x00	; 0
     9be:	80 81       	ld	r24, Z
     9c0:	82 60       	ori	r24, 0x02	; 2
     9c2:	80 83       	st	Z, r24
     9c4:	c3 cf       	rjmp	.-122    	; 0x94c <__stack+0x4d>
        break;
#endif

      case 1:
#if defined(OCR1A) && defined(TIMSK1) && defined(OCIE1A)
        OCR1A = ocr;
     9c6:	d0 92 89 00 	sts	0x0089, r13	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
     9ca:	c0 92 88 00 	sts	0x0088, r12	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
        timer1_toggle_count = toggle_count;
     9ce:	20 93 7f 07 	sts	0x077F, r18	; 0x80077f <timer1_toggle_count>
     9d2:	30 93 80 07 	sts	0x0780, r19	; 0x800780 <timer1_toggle_count+0x1>
     9d6:	40 93 81 07 	sts	0x0781, r20	; 0x800781 <timer1_toggle_count+0x2>
     9da:	50 93 82 07 	sts	0x0782, r21	; 0x800782 <timer1_toggle_count+0x3>
        bitWrite(TIMSK1, OCIE1A, 1);
     9de:	ef e6       	ldi	r30, 0x6F	; 111
     9e0:	f0 e0       	ldi	r31, 0x00	; 0
     9e2:	80 81       	ld	r24, Z
     9e4:	82 60       	ori	r24, 0x02	; 2
     9e6:	80 83       	st	Z, r24
     9e8:	b1 cf       	rjmp	.-158    	; 0x94c <__stack+0x4d>
#endif
        break;

#if defined(OCR2A) && defined(TIMSK2) && defined(OCIE2A)
      case 2:
        OCR2A = ocr;
     9ea:	c0 92 b3 00 	sts	0x00B3, r12	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7e00b3>
        timer2_toggle_count = toggle_count;
     9ee:	20 93 8a 07 	sts	0x078A, r18	; 0x80078a <timer2_toggle_count>
     9f2:	30 93 8b 07 	sts	0x078B, r19	; 0x80078b <timer2_toggle_count+0x1>
     9f6:	40 93 8c 07 	sts	0x078C, r20	; 0x80078c <timer2_toggle_count+0x2>
     9fa:	50 93 8d 07 	sts	0x078D, r21	; 0x80078d <timer2_toggle_count+0x3>
        bitWrite(TIMSK2, OCIE2A, 1);
     9fe:	e0 e7       	ldi	r30, 0x70	; 112
     a00:	f0 e0       	ldi	r31, 0x00	; 0
     a02:	80 81       	ld	r24, Z
     a04:	82 60       	ori	r24, 0x02	; 2
     a06:	80 83       	st	Z, r24
     a08:	a1 cf       	rjmp	.-190    	; 0x94c <__stack+0x4d>

00000a0a <_ZN5Print5printERK9Printable>:
  n += println();
  return n;
}

size_t Print::print(const Printable& x)
{
     a0a:	db 01       	movw	r26, r22
  return x.printTo(*this);
     a0c:	ed 91       	ld	r30, X+
     a0e:	fc 91       	ld	r31, X
     a10:	11 97       	sbiw	r26, 0x01	; 1
     a12:	01 90       	ld	r0, Z+
     a14:	f0 81       	ld	r31, Z
     a16:	e0 2d       	mov	r30, r0
     a18:	bc 01       	movw	r22, r24
     a1a:	cd 01       	movw	r24, r26
     a1c:	09 95       	icall
}
     a1e:	08 95       	ret

00000a20 <_ZN5Print5writeEPKhj>:

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
     a20:	cf 92       	push	r12
     a22:	df 92       	push	r13
     a24:	ef 92       	push	r14
     a26:	ff 92       	push	r15
     a28:	0f 93       	push	r16
     a2a:	1f 93       	push	r17
     a2c:	cf 93       	push	r28
     a2e:	df 93       	push	r29
     a30:	8c 01       	movw	r16, r24
     a32:	db 01       	movw	r26, r22
  size_t n = 0;
     a34:	d0 e0       	ldi	r29, 0x00	; 0
     a36:	c0 e0       	ldi	r28, 0x00	; 0
  while (size--) {
     a38:	7a 01       	movw	r14, r20
     a3a:	81 e0       	ldi	r24, 0x01	; 1
     a3c:	e8 1a       	sub	r14, r24
     a3e:	f1 08       	sbc	r15, r1
     a40:	45 2b       	or	r20, r21
     a42:	a1 f0       	breq	.+40     	; 0xa6c <_ZN5Print5writeEPKhj+0x4c>
    if (write(*buffer++)) n++;
     a44:	f8 01       	movw	r30, r16
     a46:	80 81       	ld	r24, Z
     a48:	91 81       	ldd	r25, Z+1	; 0x01
     a4a:	fc 01       	movw	r30, r24
     a4c:	20 81       	ld	r18, Z
     a4e:	31 81       	ldd	r19, Z+1	; 0x01
     a50:	6d 01       	movw	r12, r26
     a52:	ff ef       	ldi	r31, 0xFF	; 255
     a54:	cf 1a       	sub	r12, r31
     a56:	df 0a       	sbc	r13, r31
     a58:	6c 91       	ld	r22, X
     a5a:	c8 01       	movw	r24, r16
     a5c:	f9 01       	movw	r30, r18
     a5e:	09 95       	icall
     a60:	89 2b       	or	r24, r25
     a62:	21 f0       	breq	.+8      	; 0xa6c <_ZN5Print5writeEPKhj+0x4c>
     a64:	21 96       	adiw	r28, 0x01	; 1

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
  size_t n = 0;
  while (size--) {
     a66:	a7 01       	movw	r20, r14
    if (write(*buffer++)) n++;
     a68:	d6 01       	movw	r26, r12
     a6a:	e6 cf       	rjmp	.-52     	; 0xa38 <_ZN5Print5writeEPKhj+0x18>
    else break;
  }
  return n;
}
     a6c:	ce 01       	movw	r24, r28
     a6e:	df 91       	pop	r29
     a70:	cf 91       	pop	r28
     a72:	1f 91       	pop	r17
     a74:	0f 91       	pop	r16
     a76:	ff 90       	pop	r15
     a78:	ef 90       	pop	r14
     a7a:	df 90       	pop	r13
     a7c:	cf 90       	pop	r12
     a7e:	08 95       	ret

00000a80 <_Z41__static_initialization_and_destruction_0ii.lto_priv.1>:

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
}
     a80:	01 97       	sbiw	r24, 0x01	; 1
     a82:	09 f0       	breq	.+2      	; 0xa86 <_Z41__static_initialization_and_destruction_0ii.lto_priv.1+0x6>
     a84:	08 95       	ret
     a86:	6f 3f       	cpi	r22, 0xFF	; 255
     a88:	7f 4f       	sbci	r23, 0xFF	; 255
     a8a:	e1 f7       	brne	.-8      	; 0xa84 <_Z41__static_initialization_and_destruction_0ii.lto_priv.1+0x4>
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
     a8c:	e0 ee       	ldi	r30, 0xE0	; 224
     a8e:	f6 e0       	ldi	r31, 0x06	; 6
     a90:	13 82       	std	Z+3, r1	; 0x03
     a92:	12 82       	std	Z+2, r1	; 0x02
  public:
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;

    Stream() {_timeout=1000;}
     a94:	88 ee       	ldi	r24, 0xE8	; 232
     a96:	93 e0       	ldi	r25, 0x03	; 3
     a98:	a0 e0       	ldi	r26, 0x00	; 0
     a9a:	b0 e0       	ldi	r27, 0x00	; 0
     a9c:	84 83       	std	Z+4, r24	; 0x04
     a9e:	95 83       	std	Z+5, r25	; 0x05
     aa0:	a6 83       	std	Z+6, r26	; 0x06
     aa2:	b7 83       	std	Z+7, r27	; 0x07
  volatile uint8_t *ucsrc, volatile uint8_t *udr) :
    _ubrrh(ubrrh), _ubrrl(ubrrl),
    _ucsra(ucsra), _ucsrb(ucsrb), _ucsrc(ucsrc),
    _udr(udr),
    _rx_buffer_head(0), _rx_buffer_tail(0),
    _tx_buffer_head(0), _tx_buffer_tail(0)
     aa4:	82 e9       	ldi	r24, 0x92	; 146
     aa6:	92 e0       	ldi	r25, 0x02	; 2
     aa8:	91 83       	std	Z+1, r25	; 0x01
     aaa:	80 83       	st	Z, r24
     aac:	85 ec       	ldi	r24, 0xC5	; 197
     aae:	90 e0       	ldi	r25, 0x00	; 0
     ab0:	95 87       	std	Z+13, r25	; 0x0d
     ab2:	84 87       	std	Z+12, r24	; 0x0c
     ab4:	84 ec       	ldi	r24, 0xC4	; 196
     ab6:	90 e0       	ldi	r25, 0x00	; 0
     ab8:	97 87       	std	Z+15, r25	; 0x0f
     aba:	86 87       	std	Z+14, r24	; 0x0e
     abc:	80 ec       	ldi	r24, 0xC0	; 192
     abe:	90 e0       	ldi	r25, 0x00	; 0
     ac0:	91 8b       	std	Z+17, r25	; 0x11
     ac2:	80 8b       	std	Z+16, r24	; 0x10
     ac4:	81 ec       	ldi	r24, 0xC1	; 193
     ac6:	90 e0       	ldi	r25, 0x00	; 0
     ac8:	93 8b       	std	Z+19, r25	; 0x13
     aca:	82 8b       	std	Z+18, r24	; 0x12
     acc:	82 ec       	ldi	r24, 0xC2	; 194
     ace:	90 e0       	ldi	r25, 0x00	; 0
     ad0:	95 8b       	std	Z+21, r25	; 0x15
     ad2:	84 8b       	std	Z+20, r24	; 0x14
     ad4:	86 ec       	ldi	r24, 0xC6	; 198
     ad6:	90 e0       	ldi	r25, 0x00	; 0
     ad8:	97 8b       	std	Z+23, r25	; 0x17
     ada:	86 8b       	std	Z+22, r24	; 0x16
     adc:	11 8e       	std	Z+25, r1	; 0x19
     ade:	12 8e       	std	Z+26, r1	; 0x1a
     ae0:	13 8e       	std	Z+27, r1	; 0x1b
     ae2:	14 8e       	std	Z+28, r1	; 0x1c
     ae4:	cf cf       	rjmp	.-98     	; 0xa84 <_Z41__static_initialization_and_destruction_0ii.lto_priv.1+0x4>

00000ae6 <_ZN14HardwareSerial17availableForWriteEv>:
    return c;
  }
}

int HardwareSerial::availableForWrite(void)
{
     ae6:	fc 01       	movw	r30, r24
  tx_buffer_index_t head;
  tx_buffer_index_t tail;

  TX_BUFFER_ATOMIC {
    head = _tx_buffer_head;
     ae8:	93 8d       	ldd	r25, Z+27	; 0x1b
    tail = _tx_buffer_tail;
     aea:	84 8d       	ldd	r24, Z+28	; 0x1c
  }
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
     aec:	98 17       	cp	r25, r24
     aee:	20 f4       	brcc	.+8      	; 0xaf8 <_ZN14HardwareSerial17availableForWriteEv+0x12>
  return tail - head - 1;
     af0:	89 1b       	sub	r24, r25
     af2:	99 0b       	sbc	r25, r25
     af4:	01 97       	sbiw	r24, 0x01	; 1
}
     af6:	08 95       	ret

  TX_BUFFER_ATOMIC {
    head = _tx_buffer_head;
    tail = _tx_buffer_tail;
  }
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
     af8:	2f e3       	ldi	r18, 0x3F	; 63
     afa:	30 e0       	ldi	r19, 0x00	; 0
     afc:	29 1b       	sub	r18, r25
     afe:	31 09       	sbc	r19, r1
     b00:	82 0f       	add	r24, r18
     b02:	93 2f       	mov	r25, r19
     b04:	91 1d       	adc	r25, r1
     b06:	08 95       	ret

00000b08 <_ZN14HardwareSerial4readEv>:
    return _rx_buffer[_rx_buffer_tail];
  }
}

int HardwareSerial::read(void)
{
     b08:	fc 01       	movw	r30, r24
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
     b0a:	91 8d       	ldd	r25, Z+25	; 0x19
     b0c:	82 8d       	ldd	r24, Z+26	; 0x1a
     b0e:	98 17       	cp	r25, r24
     b10:	61 f0       	breq	.+24     	; 0xb2a <_ZN14HardwareSerial4readEv+0x22>
    return -1;
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
     b12:	a2 8d       	ldd	r26, Z+26	; 0x1a
     b14:	ae 0f       	add	r26, r30
     b16:	bf 2f       	mov	r27, r31
     b18:	b1 1d       	adc	r27, r1
     b1a:	5d 96       	adiw	r26, 0x1d	; 29
     b1c:	8c 91       	ld	r24, X
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
     b1e:	92 8d       	ldd	r25, Z+26	; 0x1a
     b20:	9f 5f       	subi	r25, 0xFF	; 255
     b22:	9f 73       	andi	r25, 0x3F	; 63
     b24:	92 8f       	std	Z+26, r25	; 0x1a
    return c;
     b26:	90 e0       	ldi	r25, 0x00	; 0
     b28:	08 95       	ret

int HardwareSerial::read(void)
{
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
     b2a:	8f ef       	ldi	r24, 0xFF	; 255
     b2c:	9f ef       	ldi	r25, 0xFF	; 255
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
    return c;
  }
}
     b2e:	08 95       	ret

00000b30 <_ZN14HardwareSerial4peekEv>:
{
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
}

int HardwareSerial::peek(void)
{
     b30:	fc 01       	movw	r30, r24
  if (_rx_buffer_head == _rx_buffer_tail) {
     b32:	91 8d       	ldd	r25, Z+25	; 0x19
     b34:	82 8d       	ldd	r24, Z+26	; 0x1a
     b36:	98 17       	cp	r25, r24
     b38:	31 f0       	breq	.+12     	; 0xb46 <_ZN14HardwareSerial4peekEv+0x16>
    return -1;
  } else {
    return _rx_buffer[_rx_buffer_tail];
     b3a:	82 8d       	ldd	r24, Z+26	; 0x1a
     b3c:	e8 0f       	add	r30, r24
     b3e:	f1 1d       	adc	r31, r1
     b40:	85 8d       	ldd	r24, Z+29	; 0x1d
     b42:	90 e0       	ldi	r25, 0x00	; 0
     b44:	08 95       	ret
}

int HardwareSerial::peek(void)
{
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
     b46:	8f ef       	ldi	r24, 0xFF	; 255
     b48:	9f ef       	ldi	r25, 0xFF	; 255
  } else {
    return _rx_buffer[_rx_buffer_tail];
  }
}
     b4a:	08 95       	ret

00000b4c <_ZN14HardwareSerial9availableEv>:
  _rx_buffer_head = _rx_buffer_tail;
}

int HardwareSerial::available(void)
{
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
     b4c:	fc 01       	movw	r30, r24
     b4e:	21 8d       	ldd	r18, Z+25	; 0x19
     b50:	30 e0       	ldi	r19, 0x00	; 0
     b52:	20 5c       	subi	r18, 0xC0	; 192
     b54:	3f 4f       	sbci	r19, 0xFF	; 255
     b56:	82 8d       	ldd	r24, Z+26	; 0x1a
     b58:	a9 01       	movw	r20, r18
     b5a:	48 1b       	sub	r20, r24
     b5c:	51 09       	sbc	r21, r1
     b5e:	ca 01       	movw	r24, r20
}
     b60:	8f 73       	andi	r24, 0x3F	; 63
     b62:	99 27       	eor	r25, r25
     b64:	08 95       	ret

00000b66 <_Z17Serial0_availablev>:
#endif

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
     b66:	80 ee       	ldi	r24, 0xE0	; 224
     b68:	96 e0       	ldi	r25, 0x06	; 6
     b6a:	0e 94 a6 05 	call	0xb4c	; 0xb4c <_ZN14HardwareSerial9availableEv>
     b6e:	21 e0       	ldi	r18, 0x01	; 1
     b70:	89 2b       	or	r24, r25
     b72:	09 f4       	brne	.+2      	; 0xb76 <_Z17Serial0_availablev+0x10>
     b74:	20 e0       	ldi	r18, 0x00	; 0
}
     b76:	82 2f       	mov	r24, r18
     b78:	08 95       	ret

00000b7a <_ZN14HardwareSerial5beginEmh>:
}

// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
     b7a:	cf 92       	push	r12
     b7c:	df 92       	push	r13
     b7e:	ef 92       	push	r14
     b80:	ff 92       	push	r15
     b82:	1f 93       	push	r17
     b84:	cf 93       	push	r28
     b86:	df 93       	push	r29
     b88:	ec 01       	movw	r28, r24
     b8a:	6a 01       	movw	r12, r20
     b8c:	7b 01       	movw	r14, r22
     b8e:	12 2f       	mov	r17, r18
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
     b90:	60 e0       	ldi	r22, 0x00	; 0
     b92:	79 e0       	ldi	r23, 0x09	; 9
     b94:	8d e3       	ldi	r24, 0x3D	; 61
     b96:	90 e0       	ldi	r25, 0x00	; 0
     b98:	a7 01       	movw	r20, r14
     b9a:	96 01       	movw	r18, r12
     b9c:	0e 94 10 3b 	call	0x7620	; 0x7620 <__udivmodsi4>
     ba0:	21 50       	subi	r18, 0x01	; 1
     ba2:	31 09       	sbc	r19, r1
     ba4:	41 09       	sbc	r20, r1
     ba6:	51 09       	sbc	r21, r1
     ba8:	56 95       	lsr	r21
     baa:	47 95       	ror	r20
     bac:	37 95       	ror	r19
     bae:	27 95       	ror	r18
  *_ucsra = 1 << U2X0;
     bb0:	e8 89       	ldd	r30, Y+16	; 0x10
     bb2:	f9 89       	ldd	r31, Y+17	; 0x11
     bb4:	82 e0       	ldi	r24, 0x02	; 2
     bb6:	80 83       	st	Z, r24
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
     bb8:	c1 14       	cp	r12, r1
     bba:	81 ee       	ldi	r24, 0xE1	; 225
     bbc:	d8 06       	cpc	r13, r24
     bbe:	e1 04       	cpc	r14, r1
     bc0:	f1 04       	cpc	r15, r1
     bc2:	21 f0       	breq	.+8      	; 0xbcc <_ZN14HardwareSerial5beginEmh+0x52>
     bc4:	21 15       	cp	r18, r1
     bc6:	80 e1       	ldi	r24, 0x10	; 16
     bc8:	38 07       	cpc	r19, r24
     bca:	98 f0       	brcs	.+38     	; 0xbf2 <_ZN14HardwareSerial5beginEmh+0x78>
  {
    *_ucsra = 0;
     bcc:	e8 89       	ldd	r30, Y+16	; 0x10
     bce:	f9 89       	ldd	r31, Y+17	; 0x11
     bd0:	10 82       	st	Z, r1
    baud_setting = (F_CPU / 8 / baud - 1) / 2;
     bd2:	60 e8       	ldi	r22, 0x80	; 128
     bd4:	74 e8       	ldi	r23, 0x84	; 132
     bd6:	8e e1       	ldi	r24, 0x1E	; 30
     bd8:	90 e0       	ldi	r25, 0x00	; 0
     bda:	a7 01       	movw	r20, r14
     bdc:	96 01       	movw	r18, r12
     bde:	0e 94 10 3b 	call	0x7620	; 0x7620 <__udivmodsi4>
     be2:	21 50       	subi	r18, 0x01	; 1
     be4:	31 09       	sbc	r19, r1
     be6:	41 09       	sbc	r20, r1
     be8:	51 09       	sbc	r21, r1
     bea:	56 95       	lsr	r21
     bec:	47 95       	ror	r20
     bee:	37 95       	ror	r19
     bf0:	27 95       	ror	r18
  }

  // assign the baud_setting, a.k.a. ubrr (USART Baud Rate Register)
  *_ubrrh = baud_setting >> 8;
     bf2:	ec 85       	ldd	r30, Y+12	; 0x0c
     bf4:	fd 85       	ldd	r31, Y+13	; 0x0d
     bf6:	30 83       	st	Z, r19
  *_ubrrl = baud_setting;
     bf8:	ee 85       	ldd	r30, Y+14	; 0x0e
     bfa:	ff 85       	ldd	r31, Y+15	; 0x0f
     bfc:	20 83       	st	Z, r18

  _written = false;
     bfe:	18 8e       	std	Y+24, r1	; 0x18

  //set the data bits, parity, and stop bits
#if defined(__AVR_ATmega8__)
  config |= 0x80; // select UCSRC register (shared with UBRRH)
#endif
  *_ucsrc = config;
     c00:	ec 89       	ldd	r30, Y+20	; 0x14
     c02:	fd 89       	ldd	r31, Y+21	; 0x15
     c04:	10 83       	st	Z, r17
  
  sbi(*_ucsrb, RXEN0);
     c06:	ea 89       	ldd	r30, Y+18	; 0x12
     c08:	fb 89       	ldd	r31, Y+19	; 0x13
     c0a:	80 81       	ld	r24, Z
     c0c:	80 61       	ori	r24, 0x10	; 16
     c0e:	80 83       	st	Z, r24
  sbi(*_ucsrb, TXEN0);
     c10:	ea 89       	ldd	r30, Y+18	; 0x12
     c12:	fb 89       	ldd	r31, Y+19	; 0x13
     c14:	80 81       	ld	r24, Z
     c16:	88 60       	ori	r24, 0x08	; 8
     c18:	80 83       	st	Z, r24
  sbi(*_ucsrb, RXCIE0);
     c1a:	ea 89       	ldd	r30, Y+18	; 0x12
     c1c:	fb 89       	ldd	r31, Y+19	; 0x13
     c1e:	80 81       	ld	r24, Z
     c20:	80 68       	ori	r24, 0x80	; 128
     c22:	80 83       	st	Z, r24
  cbi(*_ucsrb, UDRIE0);
     c24:	ea 89       	ldd	r30, Y+18	; 0x12
     c26:	fb 89       	ldd	r31, Y+19	; 0x13
     c28:	80 81       	ld	r24, Z
     c2a:	8f 7d       	andi	r24, 0xDF	; 223
     c2c:	80 83       	st	Z, r24
}
     c2e:	df 91       	pop	r29
     c30:	cf 91       	pop	r28
     c32:	1f 91       	pop	r17
     c34:	ff 90       	pop	r15
     c36:	ef 90       	pop	r14
     c38:	df 90       	pop	r13
     c3a:	cf 90       	pop	r12
     c3c:	08 95       	ret

00000c3e <_ZN14HardwareSerial17_tx_udr_empty_irqEv>:
#endif

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_tx_udr_empty_irq(void)
{
     c3e:	fc 01       	movw	r30, r24
  // If interrupts are enabled, there must be more data in the output
  // buffer. Send the next byte
  unsigned char c = _tx_buffer[_tx_buffer_tail];
     c40:	a4 8d       	ldd	r26, Z+28	; 0x1c
     c42:	a8 0f       	add	r26, r24
     c44:	b9 2f       	mov	r27, r25
     c46:	b1 1d       	adc	r27, r1
     c48:	a3 5a       	subi	r26, 0xA3	; 163
     c4a:	bf 4f       	sbci	r27, 0xFF	; 255
     c4c:	2c 91       	ld	r18, X
  _tx_buffer_tail = (_tx_buffer_tail + 1) % SERIAL_TX_BUFFER_SIZE;
     c4e:	84 8d       	ldd	r24, Z+28	; 0x1c
     c50:	90 e0       	ldi	r25, 0x00	; 0
     c52:	01 96       	adiw	r24, 0x01	; 1
     c54:	8f 73       	andi	r24, 0x3F	; 63
     c56:	90 78       	andi	r25, 0x80	; 128
     c58:	84 8f       	std	Z+28, r24	; 0x1c

  *_udr = c;
     c5a:	a6 89       	ldd	r26, Z+22	; 0x16
     c5c:	b7 89       	ldd	r27, Z+23	; 0x17
     c5e:	2c 93       	st	X, r18
  // location". This makes sure flush() won't return until the bytes
  // actually got written. Other r/w bits are preserved, and zeroes
  // written to the rest.

#ifdef MPCM0
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
     c60:	a0 89       	ldd	r26, Z+16	; 0x10
     c62:	b1 89       	ldd	r27, Z+17	; 0x11
     c64:	8c 91       	ld	r24, X
     c66:	83 70       	andi	r24, 0x03	; 3
     c68:	80 64       	ori	r24, 0x40	; 64
     c6a:	8c 93       	st	X, r24
#else
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif

  if (_tx_buffer_head == _tx_buffer_tail) {
     c6c:	93 8d       	ldd	r25, Z+27	; 0x1b
     c6e:	84 8d       	ldd	r24, Z+28	; 0x1c
     c70:	98 13       	cpse	r25, r24
    // Buffer empty, so disable interrupts
    cbi(*_ucsrb, UDRIE0);
  }
}
     c72:	08 95       	ret
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif

  if (_tx_buffer_head == _tx_buffer_tail) {
    // Buffer empty, so disable interrupts
    cbi(*_ucsrb, UDRIE0);
     c74:	02 88       	ldd	r0, Z+18	; 0x12
     c76:	f3 89       	ldd	r31, Z+19	; 0x13
     c78:	e0 2d       	mov	r30, r0
     c7a:	80 81       	ld	r24, Z
     c7c:	8f 7d       	andi	r24, 0xDF	; 223
     c7e:	80 83       	st	Z, r24
     c80:	f8 cf       	rjmp	.-16     	; 0xc72 <_ZN14HardwareSerial17_tx_udr_empty_irqEv+0x34>

00000c82 <_ZN14HardwareSerial5writeEh>:
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}

size_t HardwareSerial::write(uint8_t c)
{
     c82:	0f 93       	push	r16
     c84:	1f 93       	push	r17
     c86:	cf 93       	push	r28
     c88:	df 93       	push	r29
     c8a:	ec 01       	movw	r28, r24
  _written = true;
     c8c:	81 e0       	ldi	r24, 0x01	; 1
     c8e:	88 8f       	std	Y+24, r24	; 0x18
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
     c90:	9b 8d       	ldd	r25, Y+27	; 0x1b
     c92:	8c 8d       	ldd	r24, Y+28	; 0x1c
     c94:	98 17       	cp	r25, r24
     c96:	b1 f0       	breq	.+44     	; 0xcc4 <_ZN14HardwareSerial5writeEh+0x42>
     c98:	06 2f       	mov	r16, r22
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif
    }
    return 1;
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
     c9a:	8b 8d       	ldd	r24, Y+27	; 0x1b
     c9c:	90 e0       	ldi	r25, 0x00	; 0
     c9e:	01 96       	adiw	r24, 0x01	; 1
     ca0:	8f 73       	andi	r24, 0x3F	; 63
     ca2:	90 78       	andi	r25, 0x80	; 128
     ca4:	18 2f       	mov	r17, r24
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
     ca6:	8c 8d       	ldd	r24, Y+28	; 0x1c
     ca8:	81 13       	cpse	r24, r17
     caa:	1e c0       	rjmp	.+60     	; 0xce8 <_ZN14HardwareSerial5writeEh+0x66>
    if (bit_is_clear(SREG, SREG_I)) {
     cac:	0f b6       	in	r0, 0x3f	; 63
     cae:	07 fc       	sbrc	r0, 7
     cb0:	fa cf       	rjmp	.-12     	; 0xca6 <_ZN14HardwareSerial5writeEh+0x24>
      // Interrupts are disabled, so we'll have to poll the data
      // register empty flag ourselves. If it is set, pretend an
      // interrupt has happened and call the handler to free up
      // space for us.
      if(bit_is_set(*_ucsra, UDRE0))
     cb2:	e8 89       	ldd	r30, Y+16	; 0x10
     cb4:	f9 89       	ldd	r31, Y+17	; 0x11
     cb6:	80 81       	ld	r24, Z
     cb8:	85 ff       	sbrs	r24, 5
     cba:	f5 cf       	rjmp	.-22     	; 0xca6 <_ZN14HardwareSerial5writeEh+0x24>
	_tx_udr_empty_irq();
     cbc:	ce 01       	movw	r24, r28
     cbe:	0e 94 1f 06 	call	0xc3e	; 0xc3e <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
     cc2:	f1 cf       	rjmp	.-30     	; 0xca6 <_ZN14HardwareSerial5writeEh+0x24>
  _written = true;
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
     cc4:	e8 89       	ldd	r30, Y+16	; 0x10
     cc6:	f9 89       	ldd	r31, Y+17	; 0x11
     cc8:	80 81       	ld	r24, Z
     cca:	85 ff       	sbrs	r24, 5
     ccc:	e5 cf       	rjmp	.-54     	; 0xc98 <_ZN14HardwareSerial5writeEh+0x16>
    // So writing UDR must happen first.
    // Writing UDR and clearing TC must be done atomically, otherwise
    // interrupts might delay the TXC clear so the byte written to UDR
    // is transmitted (setting TXC) before clearing TXC. Then TXC will
    // be cleared when no bytes are left, causing flush() to hang
    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
     cce:	9f b7       	in	r25, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     cd0:	f8 94       	cli
      *_udr = c;
     cd2:	ee 89       	ldd	r30, Y+22	; 0x16
     cd4:	ff 89       	ldd	r31, Y+23	; 0x17
     cd6:	60 83       	st	Z, r22
#ifdef MPCM0
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
     cd8:	e8 89       	ldd	r30, Y+16	; 0x10
     cda:	f9 89       	ldd	r31, Y+17	; 0x11
     cdc:	80 81       	ld	r24, Z
     cde:	83 70       	andi	r24, 0x03	; 3
     ce0:	80 64       	ori	r24, 0x40	; 64
     ce2:	80 83       	st	Z, r24
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     ce4:	9f bf       	out	0x3f, r25	; 63
    __asm__ volatile ("" ::: "memory");
     ce6:	10 c0       	rjmp	.+32     	; 0xd08 <_ZN14HardwareSerial5writeEh+0x86>
    } else {
      // nop, the interrupt handler will free up space for us
    }
  }

  _tx_buffer[_tx_buffer_head] = c;
     ce8:	eb 8d       	ldd	r30, Y+27	; 0x1b
     cea:	ec 0f       	add	r30, r28
     cec:	fd 2f       	mov	r31, r29
     cee:	f1 1d       	adc	r31, r1
     cf0:	e3 5a       	subi	r30, 0xA3	; 163
     cf2:	ff 4f       	sbci	r31, 0xFF	; 255
     cf4:	00 83       	st	Z, r16

  // make atomic to prevent execution of ISR between setting the
  // head pointer and setting the interrupt flag resulting in buffer
  // retransmission
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
     cf6:	9f b7       	in	r25, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     cf8:	f8 94       	cli
    _tx_buffer_head = i;
     cfa:	1b 8f       	std	Y+27, r17	; 0x1b
    sbi(*_ucsrb, UDRIE0);
     cfc:	ea 89       	ldd	r30, Y+18	; 0x12
     cfe:	fb 89       	ldd	r31, Y+19	; 0x13
     d00:	80 81       	ld	r24, Z
     d02:	80 62       	ori	r24, 0x20	; 32
     d04:	80 83       	st	Z, r24
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     d06:	9f bf       	out	0x3f, r25	; 63
  }
  
  return 1;
}
     d08:	81 e0       	ldi	r24, 0x01	; 1
     d0a:	90 e0       	ldi	r25, 0x00	; 0
     d0c:	df 91       	pop	r29
     d0e:	cf 91       	pop	r28
     d10:	1f 91       	pop	r17
     d12:	0f 91       	pop	r16
     d14:	08 95       	ret

00000d16 <_ZN14HardwareSerial5flushEv>:
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  return tail - head - 1;
}

void HardwareSerial::flush()
{
     d16:	cf 93       	push	r28
     d18:	df 93       	push	r29
     d1a:	ec 01       	movw	r28, r24
  // If we have never written a byte, no need to flush. This special
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
     d1c:	88 8d       	ldd	r24, Y+24	; 0x18
     d1e:	81 11       	cpse	r24, r1
     d20:	04 c0       	rjmp	.+8      	; 0xd2a <_ZN14HardwareSerial5flushEv+0x14>
     d22:	0d c0       	rjmp	.+26     	; 0xd3e <_ZN14HardwareSerial5flushEv+0x28>
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
     d24:	0f b6       	in	r0, 0x3f	; 63
     d26:	07 fe       	sbrs	r0, 7
     d28:	0d c0       	rjmp	.+26     	; 0xd44 <_ZN14HardwareSerial5flushEv+0x2e>
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
     d2a:	ea 89       	ldd	r30, Y+18	; 0x12
     d2c:	fb 89       	ldd	r31, Y+19	; 0x13
     d2e:	80 81       	ld	r24, Z
     d30:	85 fd       	sbrc	r24, 5
     d32:	f8 cf       	rjmp	.-16     	; 0xd24 <_ZN14HardwareSerial5flushEv+0xe>
     d34:	a8 89       	ldd	r26, Y+16	; 0x10
     d36:	b9 89       	ldd	r27, Y+17	; 0x11
     d38:	8c 91       	ld	r24, X
     d3a:	86 ff       	sbrs	r24, 6
     d3c:	f3 cf       	rjmp	.-26     	; 0xd24 <_ZN14HardwareSerial5flushEv+0xe>
	if (bit_is_set(*_ucsra, UDRE0))
	  _tx_udr_empty_irq();
  }
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}
     d3e:	df 91       	pop	r29
     d40:	cf 91       	pop	r28
     d42:	08 95       	ret
  // complete) bit to 1 during initialization
  if (!_written)
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
     d44:	80 81       	ld	r24, Z
     d46:	85 ff       	sbrs	r24, 5
     d48:	f0 cf       	rjmp	.-32     	; 0xd2a <_ZN14HardwareSerial5flushEv+0x14>
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
     d4a:	e8 89       	ldd	r30, Y+16	; 0x10
     d4c:	f9 89       	ldd	r31, Y+17	; 0x11
     d4e:	80 81       	ld	r24, Z
     d50:	85 ff       	sbrs	r24, 5
     d52:	eb cf       	rjmp	.-42     	; 0xd2a <_ZN14HardwareSerial5flushEv+0x14>
	  _tx_udr_empty_irq();
     d54:	ce 01       	movw	r24, r28
     d56:	0e 94 1f 06 	call	0xc3e	; 0xc3e <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
     d5a:	e7 cf       	rjmp	.-50     	; 0xd2a <_ZN14HardwareSerial5flushEv+0x14>

00000d5c <_Z14serialEventRunv>:
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
     d5c:	80 e0       	ldi	r24, 0x00	; 0
     d5e:	90 e0       	ldi	r25, 0x00	; 0
     d60:	89 2b       	or	r24, r25
     d62:	21 f0       	breq	.+8      	; 0xd6c <_Z14serialEventRunv+0x10>
     d64:	0e 94 b3 05 	call	0xb66	; 0xb66 <_Z17Serial0_availablev>
     d68:	81 11       	cpse	r24, r1
     d6a:	01 c0       	rjmp	.+2      	; 0xd6e <_Z14serialEventRunv+0x12>
  if (Serial2_available && serialEvent2 && Serial2_available()) serialEvent2();
#endif
#if defined(HAVE_HWSERIAL3)
  if (Serial3_available && serialEvent3 && Serial3_available()) serialEvent3();
#endif
}
     d6c:	08 95       	ret
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
     d6e:	0e 94 00 00 	call	0	; 0x0 <__vectors>
     d72:	fc cf       	rjmp	.-8      	; 0xd6c <_Z14serialEventRunv+0x10>

00000d74 <_ZN3etl15private_variant14operation_typeIN3gel5ErrorELb1ELb1EE12do_operationEiPcPKc>:
    //*******************************************
    // Specialisation for copyable & moveable types.
    template <typename T>
    struct operation_type<T, Copyable, Moveable>
    {
      static void do_operation(int operation, char* pstorage, const char* pvalue)
     d74:	cf 93       	push	r28
     d76:	df 93       	push	r29
     d78:	ea 01       	movw	r28, r20
      {
        switch (operation)
     d7a:	00 97       	sbiw	r24, 0x00	; 0
     d7c:	29 f0       	breq	.+10     	; 0xd88 <_ZN3etl15private_variant14operation_typeIN3gel5ErrorELb1ELb1EE12do_operationEiPcPKc+0x14>
     d7e:	01 97       	sbiw	r24, 0x01	; 1
     d80:	b9 f0       	breq	.+46     	; 0xdb0 <_ZN3etl15private_variant14operation_typeIN3gel5ErrorELb1ELb1EE12do_operationEiPcPKc+0x3c>
            assert(false);
#endif
            break;
          }
        }
      }
     d82:	df 91       	pop	r29
     d84:	cf 91       	pop	r28
     d86:	08 95       	ret
      {
        switch (operation)
        {
          case Copy:
          {
            ::new (pstorage) T(*reinterpret_cast<const T*>(pvalue));
     d88:	86 e0       	ldi	r24, 0x06	; 6
     d8a:	90 e0       	ldi	r25, 0x00	; 0
     d8c:	0e 94 1e 02 	call	0x43c	; 0x43c <_ZnwjPv>
     d90:	fc 01       	movw	r30, r24
     d92:	89 2b       	or	r24, r25
     d94:	b1 f3       	breq	.-20     	; 0xd82 <_ZN3etl15private_variant14operation_typeIN3gel5ErrorELb1ELb1EE12do_operationEiPcPKc+0xe>
#include <gel/Core.h>

namespace gel
{

struct Error : Printable
     d96:	8c e8       	ldi	r24, 0x8C	; 140
     d98:	92 e0       	ldi	r25, 0x02	; 2
     d9a:	91 83       	std	Z+1, r25	; 0x01
     d9c:	80 83       	st	Z, r24
     d9e:	8a 81       	ldd	r24, Y+2	; 0x02
     da0:	9b 81       	ldd	r25, Y+3	; 0x03
     da2:	93 83       	std	Z+3, r25	; 0x03
     da4:	82 83       	std	Z+2, r24	; 0x02
     da6:	8c 81       	ldd	r24, Y+4	; 0x04
     da8:	9d 81       	ldd	r25, Y+5	; 0x05
     daa:	95 83       	std	Z+5, r25	; 0x05
     dac:	84 83       	std	Z+4, r24	; 0x04
     dae:	e9 cf       	rjmp	.-46     	; 0xd82 <_ZN3etl15private_variant14operation_typeIN3gel5ErrorELb1ELb1EE12do_operationEiPcPKc+0xe>
            break;
          }

          case Move:
          {
            ::new (pstorage) T(etl::move(*reinterpret_cast<T*>(const_cast<char*>(pvalue))));
     db0:	86 e0       	ldi	r24, 0x06	; 6
     db2:	90 e0       	ldi	r25, 0x00	; 0
     db4:	0e 94 1e 02 	call	0x43c	; 0x43c <_ZnwjPv>
     db8:	fc 01       	movw	r30, r24
     dba:	89 2b       	or	r24, r25
     dbc:	11 f3       	breq	.-60     	; 0xd82 <_ZN3etl15private_variant14operation_typeIN3gel5ErrorELb1ELb1EE12do_operationEiPcPKc+0xe>
     dbe:	8c e8       	ldi	r24, 0x8C	; 140
     dc0:	92 e0       	ldi	r25, 0x02	; 2
     dc2:	91 83       	std	Z+1, r25	; 0x01
     dc4:	80 83       	st	Z, r24
     dc6:	8a 81       	ldd	r24, Y+2	; 0x02
     dc8:	9b 81       	ldd	r25, Y+3	; 0x03
     dca:	93 83       	std	Z+3, r25	; 0x03
     dcc:	82 83       	std	Z+2, r24	; 0x02
     dce:	8c 81       	ldd	r24, Y+4	; 0x04
     dd0:	9d 81       	ldd	r25, Y+5	; 0x05
     dd2:	95 83       	std	Z+5, r25	; 0x05
     dd4:	84 83       	std	Z+4, r24	; 0x04
     dd6:	d5 cf       	rjmp	.-86     	; 0xd82 <_ZN3etl15private_variant14operation_typeIN3gel5ErrorELb1ELb1EE12do_operationEiPcPKc+0xe>

00000dd8 <_ZN3gel5Radio3getEh>:
    return Error::None;
}

Radio* Radio::get(uint8_t idx)
{
    return Radio::instances[idx];
     dd8:	e8 2f       	mov	r30, r24
     dda:	f0 e0       	ldi	r31, 0x00	; 0
     ddc:	ee 0f       	add	r30, r30
     dde:	ff 1f       	adc	r31, r31
     de0:	e4 52       	subi	r30, 0x24	; 36
     de2:	f9 4f       	sbci	r31, 0xF9	; 249
}
     de4:	80 81       	ld	r24, Z
     de6:	91 81       	ldd	r25, Z+1	; 0x01
     de8:	08 95       	ret

00000dea <_ZN3gel5Radio8setStateENS0_5StateE>:
    return Error::None;        
}

void Radio::setState(State newState)
{
    prevState = currentState;
     dea:	fc 01       	movw	r30, r24
     dec:	e4 59       	subi	r30, 0x94	; 148
     dee:	fe 4f       	sbci	r31, 0xFE	; 254
     df0:	20 81       	ld	r18, Z
     df2:	31 81       	ldd	r19, Z+1	; 0x01
     df4:	82 59       	subi	r24, 0x92	; 146
     df6:	9e 4f       	sbci	r25, 0xFE	; 254
     df8:	dc 01       	movw	r26, r24
     dfa:	2d 93       	st	X+, r18
     dfc:	3c 93       	st	X, r19
    currentState = newState;
     dfe:	71 83       	std	Z+1, r23	; 0x01
     e00:	60 83       	st	Z, r22
}
     e02:	08 95       	ret

00000e04 <_ZN6SX127xaSEOS_>:
/*!
  \class SX127x
  \brief Base class for SX127x series. All derived classes for SX127x (e.g. SX1278 or SX1272) inherit from this base class.
  This class should not be instantiated directly from Arduino sketch, only from its derived classes.
*/
class SX127x: public PhysicalLayer {
     e04:	cf 93       	push	r28
     e06:	df 93       	push	r29
     e08:	ac 01       	movw	r20, r24
     e0a:	eb 01       	movw	r28, r22
  \brief Provides common interface for protocols that run on %LoRa/FSK modules, such as RTTY or LoRaWAN.
  Also extracts some common module-independent methods. Using this interface class allows to use the protocols
  on various modules without much code duplicity. Because this class is used mainly as interface,
  all of its virtual members must be implemented in the module class.
*/
class PhysicalLayer {
     e0c:	8a 81       	ldd	r24, Y+2	; 0x02
     e0e:	9b 81       	ldd	r25, Y+3	; 0x03
     e10:	ac 81       	ldd	r26, Y+4	; 0x04
     e12:	bd 81       	ldd	r27, Y+5	; 0x05
     e14:	fa 01       	movw	r30, r20
     e16:	82 83       	std	Z+2, r24	; 0x02
     e18:	93 83       	std	Z+3, r25	; 0x03
     e1a:	a4 83       	std	Z+4, r26	; 0x04
     e1c:	b5 83       	std	Z+5, r27	; 0x05
     e1e:	8e 81       	ldd	r24, Y+6	; 0x06
     e20:	9f 81       	ldd	r25, Y+7	; 0x07
     e22:	97 83       	std	Z+7, r25	; 0x07
     e24:	86 83       	std	Z+6, r24	; 0x06
     e26:	88 85       	ldd	r24, Y+8	; 0x08
     e28:	80 87       	std	Z+8, r24	; 0x08
     e2a:	89 85       	ldd	r24, Y+9	; 0x09
     e2c:	81 87       	std	Z+9, r24	; 0x09
     e2e:	8a 85       	ldd	r24, Y+10	; 0x0a
     e30:	82 87       	std	Z+10, r24	; 0x0a
     e32:	da 01       	movw	r26, r20
     e34:	1b 96       	adiw	r26, 0x0b	; 11
     e36:	fb 01       	movw	r30, r22
     e38:	3b 96       	adiw	r30, 0x0b	; 11
     e3a:	2f ef       	ldi	r18, 0xFF	; 255
     e3c:	30 e0       	ldi	r19, 0x00	; 0
     e3e:	33 23       	and	r19, r19
     e40:	2c f0       	brlt	.+10     	; 0xe4c <_ZN6SX127xaSEOS_+0x48>
     e42:	91 91       	ld	r25, Z+
     e44:	9d 93       	st	X+, r25
     e46:	21 50       	subi	r18, 0x01	; 1
     e48:	31 09       	sbc	r19, r1
     e4a:	f9 cf       	rjmp	.-14     	; 0xe3e <_ZN6SX127xaSEOS_+0x3a>
     e4c:	fe 01       	movw	r30, r28
     e4e:	e5 5f       	subi	r30, 0xF5	; 245
     e50:	fe 4f       	sbci	r31, 0xFE	; 254
     e52:	80 81       	ld	r24, Z
     e54:	91 81       	ldd	r25, Z+1	; 0x01
     e56:	a2 81       	ldd	r26, Z+2	; 0x02
     e58:	b3 81       	ldd	r27, Z+3	; 0x03
     e5a:	fa 01       	movw	r30, r20
     e5c:	e5 5f       	subi	r30, 0xF5	; 245
     e5e:	fe 4f       	sbci	r31, 0xFE	; 254
     e60:	80 83       	st	Z, r24
     e62:	91 83       	std	Z+1, r25	; 0x01
     e64:	a2 83       	std	Z+2, r26	; 0x02
     e66:	b3 83       	std	Z+3, r27	; 0x03
     e68:	fe 01       	movw	r30, r28
     e6a:	e1 5f       	subi	r30, 0xF1	; 241
     e6c:	fe 4f       	sbci	r31, 0xFE	; 254
     e6e:	80 81       	ld	r24, Z
     e70:	91 81       	ldd	r25, Z+1	; 0x01
     e72:	a2 81       	ldd	r26, Z+2	; 0x02
     e74:	b3 81       	ldd	r27, Z+3	; 0x03
     e76:	fa 01       	movw	r30, r20
     e78:	e1 5f       	subi	r30, 0xF1	; 241
     e7a:	fe 4f       	sbci	r31, 0xFE	; 254
     e7c:	80 83       	st	Z, r24
     e7e:	91 83       	std	Z+1, r25	; 0x01
     e80:	a2 83       	std	Z+2, r26	; 0x02
     e82:	b3 83       	std	Z+3, r27	; 0x03
     e84:	fe 01       	movw	r30, r28
     e86:	ed 5e       	subi	r30, 0xED	; 237
     e88:	fe 4f       	sbci	r31, 0xFE	; 254
     e8a:	80 81       	ld	r24, Z
     e8c:	fa 01       	movw	r30, r20
     e8e:	ed 5e       	subi	r30, 0xED	; 237
     e90:	fe 4f       	sbci	r31, 0xFE	; 254
     e92:	80 83       	st	Z, r24
     e94:	fe 01       	movw	r30, r28
     e96:	ec 5e       	subi	r30, 0xEC	; 236
     e98:	fe 4f       	sbci	r31, 0xFE	; 254
     e9a:	80 81       	ld	r24, Z
     e9c:	91 81       	ldd	r25, Z+1	; 0x01
     e9e:	a2 81       	ldd	r26, Z+2	; 0x02
     ea0:	b3 81       	ldd	r27, Z+3	; 0x03
     ea2:	fa 01       	movw	r30, r20
     ea4:	ec 5e       	subi	r30, 0xEC	; 236
     ea6:	fe 4f       	sbci	r31, 0xFE	; 254
     ea8:	80 83       	st	Z, r24
     eaa:	91 83       	std	Z+1, r25	; 0x01
     eac:	a2 83       	std	Z+2, r26	; 0x02
     eae:	b3 83       	std	Z+3, r27	; 0x03
     eb0:	fe 01       	movw	r30, r28
     eb2:	e8 5e       	subi	r30, 0xE8	; 232
     eb4:	fe 4f       	sbci	r31, 0xFE	; 254
     eb6:	80 81       	ld	r24, Z
     eb8:	fa 01       	movw	r30, r20
     eba:	e8 5e       	subi	r30, 0xE8	; 232
     ebc:	fe 4f       	sbci	r31, 0xFE	; 254
     ebe:	80 83       	st	Z, r24
     ec0:	fe 01       	movw	r30, r28
     ec2:	e7 5e       	subi	r30, 0xE7	; 231
     ec4:	fe 4f       	sbci	r31, 0xFE	; 254
     ec6:	80 81       	ld	r24, Z
     ec8:	91 81       	ldd	r25, Z+1	; 0x01
     eca:	fa 01       	movw	r30, r20
     ecc:	e7 5e       	subi	r30, 0xE7	; 231
     ece:	fe 4f       	sbci	r31, 0xFE	; 254
     ed0:	91 83       	std	Z+1, r25	; 0x01
     ed2:	80 83       	st	Z, r24
     ed4:	fe 01       	movw	r30, r28
     ed6:	e5 5e       	subi	r30, 0xE5	; 229
     ed8:	fe 4f       	sbci	r31, 0xFE	; 254
     eda:	80 81       	ld	r24, Z
     edc:	91 81       	ldd	r25, Z+1	; 0x01
     ede:	a2 81       	ldd	r26, Z+2	; 0x02
     ee0:	b3 81       	ldd	r27, Z+3	; 0x03
     ee2:	fa 01       	movw	r30, r20
     ee4:	e5 5e       	subi	r30, 0xE5	; 229
     ee6:	fe 4f       	sbci	r31, 0xFE	; 254
     ee8:	80 83       	st	Z, r24
     eea:	91 83       	std	Z+1, r25	; 0x01
     eec:	a2 83       	std	Z+2, r26	; 0x02
     eee:	b3 83       	std	Z+3, r27	; 0x03
     ef0:	fe 01       	movw	r30, r28
     ef2:	e1 5e       	subi	r30, 0xE1	; 225
     ef4:	fe 4f       	sbci	r31, 0xFE	; 254
     ef6:	80 81       	ld	r24, Z
     ef8:	91 81       	ldd	r25, Z+1	; 0x01
     efa:	a2 81       	ldd	r26, Z+2	; 0x02
     efc:	b3 81       	ldd	r27, Z+3	; 0x03
     efe:	fa 01       	movw	r30, r20
     f00:	e1 5e       	subi	r30, 0xE1	; 225
     f02:	fe 4f       	sbci	r31, 0xFE	; 254
     f04:	80 83       	st	Z, r24
     f06:	91 83       	std	Z+1, r25	; 0x01
     f08:	a2 83       	std	Z+2, r26	; 0x02
     f0a:	b3 83       	std	Z+3, r27	; 0x03
     f0c:	fe 01       	movw	r30, r28
     f0e:	ed 5d       	subi	r30, 0xDD	; 221
     f10:	fe 4f       	sbci	r31, 0xFE	; 254
     f12:	80 81       	ld	r24, Z
     f14:	fa 01       	movw	r30, r20
     f16:	ed 5d       	subi	r30, 0xDD	; 221
     f18:	fe 4f       	sbci	r31, 0xFE	; 254
     f1a:	80 83       	st	Z, r24
     f1c:	fe 01       	movw	r30, r28
     f1e:	ec 5d       	subi	r30, 0xDC	; 220
     f20:	fe 4f       	sbci	r31, 0xFE	; 254
     f22:	80 81       	ld	r24, Z
     f24:	fa 01       	movw	r30, r20
     f26:	ec 5d       	subi	r30, 0xDC	; 220
     f28:	fe 4f       	sbci	r31, 0xFE	; 254
     f2a:	80 83       	st	Z, r24
     f2c:	fe 01       	movw	r30, r28
     f2e:	eb 5d       	subi	r30, 0xDB	; 219
     f30:	fe 4f       	sbci	r31, 0xFE	; 254
     f32:	80 81       	ld	r24, Z
     f34:	91 81       	ldd	r25, Z+1	; 0x01
     f36:	a2 81       	ldd	r26, Z+2	; 0x02
     f38:	b3 81       	ldd	r27, Z+3	; 0x03
     f3a:	fa 01       	movw	r30, r20
     f3c:	eb 5d       	subi	r30, 0xDB	; 219
     f3e:	fe 4f       	sbci	r31, 0xFE	; 254
     f40:	80 83       	st	Z, r24
     f42:	91 83       	std	Z+1, r25	; 0x01
     f44:	a2 83       	std	Z+2, r26	; 0x02
     f46:	b3 83       	std	Z+3, r27	; 0x03
     f48:	fe 01       	movw	r30, r28
     f4a:	e7 5d       	subi	r30, 0xD7	; 215
     f4c:	fe 4f       	sbci	r31, 0xFE	; 254
     f4e:	80 81       	ld	r24, Z
     f50:	fa 01       	movw	r30, r20
     f52:	e7 5d       	subi	r30, 0xD7	; 215
     f54:	fe 4f       	sbci	r31, 0xFE	; 254
     f56:	80 83       	st	Z, r24
     f58:	fe 01       	movw	r30, r28
     f5a:	e6 5d       	subi	r30, 0xD6	; 214
     f5c:	fe 4f       	sbci	r31, 0xFE	; 254
     f5e:	80 81       	ld	r24, Z
     f60:	fa 01       	movw	r30, r20
     f62:	e6 5d       	subi	r30, 0xD6	; 214
     f64:	fe 4f       	sbci	r31, 0xFE	; 254
     f66:	80 83       	st	Z, r24
     f68:	fe 01       	movw	r30, r28
     f6a:	e5 5d       	subi	r30, 0xD5	; 213
     f6c:	fe 4f       	sbci	r31, 0xFE	; 254
     f6e:	80 81       	ld	r24, Z
     f70:	fa 01       	movw	r30, r20
     f72:	e5 5d       	subi	r30, 0xD5	; 213
     f74:	fe 4f       	sbci	r31, 0xFE	; 254
     f76:	80 83       	st	Z, r24
     f78:	fe 01       	movw	r30, r28
     f7a:	e4 5d       	subi	r30, 0xD4	; 212
     f7c:	fe 4f       	sbci	r31, 0xFE	; 254
     f7e:	80 81       	ld	r24, Z
     f80:	91 81       	ldd	r25, Z+1	; 0x01
     f82:	fa 01       	movw	r30, r20
     f84:	e4 5d       	subi	r30, 0xD4	; 212
     f86:	fe 4f       	sbci	r31, 0xFE	; 254
     f88:	91 83       	std	Z+1, r25	; 0x01
     f8a:	80 83       	st	Z, r24
     f8c:	fe 01       	movw	r30, r28
     f8e:	e2 5d       	subi	r30, 0xD2	; 210
     f90:	fe 4f       	sbci	r31, 0xFE	; 254
     f92:	80 81       	ld	r24, Z
     f94:	91 81       	ldd	r25, Z+1	; 0x01
     f96:	a2 81       	ldd	r26, Z+2	; 0x02
     f98:	b3 81       	ldd	r27, Z+3	; 0x03
     f9a:	fa 01       	movw	r30, r20
     f9c:	e2 5d       	subi	r30, 0xD2	; 210
     f9e:	fe 4f       	sbci	r31, 0xFE	; 254
     fa0:	80 83       	st	Z, r24
     fa2:	91 83       	std	Z+1, r25	; 0x01
     fa4:	a2 83       	std	Z+2, r26	; 0x02
     fa6:	b3 83       	std	Z+3, r27	; 0x03
     fa8:	fe 01       	movw	r30, r28
     faa:	ee 5c       	subi	r30, 0xCE	; 206
     fac:	fe 4f       	sbci	r31, 0xFE	; 254
     fae:	80 81       	ld	r24, Z
     fb0:	fa 01       	movw	r30, r20
     fb2:	ee 5c       	subi	r30, 0xCE	; 206
     fb4:	fe 4f       	sbci	r31, 0xFE	; 254
     fb6:	80 83       	st	Z, r24
     fb8:	cd 5c       	subi	r28, 0xCD	; 205
     fba:	de 4f       	sbci	r29, 0xFE	; 254
     fbc:	88 81       	ld	r24, Y
     fbe:	31 96       	adiw	r30, 0x01	; 1
     fc0:	80 83       	st	Z, r24
     fc2:	ca 01       	movw	r24, r20
     fc4:	df 91       	pop	r29
     fc6:	cf 91       	pop	r28
     fc8:	08 95       	ret

00000fca <_ZN3etl3getILj1EJNS_9monostateE6StringN3gel5ErrorEEEERNS_19variant_alternativeIXT_ENS_7variantIJDpT0_EEEE4typeERS9_>:
    ETL_ASSERT(Index == v.index(), ETL_ERROR(etl::variant_incorrect_type_exception));

		using type = etl::variant_alternative_t<Index, etl::variant<TTypes...>>;

    return *static_cast<type*>(v.data);
  }
     fca:	08 95       	ret

00000fcc <_ZN3gel4Link5beginERNS_5RadioENS_10LinkConfigE>:
#include "gel/Link.h"

namespace gel {

Error Link::begin(Radio &radio, LinkConfig config)
{
     fcc:	af 92       	push	r10
     fce:	bf 92       	push	r11
     fd0:	cf 92       	push	r12
     fd2:	df 92       	push	r13
     fd4:	ef 92       	push	r14
     fd6:	ff 92       	push	r15
     fd8:	0f 93       	push	r16
     fda:	1f 93       	push	r17
     fdc:	cf 93       	push	r28
     fde:	df 93       	push	r29
     fe0:	cd b7       	in	r28, 0x3d	; 61
     fe2:	de b7       	in	r29, 0x3e	; 62
     fe4:	29 97       	sbiw	r28, 0x09	; 9
     fe6:	0f b6       	in	r0, 0x3f	; 63
     fe8:	f8 94       	cli
     fea:	de bf       	out	0x3e, r29	; 62
     fec:	0f be       	out	0x3f, r0	; 63
     fee:	cd bf       	out	0x3d, r28	; 61
     ff0:	db 01       	movw	r26, r22
     ff2:	a9 82       	std	Y+1, r10	; 0x01
     ff4:	ba 82       	std	Y+2, r11	; 0x02
     ff6:	cb 82       	std	Y+3, r12	; 0x03
     ff8:	dc 82       	std	Y+4, r13	; 0x04
     ffa:	ed 82       	std	Y+5, r14	; 0x05
     ffc:	fe 82       	std	Y+6, r15	; 0x06
     ffe:	0f 83       	std	Y+7, r16	; 0x07
    1000:	18 87       	std	Y+8, r17	; 0x08
    1002:	29 87       	std	Y+9, r18	; 0x09
    this->initialized = true;
    1004:	21 e0       	ldi	r18, 0x01	; 1
    1006:	2c 93       	st	X, r18
    this->radio = &radio;
    1008:	12 96       	adiw	r26, 0x02	; 2
    100a:	5c 93       	st	X, r21
    100c:	4e 93       	st	-X, r20
    100e:	11 97       	sbiw	r26, 0x01	; 1
    this->config = config;
    1010:	29 e0       	ldi	r18, 0x09	; 9
    1012:	fe 01       	movw	r30, r28
    1014:	31 96       	adiw	r30, 0x01	; 1
    1016:	13 96       	adiw	r26, 0x03	; 3
    1018:	01 90       	ld	r0, Z+
    101a:	0d 92       	st	X+, r0
    101c:	2a 95       	dec	r18
    101e:	e1 f7       	brne	.-8      	; 0x1018 <_ZN3gel4Link5beginERNS_5RadioENS_10LinkConfigE+0x4c>
        CapacityFull,
        NotImplemented,
    };

    Error() = default;
    Error(Code other) : code(other) {}
    1020:	2c e8       	ldi	r18, 0x8C	; 140
    1022:	32 e0       	ldi	r19, 0x02	; 2
    1024:	fc 01       	movw	r30, r24
    1026:	31 83       	std	Z+1, r19	; 0x01
    1028:	20 83       	st	Z, r18
    102a:	13 82       	std	Z+3, r1	; 0x03
    102c:	12 82       	std	Z+2, r1	; 0x02
    102e:	15 82       	std	Z+5, r1	; 0x05
    1030:	14 82       	std	Z+4, r1	; 0x04

    return Error::None;
}
    1032:	29 96       	adiw	r28, 0x09	; 9
    1034:	0f b6       	in	r0, 0x3f	; 63
    1036:	f8 94       	cli
    1038:	de bf       	out	0x3e, r29	; 62
    103a:	0f be       	out	0x3f, r0	; 63
    103c:	cd bf       	out	0x3d, r28	; 61
    103e:	df 91       	pop	r29
    1040:	cf 91       	pop	r28
    1042:	1f 91       	pop	r17
    1044:	0f 91       	pop	r16
    1046:	ff 90       	pop	r15
    1048:	ef 90       	pop	r14
    104a:	df 90       	pop	r13
    104c:	cf 90       	pop	r12
    104e:	bf 90       	pop	r11
    1050:	af 90       	pop	r10
    1052:	08 95       	ret

00001054 <_ZN11RadioLibHal22writePersistentStorageEmPhj>:
void RadioLibHal::writePersistentStorage(uint32_t addr, uint8_t* buff, size_t len) {
  // these are only needed for some protocols, so it's not needed to have them by default
  (void)addr;
  (void)buff;
  (void)len;
}
    1054:	08 95       	ret

00001056 <_ZN11RadioLibHal21readPersistentStorageEmPhj>:
void RadioLibHal::readPersistentStorage(uint32_t addr, uint8_t* buff, size_t len) {
  // these are only needed for some protocols, so it's not needed to have them by default
  (void)addr;
  (void)buff;
  (void)len;
}
    1056:	08 95       	ret

00001058 <_ZN11RadioLibHal14pinToInterruptEm>:

}

uint32_t RadioLibHal::pinToInterrupt(uint32_t pin) {
  return(pin);
}
    1058:	cb 01       	movw	r24, r22
    105a:	ba 01       	movw	r22, r20
    105c:	08 95       	ret

0000105e <_ZN11RadioLibHal5yieldEv>:
  (void)pin;
}

void RadioLibHal::yield() {

}
    105e:	08 95       	ret

00001060 <_ZN11RadioLibHal6noToneEm>:
  (void)duration;
}

void RadioLibHal::noTone(uint32_t pin) {
  (void)pin;
}
    1060:	08 95       	ret

00001062 <_ZN11RadioLibHal4toneEmjm>:

void RadioLibHal::tone(uint32_t pin, unsigned int frequency, unsigned long duration) {
  (void)pin;
  (void)frequency;
  (void)duration;
}
    1062:	08 95       	ret

00001064 <_ZN11RadioLibHal4termEv>:

}

void RadioLibHal::term() {

}
    1064:	08 95       	ret

00001066 <_ZN11RadioLibHal4initEv>:
      GpioInterruptRising(rising),
      GpioInterruptFalling(falling) {}

void RadioLibHal::init() {

}
    1066:	08 95       	ret

00001068 <_ZN11RadioLibHalC2Emmmmmm>:
#include "Hal.h"

RadioLibHal::RadioLibHal(const uint32_t input, const uint32_t output, const uint32_t low, const uint32_t high, const uint32_t rising, const uint32_t falling)
    1068:	8f 92       	push	r8
    106a:	9f 92       	push	r9
    106c:	af 92       	push	r10
    106e:	bf 92       	push	r11
    1070:	cf 92       	push	r12
    1072:	df 92       	push	r13
    1074:	ef 92       	push	r14
    1076:	ff 92       	push	r15
    1078:	0f 93       	push	r16
    107a:	1f 93       	push	r17
    107c:	cf 93       	push	r28
    107e:	df 93       	push	r29
    1080:	cd b7       	in	r28, 0x3d	; 61
    1082:	de b7       	in	r29, 0x3e	; 62
    1084:	fc 01       	movw	r30, r24
    : GpioModeInput(input),
      GpioModeOutput(output),
      GpioLevelLow(low),
      GpioLevelHigh(high),
      GpioInterruptRising(rising),
      GpioInterruptFalling(falling) {}
    1086:	8a e5       	ldi	r24, 0x5A	; 90
    1088:	92 e0       	ldi	r25, 0x02	; 2
    108a:	91 83       	std	Z+1, r25	; 0x01
    108c:	80 83       	st	Z, r24
    108e:	42 83       	std	Z+2, r20	; 0x02
    1090:	53 83       	std	Z+3, r21	; 0x03
    1092:	64 83       	std	Z+4, r22	; 0x04
    1094:	75 83       	std	Z+5, r23	; 0x05
    1096:	06 83       	std	Z+6, r16	; 0x06
    1098:	17 83       	std	Z+7, r17	; 0x07
    109a:	20 87       	std	Z+8, r18	; 0x08
    109c:	31 87       	std	Z+9, r19	; 0x09
    109e:	c2 86       	std	Z+10, r12	; 0x0a
    10a0:	d3 86       	std	Z+11, r13	; 0x0b
    10a2:	e4 86       	std	Z+12, r14	; 0x0c
    10a4:	f5 86       	std	Z+13, r15	; 0x0d
    10a6:	86 86       	std	Z+14, r8	; 0x0e
    10a8:	97 86       	std	Z+15, r9	; 0x0f
    10aa:	a0 8a       	std	Z+16, r10	; 0x10
    10ac:	b1 8a       	std	Z+17, r11	; 0x11
    10ae:	8f 85       	ldd	r24, Y+15	; 0x0f
    10b0:	98 89       	ldd	r25, Y+16	; 0x10
    10b2:	a9 89       	ldd	r26, Y+17	; 0x11
    10b4:	ba 89       	ldd	r27, Y+18	; 0x12
    10b6:	82 8b       	std	Z+18, r24	; 0x12
    10b8:	93 8b       	std	Z+19, r25	; 0x13
    10ba:	a4 8b       	std	Z+20, r26	; 0x14
    10bc:	b5 8b       	std	Z+21, r27	; 0x15
    10be:	8b 89       	ldd	r24, Y+19	; 0x13
    10c0:	9c 89       	ldd	r25, Y+20	; 0x14
    10c2:	ad 89       	ldd	r26, Y+21	; 0x15
    10c4:	be 89       	ldd	r27, Y+22	; 0x16
    10c6:	86 8b       	std	Z+22, r24	; 0x16
    10c8:	97 8b       	std	Z+23, r25	; 0x17
    10ca:	a0 8f       	std	Z+24, r26	; 0x18
    10cc:	b1 8f       	std	Z+25, r27	; 0x19
    10ce:	df 91       	pop	r29
    10d0:	cf 91       	pop	r28
    10d2:	1f 91       	pop	r17
    10d4:	0f 91       	pop	r16
    10d6:	ff 90       	pop	r15
    10d8:	ef 90       	pop	r14
    10da:	df 90       	pop	r13
    10dc:	cf 90       	pop	r12
    10de:	bf 90       	pop	r11
    10e0:	af 90       	pop	r10
    10e2:	9f 90       	pop	r9
    10e4:	8f 90       	pop	r8
    10e6:	08 95       	ret

000010e8 <_ZN10ArduinoHal14pinToInterruptEm>:
  ::yield();
  #endif
}

uint32_t inline ArduinoHal::pinToInterrupt(uint32_t pin) {
  return(digitalPinToInterrupt(pin));
    10e8:	42 30       	cpi	r20, 0x02	; 2
    10ea:	51 05       	cpc	r21, r1
    10ec:	61 05       	cpc	r22, r1
    10ee:	71 05       	cpc	r23, r1
    10f0:	51 f0       	breq	.+20     	; 0x1106 <_ZN10ArduinoHal14pinToInterruptEm+0x1e>
    10f2:	43 30       	cpi	r20, 0x03	; 3
    10f4:	51 05       	cpc	r21, r1
    10f6:	61 05       	cpc	r22, r1
    10f8:	71 05       	cpc	r23, r1
    10fa:	49 f4       	brne	.+18     	; 0x110e <_ZN10ArduinoHal14pinToInterruptEm+0x26>
    10fc:	61 e0       	ldi	r22, 0x01	; 1
    10fe:	70 e0       	ldi	r23, 0x00	; 0
    1100:	80 e0       	ldi	r24, 0x00	; 0
    1102:	90 e0       	ldi	r25, 0x00	; 0
    1104:	08 95       	ret
    1106:	60 e0       	ldi	r22, 0x00	; 0
    1108:	70 e0       	ldi	r23, 0x00	; 0
    110a:	cb 01       	movw	r24, r22
    110c:	08 95       	ret
    110e:	6f ef       	ldi	r22, 0xFF	; 255
    1110:	7f ef       	ldi	r23, 0xFF	; 255
    1112:	cb 01       	movw	r24, r22
}
    1114:	08 95       	ret

00001116 <_ZN10ArduinoHal5yieldEv>:

void inline ArduinoHal::yield() {
  #if !defined(RADIOLIB_YIELD_UNSUPPORTED)
  ::yield();
  #endif
}
    1116:	08 95       	ret

00001118 <_ZN10ArduinoHal6noToneEm>:
    if(pin == RADIOLIB_NC) {
      return;
    }
    ::noTone(pin, false);
  #elif !defined(RADIOLIB_TONE_UNSUPPORTED)
    if(pin == RADIOLIB_NC) {
    1118:	4f 3f       	cpi	r20, 0xFF	; 255
    111a:	8f ef       	ldi	r24, 0xFF	; 255
    111c:	58 07       	cpc	r21, r24
    111e:	68 07       	cpc	r22, r24
    1120:	78 07       	cpc	r23, r24
    1122:	19 f0       	breq	.+6      	; 0x112a <_ZN10ArduinoHal6noToneEm+0x12>
    1124:	ca 01       	movw	r24, r20
      return;
    }
    ::noTone(pin);
    1126:	0e 94 be 02 	call	0x57c	; 0x57c <_Z6noToneh>
    }
    // better tone for mbed OS boards
    (void)pin;
    pwmPin->suspend();
  #endif
}
    112a:	08 95       	ret

0000112c <_ZN10ArduinoHal4toneEmjm>:
      EEPROM.end();
    #endif
  #endif
}

void inline ArduinoHal::tone(uint32_t pin, unsigned int frequency, unsigned long duration) {
    112c:	ef 92       	push	r14
    112e:	ff 92       	push	r15
    1130:	0f 93       	push	r16
    1132:	1f 93       	push	r17
  #if !defined(RADIOLIB_TONE_UNSUPPORTED)
    if(pin == RADIOLIB_NC) {
    1134:	4f 3f       	cpi	r20, 0xFF	; 255
    1136:	8f ef       	ldi	r24, 0xFF	; 255
    1138:	58 07       	cpc	r21, r24
    113a:	68 07       	cpc	r22, r24
    113c:	78 07       	cpc	r23, r24
    113e:	39 f0       	breq	.+14     	; 0x114e <_ZN10ArduinoHal4toneEmjm+0x22>
    1140:	f9 01       	movw	r30, r18
    1142:	ca 01       	movw	r24, r20
      return;
    }
    ::tone(pin, frequency, duration);
    1144:	a8 01       	movw	r20, r16
    1146:	97 01       	movw	r18, r14
    1148:	bf 01       	movw	r22, r30
    114a:	0e 94 6f 03 	call	0x6de	; 0x6de <_Z4tonehjm>
      pwmPin = new mbed::PwmOut(digitalPinToPinName(pin));
    }
    pwmPin->period(1.0 / frequency);
    pwmPin->write(0.5);
  #endif
}
    114e:	1f 91       	pop	r17
    1150:	0f 91       	pop	r16
    1152:	ff 90       	pop	r15
    1154:	ef 90       	pop	r14
    1156:	08 95       	ret

00001158 <_ZN10ArduinoHal6spiEndEv>:
void inline ArduinoHal::spiEndTransaction() {
  spi->endTransaction();
}

void inline ArduinoHal::spiEnd() {
  spi->end();
    1158:	0e 94 8e 00 	call	0x11c	; 0x11c <_ZN8SPIClass3endEv>
}
    115c:	08 95       	ret

0000115e <_ZN10ArduinoHal17spiEndTransactionEv>:
      digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
    }
    inTransactionFlag = 0;
    #endif

    if (interruptMode > 0) {
    115e:	80 91 97 07 	lds	r24, 0x0797	; 0x800797 <_ZN8SPIClass13interruptModeE>
    1162:	88 23       	and	r24, r24
    1164:	49 f0       	breq	.+18     	; 0x1178 <_ZN10ArduinoHal17spiEndTransactionEv+0x1a>
      #ifdef SPI_AVR_EIMSK
      uint8_t sreg = SREG;
    1166:	9f b7       	in	r25, 0x3f	; 63
      #endif
      noInterrupts();
    1168:	f8 94       	cli
      #ifdef SPI_AVR_EIMSK
      if (interruptMode == 1) {
    116a:	80 91 97 07 	lds	r24, 0x0797	; 0x800797 <_ZN8SPIClass13interruptModeE>
    116e:	81 30       	cpi	r24, 0x01	; 1
    1170:	21 f0       	breq	.+8      	; 0x117a <_ZN10ArduinoHal17spiEndTransactionEv+0x1c>
        SPI_AVR_EIMSK = interruptSave;
        SREG = sreg;
      } else
      #endif
      {
        SREG = interruptSave;
    1172:	80 91 da 06 	lds	r24, 0x06DA	; 0x8006da <_ZN8SPIClass13interruptSaveE>
    1176:	8f bf       	out	0x3f, r24	; 63
  }
}

void inline ArduinoHal::spiEndTransaction() {
  spi->endTransaction();
}
    1178:	08 95       	ret
      uint8_t sreg = SREG;
      #endif
      noInterrupts();
      #ifdef SPI_AVR_EIMSK
      if (interruptMode == 1) {
        SPI_AVR_EIMSK = interruptSave;
    117a:	80 91 da 06 	lds	r24, 0x06DA	; 0x8006da <_ZN8SPIClass13interruptSaveE>
    117e:	8d bb       	out	0x1d, r24	; 29
        SREG = sreg;
    1180:	9f bf       	out	0x3f, r25	; 63
    1182:	08 95       	ret

00001184 <_ZN10ArduinoHal11spiTransferEPhjS0_>:

void inline ArduinoHal::spiBeginTransaction() {
  spi->beginTransaction(spiSettings);
}

void ArduinoHal::spiTransfer(uint8_t* out, size_t len, uint8_t* in) {
    1184:	d9 01       	movw	r26, r18
  for(size_t i = 0; i < len; i++) {
    1186:	90 e0       	ldi	r25, 0x00	; 0
    1188:	80 e0       	ldi	r24, 0x00	; 0
    118a:	84 17       	cp	r24, r20
    118c:	95 07       	cpc	r25, r21
    118e:	80 f4       	brcc	.+32     	; 0x11b0 <_ZN10ArduinoHal11spiTransferEPhjS0_+0x2c>
    in[i] = spi->transfer(out[i]);
    1190:	fb 01       	movw	r30, r22
    1192:	e8 0f       	add	r30, r24
    1194:	f9 1f       	adc	r31, r25
    1196:	30 81       	ld	r19, Z
    1198:	fd 01       	movw	r30, r26
    119a:	e8 0f       	add	r30, r24
    119c:	f9 1f       	adc	r31, r25
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    119e:	3e bd       	out	0x2e, r19	; 46
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    11a0:	00 00       	nop
    while (!(SPSR & _BV(SPIF))) ; // wait
    11a2:	0d b4       	in	r0, 0x2d	; 45
    11a4:	07 fe       	sbrs	r0, 7
    11a6:	fd cf       	rjmp	.-6      	; 0x11a2 <_ZN10ArduinoHal11spiTransferEPhjS0_+0x1e>
    return SPDR;
    11a8:	3e b5       	in	r19, 0x2e	; 46
    11aa:	30 83       	st	Z, r19
void inline ArduinoHal::spiBeginTransaction() {
  spi->beginTransaction(spiSettings);
}

void ArduinoHal::spiTransfer(uint8_t* out, size_t len, uint8_t* in) {
  for(size_t i = 0; i < len; i++) {
    11ac:	01 96       	adiw	r24, 0x01	; 1
    11ae:	ed cf       	rjmp	.-38     	; 0x118a <_ZN10ArduinoHal11spiTransferEPhjS0_+0x6>
    in[i] = spi->transfer(out[i]);
  }
}
    11b0:	08 95       	ret

000011b2 <_ZN10ArduinoHal19spiBeginTransactionEv>:

void inline ArduinoHal::spiBegin() {
  spi->begin();
}

void inline ArduinoHal::spiBeginTransaction() {
    11b2:	fc 01       	movw	r30, r24
    11b4:	24 8d       	ldd	r18, Z+28	; 0x1c
    11b6:	85 8d       	ldd	r24, Z+29	; 0x1d

  // Before using SPI.transfer() or asserting chip select pins,
  // this function is used to gain exclusive access to the SPI bus
  // and configure the correct settings.
  inline static void beginTransaction(SPISettings settings) {
    if (interruptMode > 0) {
    11b8:	90 91 97 07 	lds	r25, 0x0797	; 0x800797 <_ZN8SPIClass13interruptModeE>
    11bc:	99 23       	and	r25, r25
    11be:	41 f0       	breq	.+16     	; 0x11d0 <_ZN10ArduinoHal19spiBeginTransactionEv+0x1e>
      uint8_t sreg = SREG;
    11c0:	3f b7       	in	r19, 0x3f	; 63
      noInterrupts();
    11c2:	f8 94       	cli

      #ifdef SPI_AVR_EIMSK
      if (interruptMode == 1) {
    11c4:	90 91 97 07 	lds	r25, 0x0797	; 0x800797 <_ZN8SPIClass13interruptModeE>
    11c8:	91 30       	cpi	r25, 0x01	; 1
    11ca:	29 f0       	breq	.+10     	; 0x11d6 <_ZN10ArduinoHal19spiBeginTransactionEv+0x24>
        SPI_AVR_EIMSK &= ~interruptMask;
        SREG = sreg;
      } else
      #endif
      {
        interruptSave = sreg;
    11cc:	30 93 da 06 	sts	0x06DA, r19	; 0x8006da <_ZN8SPIClass13interruptSaveE>
      digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
    }
    inTransactionFlag = 1;
    #endif

    SPCR = settings.spcr;
    11d0:	2c bd       	out	0x2c, r18	; 44
    SPSR = settings.spsr;
    11d2:	8d bd       	out	0x2d, r24	; 45
  spi->beginTransaction(spiSettings);
}
    11d4:	08 95       	ret
      uint8_t sreg = SREG;
      noInterrupts();

      #ifdef SPI_AVR_EIMSK
      if (interruptMode == 1) {
        interruptSave = SPI_AVR_EIMSK;
    11d6:	9d b3       	in	r25, 0x1d	; 29
    11d8:	90 93 da 06 	sts	0x06DA, r25	; 0x8006da <_ZN8SPIClass13interruptSaveE>
        SPI_AVR_EIMSK &= ~interruptMask;
    11dc:	9d b3       	in	r25, 0x1d	; 29
    11de:	9d bb       	out	0x1d, r25	; 29
        SREG = sreg;
    11e0:	3f bf       	out	0x3f, r19	; 63
    11e2:	f6 cf       	rjmp	.-20     	; 0x11d0 <_ZN10ArduinoHal19spiBeginTransactionEv+0x1e>

000011e4 <_ZN10ArduinoHal8spiBeginEv>:
  }
  return(::pulseIn(pin, state, timeout));
}

void inline ArduinoHal::spiBegin() {
  spi->begin();
    11e4:	0e 94 6f 01 	call	0x2de	; 0x2de <_ZN8SPIClass5beginEv>
}
    11e8:	08 95       	ret

000011ea <_ZN10ArduinoHal6microsEv>:
unsigned long inline ArduinoHal::millis() {
  return(::millis());
}

unsigned long inline ArduinoHal::micros() {
  return(::micros());
    11ea:	0e 94 ec 01 	call	0x3d8	; 0x3d8 <micros>
}
    11ee:	08 95       	ret

000011f0 <_ZN10ArduinoHal6millisEv>:
void inline ArduinoHal::delayMicroseconds(unsigned long us) {
  ::delayMicroseconds(us);
}

unsigned long inline ArduinoHal::millis() {
  return(::millis());
    11f0:	0e 94 12 02 	call	0x424	; 0x424 <millis>
}
    11f4:	08 95       	ret

000011f6 <_ZN10ArduinoHal17delayMicrosecondsEm>:
void inline ArduinoHal::delay(unsigned long ms) {
  ::delay(ms);
}

void inline ArduinoHal::delayMicroseconds(unsigned long us) {
  ::delayMicroseconds(us);
    11f6:	ca 01       	movw	r24, r20
    11f8:	0e 94 e1 01 	call	0x3c2	; 0x3c2 <delayMicroseconds>
}
    11fc:	08 95       	ret

000011fe <_ZN10ArduinoHal5delayEm>:
  }
  ::detachInterrupt(interruptNum);
}

void inline ArduinoHal::delay(unsigned long ms) {
  ::delay(ms);
    11fe:	cb 01       	movw	r24, r22
    1200:	ba 01       	movw	r22, r20
    1202:	0e 94 22 02 	call	0x444	; 0x444 <delay>
}
    1206:	08 95       	ret

00001208 <_ZN10ArduinoHal15detachInterruptEm>:
  }
  ::attachInterrupt(interruptNum, interruptCb,  RADIOLIB_ARDUINOHAL_INTERRUPT_MODE_CAST mode);
}

void inline ArduinoHal::detachInterrupt(uint32_t interruptNum) {
  if(interruptNum == RADIOLIB_NC) {
    1208:	4f 3f       	cpi	r20, 0xFF	; 255
    120a:	8f ef       	ldi	r24, 0xFF	; 255
    120c:	58 07       	cpc	r21, r24
    120e:	68 07       	cpc	r22, r24
    1210:	78 07       	cpc	r23, r24
    1212:	19 f0       	breq	.+6      	; 0x121a <_ZN10ArduinoHal15detachInterruptEm+0x12>
    1214:	ca 01       	movw	r24, r20
    return;
  }
  ::detachInterrupt(interruptNum);
    1216:	0e 94 5b 02 	call	0x4b6	; 0x4b6 <detachInterrupt>
}
    121a:	08 95       	ret

0000121c <_ZN10ArduinoHal15attachInterruptEmPFvvEm>:
    return 0;
  }
  return(::digitalRead(pin));
}

void inline ArduinoHal::attachInterrupt(uint32_t interruptNum, void (*interruptCb)(void), uint32_t mode) {
    121c:	ef 92       	push	r14
    121e:	ff 92       	push	r15
    1220:	0f 93       	push	r16
    1222:	1f 93       	push	r17
  if(interruptNum == RADIOLIB_NC) {
    1224:	4f 3f       	cpi	r20, 0xFF	; 255
    1226:	8f ef       	ldi	r24, 0xFF	; 255
    1228:	58 07       	cpc	r21, r24
    122a:	68 07       	cpc	r22, r24
    122c:	78 07       	cpc	r23, r24
    122e:	29 f0       	breq	.+10     	; 0x123a <_ZN10ArduinoHal15attachInterruptEmPFvvEm+0x1e>
    1230:	ca 01       	movw	r24, r20
    return;
  }
  ::attachInterrupt(interruptNum, interruptCb,  RADIOLIB_ARDUINOHAL_INTERRUPT_MODE_CAST mode);
    1232:	a7 01       	movw	r20, r14
    1234:	b9 01       	movw	r22, r18
    1236:	0e 94 76 02 	call	0x4ec	; 0x4ec <attachInterrupt>
}
    123a:	1f 91       	pop	r17
    123c:	0f 91       	pop	r16
    123e:	ff 90       	pop	r15
    1240:	ef 90       	pop	r14
    1242:	08 95       	ret

00001244 <_ZN10ArduinoHal11digitalReadEm>:
  }
  ::digitalWrite(pin, RADIOLIB_ARDUINOHAL_PIN_STATUS_CAST value);
}

uint32_t inline ArduinoHal::digitalRead(uint32_t pin) {
  if(pin == RADIOLIB_NC) {
    1244:	4f 3f       	cpi	r20, 0xFF	; 255
    1246:	8f ef       	ldi	r24, 0xFF	; 255
    1248:	58 07       	cpc	r21, r24
    124a:	68 07       	cpc	r22, r24
    124c:	78 07       	cpc	r23, r24
    124e:	41 f0       	breq	.+16     	; 0x1260 <_ZN10ArduinoHal11digitalReadEm+0x1c>
    1250:	ca 01       	movw	r24, r20
    return 0;
  }
  return(::digitalRead(pin));
    1252:	0e 94 d0 00 	call	0x1a0	; 0x1a0 <digitalRead>
    1256:	bc 01       	movw	r22, r24
    1258:	99 0f       	add	r25, r25
    125a:	88 0b       	sbc	r24, r24
    125c:	99 0b       	sbc	r25, r25
    125e:	08 95       	ret
  ::digitalWrite(pin, RADIOLIB_ARDUINOHAL_PIN_STATUS_CAST value);
}

uint32_t inline ArduinoHal::digitalRead(uint32_t pin) {
  if(pin == RADIOLIB_NC) {
    return 0;
    1260:	60 e0       	ldi	r22, 0x00	; 0
    1262:	70 e0       	ldi	r23, 0x00	; 0
    1264:	cb 01       	movw	r24, r22
  }
  return(::digitalRead(pin));
}
    1266:	08 95       	ret

00001268 <_ZN10ArduinoHal12digitalWriteEmm>:
    return;
  }
  ::pinMode(pin, RADIOLIB_ARDUINOHAL_PIN_MODE_CAST mode);
}

void inline ArduinoHal::digitalWrite(uint32_t pin, uint32_t value) {
    1268:	0f 93       	push	r16
  if(pin == RADIOLIB_NC) {
    126a:	4f 3f       	cpi	r20, 0xFF	; 255
    126c:	8f ef       	ldi	r24, 0xFF	; 255
    126e:	58 07       	cpc	r21, r24
    1270:	68 07       	cpc	r22, r24
    1272:	78 07       	cpc	r23, r24
    1274:	21 f0       	breq	.+8      	; 0x127e <_ZN10ArduinoHal12digitalWriteEmm+0x16>
    1276:	ca 01       	movw	r24, r20
    return;
  }
  ::digitalWrite(pin, RADIOLIB_ARDUINOHAL_PIN_STATUS_CAST value);
    1278:	60 2f       	mov	r22, r16
    127a:	0e 94 fd 00 	call	0x1fa	; 0x1fa <digitalWrite>
}
    127e:	0f 91       	pop	r16
    1280:	08 95       	ret

00001282 <_ZN10ArduinoHal7pinModeEmm>:
  if(initInterface) {
    spiEnd();
  }
}

void inline ArduinoHal::pinMode(uint32_t pin, uint32_t mode) {
    1282:	0f 93       	push	r16
  if(pin == RADIOLIB_NC) {
    1284:	4f 3f       	cpi	r20, 0xFF	; 255
    1286:	8f ef       	ldi	r24, 0xFF	; 255
    1288:	58 07       	cpc	r21, r24
    128a:	68 07       	cpc	r22, r24
    128c:	78 07       	cpc	r23, r24
    128e:	21 f0       	breq	.+8      	; 0x1298 <_ZN10ArduinoHal7pinModeEmm+0x16>
    1290:	ca 01       	movw	r24, r20
    return;
  }
  ::pinMode(pin, RADIOLIB_ARDUINOHAL_PIN_MODE_CAST mode);
    1292:	60 2f       	mov	r22, r16
    1294:	0e 94 30 01 	call	0x260	; 0x260 <pinMode>
}
    1298:	0f 91       	pop	r16
    129a:	08 95       	ret

0000129c <_ZN10ArduinoHal4termEv>:
    spiBegin();
  }
}

void ArduinoHal::term() {
  if(initInterface) {
    129c:	dc 01       	movw	r26, r24
    129e:	5e 96       	adiw	r26, 0x1e	; 30
    12a0:	2c 91       	ld	r18, X
    12a2:	5e 97       	sbiw	r26, 0x1e	; 30
    12a4:	22 23       	and	r18, r18
    12a6:	31 f0       	breq	.+12     	; 0x12b4 <_ZN10ArduinoHal4termEv+0x18>
    spiEnd();
    12a8:	ed 91       	ld	r30, X+
    12aa:	fc 91       	ld	r31, X
    12ac:	04 8c       	ldd	r0, Z+28	; 0x1c
    12ae:	f5 8d       	ldd	r31, Z+29	; 0x1d
    12b0:	e0 2d       	mov	r30, r0
    12b2:	09 95       	icall
  }
}
    12b4:	08 95       	ret

000012b6 <_ZN10ArduinoHal4initEv>:
ArduinoHal::ArduinoHal(): RadioLibHal(INPUT, OUTPUT, LOW, HIGH, RISING, FALLING), spi(&RADIOLIB_DEFAULT_SPI), initInterface(true) {}

ArduinoHal::ArduinoHal(SPIClass& spi, SPISettings spiSettings): RadioLibHal(INPUT, OUTPUT, LOW, HIGH, RISING, FALLING), spi(&spi), spiSettings(spiSettings) {}

void ArduinoHal::init() {
  if(initInterface) {
    12b6:	dc 01       	movw	r26, r24
    12b8:	5e 96       	adiw	r26, 0x1e	; 30
    12ba:	2c 91       	ld	r18, X
    12bc:	5e 97       	sbiw	r26, 0x1e	; 30
    12be:	22 23       	and	r18, r18
    12c0:	31 f0       	breq	.+12     	; 0x12ce <_ZN10ArduinoHal4initEv+0x18>
    spiBegin();
    12c2:	ed 91       	ld	r30, X+
    12c4:	fc 91       	ld	r31, X
    12c6:	04 88       	ldd	r0, Z+20	; 0x14
    12c8:	f5 89       	ldd	r31, Z+21	; 0x15
    12ca:	e0 2d       	mov	r30, r0
    12cc:	09 95       	icall
  }
}
    12ce:	08 95       	ret

000012d0 <_ZN10ArduinoHalC1Ev>:

#if !defined(RADIOLIB_EEPROM_UNSUPPORTED)
#include <EEPROM.h>
#endif

ArduinoHal::ArduinoHal(): RadioLibHal(INPUT, OUTPUT, LOW, HIGH, RISING, FALLING), spi(&RADIOLIB_DEFAULT_SPI), initInterface(true) {}
    12d0:	8f 92       	push	r8
    12d2:	9f 92       	push	r9
    12d4:	af 92       	push	r10
    12d6:	bf 92       	push	r11
    12d8:	cf 92       	push	r12
    12da:	df 92       	push	r13
    12dc:	ef 92       	push	r14
    12de:	ff 92       	push	r15
    12e0:	0f 93       	push	r16
    12e2:	1f 93       	push	r17
    12e4:	cf 93       	push	r28
    12e6:	df 93       	push	r29
    12e8:	ec 01       	movw	r28, r24
    12ea:	1f 92       	push	r1
    12ec:	1f 92       	push	r1
    12ee:	1f 92       	push	r1
    12f0:	82 e0       	ldi	r24, 0x02	; 2
    12f2:	8f 93       	push	r24
    12f4:	1f 92       	push	r1
    12f6:	1f 92       	push	r1
    12f8:	1f 92       	push	r1
    12fa:	83 e0       	ldi	r24, 0x03	; 3
    12fc:	8f 93       	push	r24
    12fe:	81 2c       	mov	r8, r1
    1300:	91 2c       	mov	r9, r1
    1302:	54 01       	movw	r10, r8
    1304:	83 94       	inc	r8
    1306:	c1 2c       	mov	r12, r1
    1308:	d1 2c       	mov	r13, r1
    130a:	76 01       	movw	r14, r12
    130c:	01 e0       	ldi	r16, 0x01	; 1
    130e:	10 e0       	ldi	r17, 0x00	; 0
    1310:	20 e0       	ldi	r18, 0x00	; 0
    1312:	30 e0       	ldi	r19, 0x00	; 0
    1314:	40 e0       	ldi	r20, 0x00	; 0
    1316:	50 e0       	ldi	r21, 0x00	; 0
    1318:	ba 01       	movw	r22, r20
    131a:	ce 01       	movw	r24, r28
    131c:	0e 94 34 08 	call	0x1068	; 0x1068 <_ZN11RadioLibHalC2Emmmmmm>
    1320:	88 e2       	ldi	r24, 0x28	; 40
    1322:	92 e0       	ldi	r25, 0x02	; 2
    1324:	99 83       	std	Y+1, r25	; 0x01
    1326:	88 83       	st	Y, r24
    1328:	89 ed       	ldi	r24, 0xD9	; 217
    132a:	96 e0       	ldi	r25, 0x06	; 6
    132c:	9b 8f       	std	Y+27, r25	; 0x1b
    132e:	8a 8f       	std	Y+26, r24	; 0x1a

    // Invert the SPI2X bit
    clockDiv ^= 0x1;

    // Pack into the SPISettings class
    spcr = _BV(SPE) | _BV(MSTR) | ((bitOrder == LSBFIRST) ? _BV(DORD) : 0) |
    1330:	81 e5       	ldi	r24, 0x51	; 81
    1332:	8c 8f       	std	Y+28, r24	; 0x1c
      (dataMode & SPI_MODE_MASK) | ((clockDiv >> 1) & SPI_CLOCK_MASK);
    spsr = clockDiv & SPI_2XCLOCK_MASK;
    1334:	81 e0       	ldi	r24, 0x01	; 1
    1336:	8d 8f       	std	Y+29, r24	; 0x1d
    1338:	8e 8f       	std	Y+30, r24	; 0x1e
    133a:	8d b7       	in	r24, 0x3d	; 61
    133c:	9e b7       	in	r25, 0x3e	; 62
    133e:	08 96       	adiw	r24, 0x08	; 8
    1340:	0f b6       	in	r0, 0x3f	; 63
    1342:	f8 94       	cli
    1344:	9e bf       	out	0x3e, r25	; 62
    1346:	0f be       	out	0x3f, r0	; 63
    1348:	8d bf       	out	0x3d, r24	; 61
    134a:	df 91       	pop	r29
    134c:	cf 91       	pop	r28
    134e:	1f 91       	pop	r17
    1350:	0f 91       	pop	r16
    1352:	ff 90       	pop	r15
    1354:	ef 90       	pop	r14
    1356:	df 90       	pop	r13
    1358:	cf 90       	pop	r12
    135a:	bf 90       	pop	r11
    135c:	af 90       	pop	r10
    135e:	9f 90       	pop	r9
    1360:	8f 90       	pop	r8
    1362:	08 95       	ret

00001364 <_ZNK6Module16findRfSwitchModeEh>:
  for(size_t i = 0; i < RFSWITCH_MAX_PINS; i++)
    this->hal->pinMode(pins[i], this->hal->GpioModeOutput);
}

const Module::RfSwitchMode_t *Module::findRfSwitchMode(uint8_t mode) const {
  const RfSwitchMode_t *row = this->rfSwitchTable;
    1364:	dc 01       	movw	r26, r24
    1366:	98 96       	adiw	r26, 0x28	; 40
    1368:	ed 91       	ld	r30, X+
    136a:	fc 91       	ld	r31, X
  while (row && row->mode != MODE_END_OF_TABLE) {
    136c:	30 97       	sbiw	r30, 0x00	; 0
    136e:	49 f0       	breq	.+18     	; 0x1382 <_ZNK6Module16findRfSwitchModeEh+0x1e>
    1370:	80 81       	ld	r24, Z
    1372:	88 23       	and	r24, r24
    1374:	21 f0       	breq	.+8      	; 0x137e <_ZNK6Module16findRfSwitchModeEh+0x1a>
    if (row->mode == mode)
    1376:	86 17       	cp	r24, r22
    1378:	21 f0       	breq	.+8      	; 0x1382 <_ZNK6Module16findRfSwitchModeEh+0x1e>
      return row;
    ++row;
    137a:	3d 96       	adiw	r30, 0x0d	; 13
    137c:	f7 cf       	rjmp	.-18     	; 0x136c <_ZNK6Module16findRfSwitchModeEh+0x8>
  }
  return nullptr;
    137e:	f0 e0       	ldi	r31, 0x00	; 0
    1380:	e0 e0       	ldi	r30, 0x00	; 0
}
    1382:	cf 01       	movw	r24, r30
    1384:	08 95       	ret

00001386 <_ZN6Module16setRfSwitchStateEh>:

void Module::setRfSwitchState(uint8_t mode) {
    1386:	cf 92       	push	r12
    1388:	df 92       	push	r13
    138a:	ef 92       	push	r14
    138c:	ff 92       	push	r15
    138e:	0f 93       	push	r16
    1390:	1f 93       	push	r17
    1392:	cf 93       	push	r28
    1394:	df 93       	push	r29
    1396:	6c 01       	movw	r12, r24
  const RfSwitchMode_t *row = findRfSwitchMode(mode);
    1398:	0e 94 b2 09 	call	0x1364	; 0x1364 <_ZNK6Module16findRfSwitchModeEh>
  if(!row) {
    139c:	00 97       	sbiw	r24, 0x00	; 0
    139e:	81 f1       	breq	.+96     	; 0x1400 <_ZN6Module16setRfSwitchStateEh+0x7a>
    // RF switch control is disabled or does not have this mode
    return;
  }

  // set pins
  const uint32_t *value = &row->values[0];
    13a0:	7c 01       	movw	r14, r24
    13a2:	2f ef       	ldi	r18, 0xFF	; 255
    13a4:	e2 1a       	sub	r14, r18
    13a6:	f2 0a       	sbc	r15, r18
  for(size_t i = 0; i < RFSWITCH_MAX_PINS; i++) {
    13a8:	d0 e0       	ldi	r29, 0x00	; 0
    13aa:	c0 e0       	ldi	r28, 0x00	; 0
    13ac:	04 c0       	rjmp	.+8      	; 0x13b6 <_ZN6Module16setRfSwitchStateEh+0x30>
    uint32_t pin = this->rfSwitchPins[i];
    if (pin != RADIOLIB_NC)
      this->hal->digitalWrite(pin, *value);
    ++value;
    13ae:	b4 e0       	ldi	r27, 0x04	; 4
    13b0:	eb 0e       	add	r14, r27
    13b2:	f1 1c       	adc	r15, r1
    return;
  }

  // set pins
  const uint32_t *value = &row->values[0];
  for(size_t i = 0; i < RFSWITCH_MAX_PINS; i++) {
    13b4:	21 96       	adiw	r28, 0x01	; 1
    13b6:	c3 30       	cpi	r28, 0x03	; 3
    13b8:	d1 05       	cpc	r29, r1
    13ba:	10 f5       	brcc	.+68     	; 0x1400 <_ZN6Module16setRfSwitchStateEh+0x7a>
    uint32_t pin = this->rfSwitchPins[i];
    13bc:	fe 01       	movw	r30, r28
    13be:	37 96       	adiw	r30, 0x07	; 7
    13c0:	ee 0f       	add	r30, r30
    13c2:	ff 1f       	adc	r31, r31
    13c4:	ee 0f       	add	r30, r30
    13c6:	ff 1f       	adc	r31, r31
    13c8:	ec 0d       	add	r30, r12
    13ca:	fd 1d       	adc	r31, r13
    13cc:	40 81       	ld	r20, Z
    13ce:	51 81       	ldd	r21, Z+1	; 0x01
    13d0:	62 81       	ldd	r22, Z+2	; 0x02
    13d2:	73 81       	ldd	r23, Z+3	; 0x03
    if (pin != RADIOLIB_NC)
    13d4:	4f 3f       	cpi	r20, 0xFF	; 255
    13d6:	8f ef       	ldi	r24, 0xFF	; 255
    13d8:	58 07       	cpc	r21, r24
    13da:	68 07       	cpc	r22, r24
    13dc:	78 07       	cpc	r23, r24
    13de:	39 f3       	breq	.-50     	; 0x13ae <_ZN6Module16setRfSwitchStateEh+0x28>
      this->hal->digitalWrite(pin, *value);
    13e0:	d6 01       	movw	r26, r12
    13e2:	8d 91       	ld	r24, X+
    13e4:	9c 91       	ld	r25, X
    13e6:	dc 01       	movw	r26, r24
    13e8:	ed 91       	ld	r30, X+
    13ea:	fc 91       	ld	r31, X
    13ec:	02 80       	ldd	r0, Z+2	; 0x02
    13ee:	f3 81       	ldd	r31, Z+3	; 0x03
    13f0:	e0 2d       	mov	r30, r0
    13f2:	d7 01       	movw	r26, r14
    13f4:	0d 91       	ld	r16, X+
    13f6:	1d 91       	ld	r17, X+
    13f8:	2d 91       	ld	r18, X+
    13fa:	3c 91       	ld	r19, X
    13fc:	09 95       	icall
    13fe:	d7 cf       	rjmp	.-82     	; 0x13ae <_ZN6Module16setRfSwitchStateEh+0x28>
    ++value;
  }
}
    1400:	df 91       	pop	r29
    1402:	cf 91       	pop	r28
    1404:	1f 91       	pop	r17
    1406:	0f 91       	pop	r16
    1408:	ff 90       	pop	r15
    140a:	ef 90       	pop	r14
    140c:	df 90       	pop	r13
    140e:	cf 90       	pop	r12
    1410:	08 95       	ret

00001412 <_ZN6Module7reflectEmh>:
    this->hal->yield();
  }
  #endif
}

uint32_t Module::reflect(uint32_t in, uint8_t bits) {
    1412:	cf 92       	push	r12
    1414:	df 92       	push	r13
    1416:	ef 92       	push	r14
    1418:	ff 92       	push	r15
    141a:	0f 93       	push	r16
    141c:	1f 93       	push	r17
    141e:	6b 01       	movw	r12, r22
    1420:	7c 01       	movw	r14, r24
  uint32_t res = 0;
  for(uint8_t i = 0; i < bits; i++) {
    1422:	50 e0       	ldi	r21, 0x00	; 0
  }
  #endif
}

uint32_t Module::reflect(uint32_t in, uint8_t bits) {
  uint32_t res = 0;
    1424:	00 e0       	ldi	r16, 0x00	; 0
    1426:	10 e0       	ldi	r17, 0x00	; 0
    1428:	98 01       	movw	r18, r16
  for(uint8_t i = 0; i < bits; i++) {
    142a:	54 17       	cp	r21, r20
    142c:	58 f5       	brcc	.+86     	; 0x1484 <_ZN6Module7reflectEmh+0x72>
    res |= (((in & ((uint32_t)1 << i)) >> i) << (bits - i - 1));
    142e:	81 e0       	ldi	r24, 0x01	; 1
    1430:	90 e0       	ldi	r25, 0x00	; 0
    1432:	a0 e0       	ldi	r26, 0x00	; 0
    1434:	b0 e0       	ldi	r27, 0x00	; 0
    1436:	05 2e       	mov	r0, r21
    1438:	04 c0       	rjmp	.+8      	; 0x1442 <_ZN6Module7reflectEmh+0x30>
    143a:	88 0f       	add	r24, r24
    143c:	99 1f       	adc	r25, r25
    143e:	aa 1f       	adc	r26, r26
    1440:	bb 1f       	adc	r27, r27
    1442:	0a 94       	dec	r0
    1444:	d2 f7       	brpl	.-12     	; 0x143a <_ZN6Module7reflectEmh+0x28>
    1446:	8c 21       	and	r24, r12
    1448:	9d 21       	and	r25, r13
    144a:	ae 21       	and	r26, r14
    144c:	bf 21       	and	r27, r15
    144e:	05 2e       	mov	r0, r21
    1450:	04 c0       	rjmp	.+8      	; 0x145a <_ZN6Module7reflectEmh+0x48>
    1452:	b6 95       	lsr	r27
    1454:	a7 95       	ror	r26
    1456:	97 95       	ror	r25
    1458:	87 95       	ror	r24
    145a:	0a 94       	dec	r0
    145c:	d2 f7       	brpl	.-12     	; 0x1452 <_ZN6Module7reflectEmh+0x40>
    145e:	e4 2f       	mov	r30, r20
    1460:	e5 1b       	sub	r30, r21
    1462:	ff 0b       	sbc	r31, r31
    1464:	bf 01       	movw	r22, r30
    1466:	61 50       	subi	r22, 0x01	; 1
    1468:	71 09       	sbc	r23, r1
    146a:	04 c0       	rjmp	.+8      	; 0x1474 <_ZN6Module7reflectEmh+0x62>
    146c:	88 0f       	add	r24, r24
    146e:	99 1f       	adc	r25, r25
    1470:	aa 1f       	adc	r26, r26
    1472:	bb 1f       	adc	r27, r27
    1474:	6a 95       	dec	r22
    1476:	d2 f7       	brpl	.-12     	; 0x146c <_ZN6Module7reflectEmh+0x5a>
    1478:	08 2b       	or	r16, r24
    147a:	19 2b       	or	r17, r25
    147c:	2a 2b       	or	r18, r26
    147e:	3b 2b       	or	r19, r27
  #endif
}

uint32_t Module::reflect(uint32_t in, uint8_t bits) {
  uint32_t res = 0;
  for(uint8_t i = 0; i < bits; i++) {
    1480:	5f 5f       	subi	r21, 0xFF	; 255
    1482:	d3 cf       	rjmp	.-90     	; 0x142a <_ZN6Module7reflectEmh+0x18>
    res |= (((in & ((uint32_t)1 << i)) >> i) << (bits - i - 1));
  }
  return(res);
}
    1484:	c9 01       	movw	r24, r18
    1486:	b8 01       	movw	r22, r16
    1488:	1f 91       	pop	r17
    148a:	0f 91       	pop	r16
    148c:	ff 90       	pop	r15
    148e:	ef 90       	pop	r14
    1490:	df 90       	pop	r13
    1492:	cf 90       	pop	r12
    1494:	08 95       	ret

00001496 <_ZN6Module4termEv>:
  RADIOLIB_DEBUG_PRINTLN("Compiled: " __DATE__ " " __TIME__ "\n");
}

void Module::term() {
  // stop hardware interfaces (if they were initialized by the library)
  this->hal->term();
    1496:	dc 01       	movw	r26, r24
    1498:	8d 91       	ld	r24, X+
    149a:	9c 91       	ld	r25, X
    149c:	dc 01       	movw	r26, r24
    149e:	ed 91       	ld	r30, X+
    14a0:	fc 91       	ld	r31, X
    14a2:	00 a0       	ldd	r0, Z+32	; 0x20
    14a4:	f1 a1       	ldd	r31, Z+33	; 0x21
    14a6:	e0 2d       	mov	r30, r0
    14a8:	09 95       	icall
}
    14aa:	08 95       	ret

000014ac <_ZN6Module4initEv>:
  this->rstPin = mod.rstPin;
  this->gpioPin = mod.gpioPin;
  return(*this);
}

void Module::init() {
    14ac:	0f 93       	push	r16
    14ae:	1f 93       	push	r17
    14b0:	cf 93       	push	r28
    14b2:	df 93       	push	r29
    14b4:	ec 01       	movw	r28, r24
  this->hal->init();
    14b6:	88 81       	ld	r24, Y
    14b8:	99 81       	ldd	r25, Y+1	; 0x01
    14ba:	dc 01       	movw	r26, r24
    14bc:	ed 91       	ld	r30, X+
    14be:	fc 91       	ld	r31, X
    14c0:	06 8c       	ldd	r0, Z+30	; 0x1e
    14c2:	f7 8d       	ldd	r31, Z+31	; 0x1f
    14c4:	e0 2d       	mov	r30, r0
    14c6:	09 95       	icall
  this->hal->pinMode(csPin, this->hal->GpioModeOutput);
    14c8:	88 81       	ld	r24, Y
    14ca:	99 81       	ldd	r25, Y+1	; 0x01
    14cc:	dc 01       	movw	r26, r24
    14ce:	ed 91       	ld	r30, X+
    14d0:	fc 91       	ld	r31, X
    14d2:	11 97       	sbiw	r26, 0x01	; 1
    14d4:	01 90       	ld	r0, Z+
    14d6:	f0 81       	ld	r31, Z
    14d8:	e0 2d       	mov	r30, r0
    14da:	16 96       	adiw	r26, 0x06	; 6
    14dc:	0d 91       	ld	r16, X+
    14de:	1d 91       	ld	r17, X+
    14e0:	2d 91       	ld	r18, X+
    14e2:	3c 91       	ld	r19, X
    14e4:	19 97       	sbiw	r26, 0x09	; 9
    14e6:	4c 85       	ldd	r20, Y+12	; 0x0c
    14e8:	5d 85       	ldd	r21, Y+13	; 0x0d
    14ea:	6e 85       	ldd	r22, Y+14	; 0x0e
    14ec:	7f 85       	ldd	r23, Y+15	; 0x0f
    14ee:	09 95       	icall
  this->hal->digitalWrite(csPin, this->hal->GpioLevelHigh);
    14f0:	88 81       	ld	r24, Y
    14f2:	99 81       	ldd	r25, Y+1	; 0x01
    14f4:	dc 01       	movw	r26, r24
    14f6:	ed 91       	ld	r30, X+
    14f8:	fc 91       	ld	r31, X
    14fa:	11 97       	sbiw	r26, 0x01	; 1
    14fc:	02 80       	ldd	r0, Z+2	; 0x02
    14fe:	f3 81       	ldd	r31, Z+3	; 0x03
    1500:	e0 2d       	mov	r30, r0
    1502:	1e 96       	adiw	r26, 0x0e	; 14
    1504:	0d 91       	ld	r16, X+
    1506:	1d 91       	ld	r17, X+
    1508:	2d 91       	ld	r18, X+
    150a:	3c 91       	ld	r19, X
    150c:	51 97       	sbiw	r26, 0x11	; 17
    150e:	4c 85       	ldd	r20, Y+12	; 0x0c
    1510:	5d 85       	ldd	r21, Y+13	; 0x0d
    1512:	6e 85       	ldd	r22, Y+14	; 0x0e
    1514:	7f 85       	ldd	r23, Y+15	; 0x0f
    1516:	09 95       	icall
  RADIOLIB_DEBUG_PRINTLN("\nRadioLib Debug Info");
  RADIOLIB_DEBUG_PRINTLN("Version:  %d.%d.%d.%d", RADIOLIB_VERSION_MAJOR, RADIOLIB_VERSION_MINOR, RADIOLIB_VERSION_PATCH, RADIOLIB_VERSION_EXTRA);
  RADIOLIB_DEBUG_PRINTLN("Platform: " RADIOLIB_PLATFORM);
  RADIOLIB_DEBUG_PRINTLN("Compiled: " __DATE__ " " __TIME__ "\n");
}
    1518:	df 91       	pop	r29
    151a:	cf 91       	pop	r28
    151c:	1f 91       	pop	r17
    151e:	0f 91       	pop	r16
    1520:	08 95       	ret

00001522 <_ZN13PhysicalLayer22clearChannelScanActionEv>:
  (void)func;
}

void PhysicalLayer::clearChannelScanAction() {
  
}
    1522:	08 95       	ret

00001524 <_ZN13PhysicalLayer20setChannelScanActionEPFvvE>:
  
}

void PhysicalLayer::setChannelScanAction(void (*func)(void)) {
  (void)func;
}
    1524:	08 95       	ret

00001526 <_ZN13PhysicalLayer21clearPacketSentActionEv>:
  (void)func;
}

void PhysicalLayer::clearPacketSentAction() {
  
}
    1526:	08 95       	ret

00001528 <_ZN13PhysicalLayer19setPacketSentActionEPFvvE>:
  
}

void PhysicalLayer::setPacketSentAction(void (*func)(void)) {
  (void)func;
}
    1528:	08 95       	ret

0000152a <_ZN13PhysicalLayer25clearPacketReceivedActionEv>:
  (void)func;
}

void PhysicalLayer::clearPacketReceivedAction() {
  
}
    152a:	08 95       	ret

0000152c <_ZN13PhysicalLayer23setPacketReceivedActionEPFvvE>:
  return(RADIOLIB_ERR_UNSUPPORTED);
}

void PhysicalLayer::setPacketReceivedAction(void (*func)(void)) {
  (void)func;
}
    152c:	08 95       	ret

0000152e <_ZN13PhysicalLayer13setDIOMappingEmm>:

int16_t PhysicalLayer::setDIOMapping(uint32_t pin, uint32_t value) {
  (void)pin;
  (void)value;
  return(RADIOLIB_ERR_UNSUPPORTED);
}
    152e:	87 ee       	ldi	r24, 0xE7	; 231
    1530:	9f ef       	ldi	r25, 0xFF	; 255
    1532:	08 95       	ret

00001534 <_ZN13PhysicalLayer7readBitEm>:
  (void)func;
}

void PhysicalLayer::readBit(uint32_t pin) {
  (void)pin;
}
    1534:	08 95       	ret

00001536 <_ZN13PhysicalLayer15setDirectActionEPFvvE>:
  }
}

void PhysicalLayer::setDirectAction(void (*func)(void)) {
  (void)func;
}
    1536:	08 95       	ret

00001538 <_ZN13PhysicalLayer18updateDirectBufferEh>:
  }

  return(RADIOLIB_ERR_NONE);
}

void PhysicalLayer::updateDirectBuffer(uint8_t bit) {
    1538:	ef 92       	push	r14
    153a:	ff 92       	push	r15
    153c:	1f 93       	push	r17
    153e:	cf 93       	push	r28
    1540:	df 93       	push	r29
    1542:	fc 01       	movw	r30, r24
  // check sync word
  if(!this->gotSync) {
    1544:	dc 01       	movw	r26, r24
    1546:	a8 5e       	subi	r26, 0xE8	; 232
    1548:	be 4f       	sbci	r27, 0xFE	; 254
    154a:	8c 91       	ld	r24, X
    154c:	81 11       	cpse	r24, r1
    154e:	2c c0       	rjmp	.+88     	; 0x15a8 <_ZN13PhysicalLayer18updateDirectBufferEh+0x70>
    this->syncBuffer <<= 1;
    1550:	ef 01       	movw	r28, r30
    1552:	c5 5f       	subi	r28, 0xF5	; 245
    1554:	de 4f       	sbci	r29, 0xFE	; 254
    1556:	88 81       	ld	r24, Y
    1558:	99 81       	ldd	r25, Y+1	; 0x01
    155a:	aa 81       	ldd	r26, Y+2	; 0x02
    155c:	bb 81       	ldd	r27, Y+3	; 0x03
    155e:	88 0f       	add	r24, r24
    1560:	99 1f       	adc	r25, r25
    1562:	aa 1f       	adc	r26, r26
    1564:	bb 1f       	adc	r27, r27
    this->syncBuffer |= bit;
    1566:	86 2b       	or	r24, r22
    1568:	88 83       	st	Y, r24
    156a:	99 83       	std	Y+1, r25	; 0x01
    156c:	aa 83       	std	Y+2, r26	; 0x02
    156e:	bb 83       	std	Y+3, r27	; 0x03

    RADIOLIB_VERBOSE_PRINTLN("S\t%lu", this->syncBuffer);

    if((this->syncBuffer & this->directSyncWordMask) == this->directSyncWord) {
    1570:	29 96       	adiw	r28, 0x09	; 9
    1572:	48 81       	ld	r20, Y
    1574:	59 81       	ldd	r21, Y+1	; 0x01
    1576:	6a 81       	ldd	r22, Y+2	; 0x02
    1578:	7b 81       	ldd	r23, Y+3	; 0x03
    157a:	84 23       	and	r24, r20
    157c:	95 23       	and	r25, r21
    157e:	a6 23       	and	r26, r22
    1580:	b7 23       	and	r27, r23
    1582:	25 97       	sbiw	r28, 0x05	; 5
    1584:	48 81       	ld	r20, Y
    1586:	59 81       	ldd	r21, Y+1	; 0x01
    1588:	6a 81       	ldd	r22, Y+2	; 0x02
    158a:	7b 81       	ldd	r23, Y+3	; 0x03
    158c:	84 17       	cp	r24, r20
    158e:	95 07       	cpc	r25, r21
    1590:	a6 07       	cpc	r26, r22
    1592:	b7 07       	cpc	r27, r23
    1594:	19 f5       	brne	.+70     	; 0x15dc <_ZN13PhysicalLayer18updateDirectBufferEh+0xa4>
      this->gotSync = true;
    1596:	df 01       	movw	r26, r30
    1598:	a8 5e       	subi	r26, 0xE8	; 232
    159a:	be 4f       	sbci	r27, 0xFE	; 254
    159c:	81 e0       	ldi	r24, 0x01	; 1
    159e:	8c 93       	st	X, r24
      this->bufferWritePos = 0;
    15a0:	11 86       	std	Z+9, r1	; 0x09
      this->bufferReadPos = 0;
    15a2:	12 86       	std	Z+10, r1	; 0x0a
      this->bufferBitPos = 0;
    15a4:	10 86       	std	Z+8, r1	; 0x08
    15a6:	1a c0       	rjmp	.+52     	; 0x15dc <_ZN13PhysicalLayer18updateDirectBufferEh+0xa4>
    }

  } else {
    // save the bit
    if(bit) {
    15a8:	66 23       	and	r22, r22
    15aa:	f1 f0       	breq	.+60     	; 0x15e8 <_ZN13PhysicalLayer18updateDirectBufferEh+0xb0>
      this->buffer[this->bufferWritePos] |= 0x01 << this->bufferBitPos;
    15ac:	a1 85       	ldd	r26, Z+9	; 0x09
    15ae:	20 85       	ldd	r18, Z+8	; 0x08
    15b0:	81 e0       	ldi	r24, 0x01	; 1
    15b2:	90 e0       	ldi	r25, 0x00	; 0
    15b4:	ac 01       	movw	r20, r24
    15b6:	02 c0       	rjmp	.+4      	; 0x15bc <_ZN13PhysicalLayer18updateDirectBufferEh+0x84>
    15b8:	44 0f       	add	r20, r20
    15ba:	55 1f       	adc	r21, r21
    15bc:	2a 95       	dec	r18
    15be:	e2 f7       	brpl	.-8      	; 0x15b8 <_ZN13PhysicalLayer18updateDirectBufferEh+0x80>
    15c0:	ae 0f       	add	r26, r30
    15c2:	bf 2f       	mov	r27, r31
    15c4:	b1 1d       	adc	r27, r1
    15c6:	1b 96       	adiw	r26, 0x0b	; 11
    15c8:	8c 91       	ld	r24, X
    15ca:	1b 97       	sbiw	r26, 0x0b	; 11
    15cc:	84 2b       	or	r24, r20
    15ce:	1b 96       	adiw	r26, 0x0b	; 11
    15d0:	8c 93       	st	X, r24
    } else {
      this->buffer[this->bufferWritePos] &= ~(0x01 << this->bufferBitPos);
    }
    this->bufferBitPos++;
    15d2:	80 85       	ldd	r24, Z+8	; 0x08
    15d4:	8f 5f       	subi	r24, 0xFF	; 255
    15d6:	80 87       	std	Z+8, r24	; 0x08

    // check complete byte
    if(this->bufferBitPos == 8) {
    15d8:	88 30       	cpi	r24, 0x08	; 8
    15da:	d1 f0       	breq	.+52     	; 0x1610 <_ZN13PhysicalLayer18updateDirectBufferEh+0xd8>

      this->bufferWritePos++;
      this->bufferBitPos = 0;
    }
  }
}
    15dc:	df 91       	pop	r29
    15de:	cf 91       	pop	r28
    15e0:	1f 91       	pop	r17
    15e2:	ff 90       	pop	r15
    15e4:	ef 90       	pop	r14
    15e6:	08 95       	ret
  } else {
    // save the bit
    if(bit) {
      this->buffer[this->bufferWritePos] |= 0x01 << this->bufferBitPos;
    } else {
      this->buffer[this->bufferWritePos] &= ~(0x01 << this->bufferBitPos);
    15e8:	a1 85       	ldd	r26, Z+9	; 0x09
    15ea:	20 85       	ldd	r18, Z+8	; 0x08
    15ec:	81 e0       	ldi	r24, 0x01	; 1
    15ee:	90 e0       	ldi	r25, 0x00	; 0
    15f0:	02 c0       	rjmp	.+4      	; 0x15f6 <_ZN13PhysicalLayer18updateDirectBufferEh+0xbe>
    15f2:	88 0f       	add	r24, r24
    15f4:	99 1f       	adc	r25, r25
    15f6:	2a 95       	dec	r18
    15f8:	e2 f7       	brpl	.-8      	; 0x15f2 <_ZN13PhysicalLayer18updateDirectBufferEh+0xba>
    15fa:	ae 0f       	add	r26, r30
    15fc:	bf 2f       	mov	r27, r31
    15fe:	b1 1d       	adc	r27, r1
    1600:	80 95       	com	r24
    1602:	1b 96       	adiw	r26, 0x0b	; 11
    1604:	9c 91       	ld	r25, X
    1606:	1b 97       	sbiw	r26, 0x0b	; 11
    1608:	89 23       	and	r24, r25
    160a:	1b 96       	adiw	r26, 0x0b	; 11
    160c:	8c 93       	st	X, r24
    160e:	e1 cf       	rjmp	.-62     	; 0x15d2 <_ZN13PhysicalLayer18updateDirectBufferEh+0x9a>
    1610:	ef 01       	movw	r28, r30
    }
    this->bufferBitPos++;

    // check complete byte
    if(this->bufferBitPos == 8) {
      this->buffer[this->bufferWritePos] = Module::reflect(this->buffer[this->bufferWritePos], 8);
    1612:	11 85       	ldd	r17, Z+9	; 0x09
    1614:	7f 01       	movw	r14, r30
    1616:	e1 0e       	add	r14, r17
    1618:	f1 1c       	adc	r15, r1
    161a:	f7 01       	movw	r30, r14
    161c:	63 85       	ldd	r22, Z+11	; 0x0b
    161e:	70 e0       	ldi	r23, 0x00	; 0
    1620:	90 e0       	ldi	r25, 0x00	; 0
    1622:	80 e0       	ldi	r24, 0x00	; 0
    1624:	48 e0       	ldi	r20, 0x08	; 8
    1626:	0e 94 09 0a 	call	0x1412	; 0x1412 <_ZN6Module7reflectEmh>
    162a:	f7 01       	movw	r30, r14
    162c:	63 87       	std	Z+11, r22	; 0x0b
      RADIOLIB_VERBOSE_PRINTLN("R\t%X", this->buffer[this->bufferWritePos]);

      this->bufferWritePos++;
    162e:	1f 5f       	subi	r17, 0xFF	; 255
    1630:	19 87       	std	Y+9, r17	; 0x09
      this->bufferBitPos = 0;
    1632:	18 86       	std	Y+8, r1	; 0x08
    1634:	d3 cf       	rjmp	.-90     	; 0x15dc <_ZN13PhysicalLayer18updateDirectBufferEh+0xa4>

00001636 <_ZN13PhysicalLayer10randomByteEv>:
  return(PhysicalLayer::random(max - min) + min);
}

uint8_t PhysicalLayer::randomByte() {
  return(0);
}
    1636:	80 e0       	ldi	r24, 0x00	; 0
    1638:	08 95       	ret

0000163a <_ZN13PhysicalLayer11scanChannelEv>:
  return(RADIOLIB_ERR_UNSUPPORTED);
}

int16_t PhysicalLayer::scanChannel() {
  return(RADIOLIB_ERR_UNSUPPORTED); 
}
    163a:	87 ee       	ldi	r24, 0xE7	; 231
    163c:	9f ef       	ldi	r25, 0xFF	; 255
    163e:	08 95       	ret

00001640 <_ZN13PhysicalLayer20getChannelScanResultEv>:
  return(RADIOLIB_ERR_UNSUPPORTED); 
}

int16_t PhysicalLayer::getChannelScanResult() {
  return(RADIOLIB_ERR_UNSUPPORTED);
}
    1640:	87 ee       	ldi	r24, 0xE7	; 231
    1642:	9f ef       	ldi	r25, 0xFF	; 255
    1644:	08 95       	ret

00001646 <_ZN13PhysicalLayer16startChannelScanEv>:
  return(0);
}
    
int16_t PhysicalLayer::startChannelScan() {
  return(RADIOLIB_ERR_UNSUPPORTED); 
}
    1646:	87 ee       	ldi	r24, 0xE7	; 231
    1648:	9f ef       	ldi	r25, 0xFF	; 255
    164a:	08 95       	ret

0000164c <_ZN13PhysicalLayer12getTimeOnAirEj>:
}

uint32_t PhysicalLayer::getTimeOnAir(size_t len) {
  (void)len;
  return(0);
}
    164c:	60 e0       	ldi	r22, 0x00	; 0
    164e:	70 e0       	ldi	r23, 0x00	; 0
    1650:	cb 01       	movw	r24, r22
    1652:	08 95       	ret

00001654 <_ZN13PhysicalLayer6getSNREv>:
  return(RADIOLIB_ERR_UNSUPPORTED);
}

float PhysicalLayer::getSNR() {
  return(RADIOLIB_ERR_UNSUPPORTED);
}
    1654:	60 e0       	ldi	r22, 0x00	; 0
    1656:	70 e0       	ldi	r23, 0x00	; 0
    1658:	88 ec       	ldi	r24, 0xC8	; 200
    165a:	91 ec       	ldi	r25, 0xC1	; 193
    165c:	08 95       	ret

0000165e <_ZN13PhysicalLayer7getRSSIEv>:
  return(0);
}

float PhysicalLayer::getRSSI() {
  return(RADIOLIB_ERR_UNSUPPORTED);
}
    165e:	60 e0       	ldi	r22, 0x00	; 0
    1660:	70 e0       	ldi	r23, 0x00	; 0
    1662:	88 ec       	ldi	r24, 0xC8	; 200
    1664:	91 ec       	ldi	r25, 0xC1	; 193
    1666:	08 95       	ret

00001668 <_ZN13PhysicalLayer15getPacketLengthEb>:
}

size_t PhysicalLayer::getPacketLength(bool update) {
  (void)update;
  return(0);
}
    1668:	90 e0       	ldi	r25, 0x00	; 0
    166a:	80 e0       	ldi	r24, 0x00	; 0
    166c:	08 95       	ret

0000166e <_ZN13PhysicalLayer11setDataRateE10DataRate_t>:
int16_t PhysicalLayer::setPreambleLength(size_t len) {
  (void)len;
  return(RADIOLIB_ERR_UNSUPPORTED);
}

int16_t PhysicalLayer::setDataRate(DataRate_t dr) {
    166e:	0f 93       	push	r16
    1670:	1f 93       	push	r17
    1672:	cf 93       	push	r28
    1674:	df 93       	push	r29
    1676:	cd b7       	in	r28, 0x3d	; 61
    1678:	de b7       	in	r29, 0x3e	; 62
    167a:	28 97       	sbiw	r28, 0x08	; 8
    167c:	0f b6       	in	r0, 0x3f	; 63
    167e:	f8 94       	cli
    1680:	de bf       	out	0x3e, r29	; 62
    1682:	0f be       	out	0x3f, r0	; 63
    1684:	cd bf       	out	0x3d, r28	; 61
  (void)dr;
  return(RADIOLIB_ERR_UNSUPPORTED);
}
    1686:	87 ee       	ldi	r24, 0xE7	; 231
    1688:	9f ef       	ldi	r25, 0xFF	; 255
    168a:	28 96       	adiw	r28, 0x08	; 8
    168c:	0f b6       	in	r0, 0x3f	; 63
    168e:	f8 94       	cli
    1690:	de bf       	out	0x3e, r29	; 62
    1692:	0f be       	out	0x3f, r0	; 63
    1694:	cd bf       	out	0x3d, r28	; 61
    1696:	df 91       	pop	r29
    1698:	cf 91       	pop	r28
    169a:	1f 91       	pop	r17
    169c:	0f 91       	pop	r16
    169e:	08 95       	ret

000016a0 <_ZN13PhysicalLayer17setPreambleLengthEj>:
}

int16_t PhysicalLayer::setPreambleLength(size_t len) {
  (void)len;
  return(RADIOLIB_ERR_UNSUPPORTED);
}
    16a0:	87 ee       	ldi	r24, 0xE7	; 231
    16a2:	9f ef       	ldi	r25, 0xFF	; 255
    16a4:	08 95       	ret

000016a6 <_ZN13PhysicalLayer11setSyncWordEPhj>:

int16_t PhysicalLayer::setSyncWord(uint8_t* sync, size_t len) {
  (void)sync;
  (void)len;
  return(RADIOLIB_ERR_UNSUPPORTED);
}
    16a6:	87 ee       	ldi	r24, 0xE7	; 231
    16a8:	9f ef       	ldi	r25, 0xFF	; 255
    16aa:	08 95       	ret

000016ac <_ZN13PhysicalLayer14setOutputPowerEa>:
}

int16_t PhysicalLayer::setOutputPower(int8_t power) {
  (void)power;
  return(RADIOLIB_ERR_UNSUPPORTED);
}
    16ac:	87 ee       	ldi	r24, 0xE7	; 231
    16ae:	9f ef       	ldi	r25, 0xFF	; 255
    16b0:	08 95       	ret

000016b2 <_ZN13PhysicalLayer8invertIQEb>:
}

int16_t PhysicalLayer::invertIQ(bool enable) {
  (void)enable;
  return(RADIOLIB_ERR_UNSUPPORTED);
}
    16b2:	87 ee       	ldi	r24, 0xE7	; 231
    16b4:	9f ef       	ldi	r25, 0xFF	; 255
    16b6:	08 95       	ret

000016b8 <_ZN13PhysicalLayer11setEncodingEh>:
}

int16_t PhysicalLayer::setEncoding(uint8_t encoding) {
  (void)encoding;
  return(RADIOLIB_ERR_UNSUPPORTED);
}
    16b8:	87 ee       	ldi	r24, 0xE7	; 231
    16ba:	9f ef       	ldi	r25, 0xFF	; 255
    16bc:	08 95       	ret

000016be <_ZN13PhysicalLayer14setDataShapingEh>:
}

int16_t PhysicalLayer::setDataShaping(uint8_t sh) {
  (void)sh;
  return(RADIOLIB_ERR_UNSUPPORTED);
}
    16be:	87 ee       	ldi	r24, 0xE7	; 231
    16c0:	9f ef       	ldi	r25, 0xFF	; 255
    16c2:	08 95       	ret

000016c4 <_ZN13PhysicalLayer21setFrequencyDeviationEf>:
}

int16_t PhysicalLayer::setFrequencyDeviation(float freqDev) {
  (void)freqDev;
  return(RADIOLIB_ERR_UNSUPPORTED);
}
    16c4:	87 ee       	ldi	r24, 0xE7	; 231
    16c6:	9f ef       	ldi	r25, 0xFF	; 255
    16c8:	08 95       	ret

000016ca <_ZN13PhysicalLayer10setBitRateEf>:
}

int16_t PhysicalLayer::setBitRate(float br) {
  (void)br;
  return(RADIOLIB_ERR_UNSUPPORTED);
}
    16ca:	87 ee       	ldi	r24, 0xE7	; 231
    16cc:	9f ef       	ldi	r25, 0xFF	; 255
    16ce:	08 95       	ret

000016d0 <_ZN13PhysicalLayer12setFrequencyEf>:
}

int16_t PhysicalLayer::setFrequency(float freq) {
  (void)freq;
  return(RADIOLIB_ERR_UNSUPPORTED);
}
    16d0:	87 ee       	ldi	r24, 0xE7	; 231
    16d2:	9f ef       	ldi	r25, 0xFF	; 255
    16d4:	08 95       	ret

000016d6 <_ZN13PhysicalLayer13receiveDirectEv>:
  return(RADIOLIB_ERR_UNSUPPORTED);
}

int16_t PhysicalLayer::receiveDirect() {
  return(RADIOLIB_ERR_UNSUPPORTED);
}
    16d6:	87 ee       	ldi	r24, 0xE7	; 231
    16d8:	9f ef       	ldi	r25, 0xFF	; 255
    16da:	08 95       	ret

000016dc <_ZN13PhysicalLayer14transmitDirectEm>:
}

int16_t PhysicalLayer::transmitDirect(uint32_t frf) {
  (void)frf;
  return(RADIOLIB_ERR_UNSUPPORTED);
}
    16dc:	87 ee       	ldi	r24, 0xE7	; 231
    16de:	9f ef       	ldi	r25, 0xFF	; 255
    16e0:	08 95       	ret

000016e2 <_ZN13PhysicalLayer8readDataEPhj>:

int16_t PhysicalLayer::readData(uint8_t* data, size_t len) {
  (void)data;
  (void)len;
  return(RADIOLIB_ERR_UNSUPPORTED);
}
    16e2:	87 ee       	ldi	r24, 0xE7	; 231
    16e4:	9f ef       	ldi	r25, 0xFF	; 255
    16e6:	08 95       	ret

000016e8 <_ZN13PhysicalLayer14finishTransmitEv>:
  return(RADIOLIB_ERR_UNSUPPORTED);
}

int16_t PhysicalLayer::finishTransmit() {
  return(RADIOLIB_ERR_UNSUPPORTED);
}
    16e8:	87 ee       	ldi	r24, 0xE7	; 231
    16ea:	9f ef       	ldi	r25, 0xFF	; 255
    16ec:	08 95       	ret

000016ee <_ZN13PhysicalLayer13startTransmitEPhjh>:
int16_t PhysicalLayer::startTransmit(uint8_t* data, size_t len, uint8_t addr) {
  (void)data;
  (void)len;
  (void)addr;
  return(RADIOLIB_ERR_UNSUPPORTED);
}
    16ee:	87 ee       	ldi	r24, 0xE7	; 231
    16f0:	9f ef       	ldi	r25, 0xFF	; 255
    16f2:	08 95       	ret

000016f4 <_ZN13PhysicalLayer12startReceiveEmjjj>:
  (void)timeout;
  (void)irqFlags;
  (void)irqMask;
  (void)len;
  return(RADIOLIB_ERR_UNSUPPORTED);
}
    16f4:	87 ee       	ldi	r24, 0xE7	; 231
    16f6:	9f ef       	ldi	r25, 0xFF	; 255
    16f8:	08 95       	ret

000016fa <_ZN13PhysicalLayer12startReceiveEv>:
  return(RADIOLIB_ERR_UNSUPPORTED);
}

int16_t PhysicalLayer::startReceive() {
  return(RADIOLIB_ERR_UNSUPPORTED);
}
    16fa:	87 ee       	ldi	r24, 0xE7	; 231
    16fc:	9f ef       	ldi	r25, 0xFF	; 255
    16fe:	08 95       	ret

00001700 <_ZN13PhysicalLayer7standbyEh>:
}

int16_t PhysicalLayer::standby(uint8_t mode) {
  (void)mode;
  return(RADIOLIB_ERR_UNSUPPORTED);
}
    1700:	87 ee       	ldi	r24, 0xE7	; 231
    1702:	9f ef       	ldi	r25, 0xFF	; 255
    1704:	08 95       	ret

00001706 <_ZN13PhysicalLayer7standbyEv>:
int16_t PhysicalLayer::sleep() {
  return(RADIOLIB_ERR_UNSUPPORTED);
}

int16_t PhysicalLayer::standby() {
  return(standby(RADIOLIB_STANDBY_DEFAULT));
    1706:	dc 01       	movw	r26, r24
    1708:	ed 91       	ld	r30, X+
    170a:	fc 91       	ld	r31, X
    170c:	06 80       	ldd	r0, Z+6	; 0x06
    170e:	f7 81       	ldd	r31, Z+7	; 0x07
    1710:	e0 2d       	mov	r30, r0
    1712:	60 e0       	ldi	r22, 0x00	; 0
    1714:	09 95       	icall
}
    1716:	08 95       	ret

00001718 <_ZN13PhysicalLayer5sleepEv>:
  return(RADIOLIB_ERR_UNSUPPORTED);
}

int16_t PhysicalLayer::sleep() {
  return(RADIOLIB_ERR_UNSUPPORTED);
}
    1718:	87 ee       	ldi	r24, 0xE7	; 231
    171a:	9f ef       	ldi	r25, 0xFF	; 255
    171c:	08 95       	ret

0000171e <_ZN13PhysicalLayer7receiveEPhj>:

int16_t PhysicalLayer::receive(uint8_t* data, size_t len) {
  (void)data;
  (void)len;
  return(RADIOLIB_ERR_UNSUPPORTED);
}
    171e:	87 ee       	ldi	r24, 0xE7	; 231
    1720:	9f ef       	ldi	r25, 0xFF	; 255
    1722:	08 95       	ret

00001724 <_ZN13PhysicalLayer8transmitEPhjh>:
int16_t PhysicalLayer::transmit(uint8_t* data, size_t len, uint8_t addr) {
  (void)data;
  (void)len;
  (void)addr;
  return(RADIOLIB_ERR_UNSUPPORTED);
}
    1724:	87 ee       	ldi	r24, 0xE7	; 231
    1726:	9f ef       	ldi	r25, 0xFF	; 255
    1728:	08 95       	ret

0000172a <_ZN13PhysicalLayerC2Efj>:
#include "PhysicalLayer.h"
#include <string.h>

PhysicalLayer::PhysicalLayer(float step, size_t maxLen) {
    172a:	fc 01       	movw	r30, r24
    172c:	84 ed       	ldi	r24, 0xD4	; 212
    172e:	91 e0       	ldi	r25, 0x01	; 1
    1730:	91 83       	std	Z+1, r25	; 0x01
    1732:	80 83       	st	Z, r24
  this->freqStep = step;
    1734:	42 83       	std	Z+2, r20	; 0x02
    1736:	53 83       	std	Z+3, r21	; 0x03
    1738:	64 83       	std	Z+4, r22	; 0x04
    173a:	75 83       	std	Z+5, r23	; 0x05
  this->maxPacketLength = maxLen;
    173c:	37 83       	std	Z+7, r19	; 0x07
    173e:	26 83       	std	Z+6, r18	; 0x06
  #if !defined(RADIOLIB_EXCLUDE_DIRECT_RECEIVE)
  this->bufferBitPos = 0;
    1740:	10 86       	std	Z+8, r1	; 0x08
  this->bufferWritePos = 0;
    1742:	11 86       	std	Z+9, r1	; 0x09
  #endif
}
    1744:	08 95       	ret

00001746 <_ZN6SX127x7readBitEm>:
#if !defined(RADIOLIB_EXCLUDE_DIRECT_RECEIVE)
void SX127x::setDirectAction(void (*func)(void)) {
  setDio1Action(func, this->mod->hal->GpioInterruptRising);
}

void SX127x::readBit(uint32_t pin) {
    1746:	cf 93       	push	r28
    1748:	df 93       	push	r29
    174a:	ec 01       	movw	r28, r24
  updateDirectBuffer((uint8_t)this->mod->hal->digitalRead(pin));
    174c:	fc 01       	movw	r30, r24
    174e:	e7 5e       	subi	r30, 0xE7	; 231
    1750:	fe 4f       	sbci	r31, 0xFE	; 254
    1752:	01 90       	ld	r0, Z+
    1754:	f0 81       	ld	r31, Z
    1756:	e0 2d       	mov	r30, r0
    1758:	80 81       	ld	r24, Z
    175a:	91 81       	ldd	r25, Z+1	; 0x01
    175c:	dc 01       	movw	r26, r24
    175e:	ed 91       	ld	r30, X+
    1760:	fc 91       	ld	r31, X
    1762:	04 80       	ldd	r0, Z+4	; 0x04
    1764:	f5 81       	ldd	r31, Z+5	; 0x05
    1766:	e0 2d       	mov	r30, r0
    1768:	09 95       	icall
    176a:	ce 01       	movw	r24, r28
    176c:	0e 94 9c 0a 	call	0x1538	; 0x1538 <_ZN13PhysicalLayer18updateDirectBufferEh>
}
    1770:	df 91       	pop	r29
    1772:	cf 91       	pop	r28
    1774:	08 95       	ret

00001776 <_ZN6SX127x13setDio1ActionEPFvvEm>:

void SX127x::clearDio0Action() {
  this->mod->hal->detachInterrupt(this->mod->hal->pinToInterrupt(this->mod->getIrq()));
}

void SX127x::setDio1Action(void (*func)(void), uint32_t dir) {
    1776:	4f 92       	push	r4
    1778:	5f 92       	push	r5
    177a:	6f 92       	push	r6
    177c:	7f 92       	push	r7
    177e:	af 92       	push	r10
    1780:	bf 92       	push	r11
    1782:	cf 92       	push	r12
    1784:	df 92       	push	r13
    1786:	ef 92       	push	r14
    1788:	ff 92       	push	r15
    178a:	0f 93       	push	r16
    178c:	1f 93       	push	r17
    178e:	cf 93       	push	r28
    1790:	df 93       	push	r29
    1792:	eb 01       	movw	r28, r22
    1794:	29 01       	movw	r4, r18
    1796:	3a 01       	movw	r6, r20
  if(this->mod->getGpio() == RADIOLIB_NC) {
    1798:	87 5e       	subi	r24, 0xE7	; 231
    179a:	9e 4f       	sbci	r25, 0xFE	; 254
    179c:	dc 01       	movw	r26, r24
    179e:	ed 91       	ld	r30, X+
    17a0:	fc 91       	ld	r31, X

    /*!
      \brief Access method to get the pin number of second interrupt/GPIO.
      \returns Pin number of second interrupt/GPIO configured in the constructor.
    */
    uint32_t getGpio() const { return(gpioPin); }
    17a2:	40 8d       	ldd	r20, Z+24	; 0x18
    17a4:	51 8d       	ldd	r21, Z+25	; 0x19
    17a6:	62 8d       	ldd	r22, Z+26	; 0x1a
    17a8:	73 8d       	ldd	r23, Z+27	; 0x1b
    17aa:	4f 3f       	cpi	r20, 0xFF	; 255
    17ac:	bf ef       	ldi	r27, 0xFF	; 255
    17ae:	5b 07       	cpc	r21, r27
    17b0:	6b 07       	cpc	r22, r27
    17b2:	7b 07       	cpc	r23, r27
    17b4:	a1 f0       	breq	.+40     	; 0x17de <_ZN6SX127x13setDio1ActionEPFvvEm+0x68>
    return;
  }
  this->mod->hal->attachInterrupt(this->mod->hal->pinToInterrupt(this->mod->getGpio()), func, dir);
    17b6:	c0 80       	ld	r12, Z
    17b8:	d1 80       	ldd	r13, Z+1	; 0x01
    17ba:	d6 01       	movw	r26, r12
    17bc:	ed 91       	ld	r30, X+
    17be:	fc 91       	ld	r31, X
    17c0:	a6 80       	ldd	r10, Z+6	; 0x06
    17c2:	b7 80       	ldd	r11, Z+7	; 0x07
    17c4:	00 a4       	ldd	r0, Z+40	; 0x28
    17c6:	f1 a5       	ldd	r31, Z+41	; 0x29
    17c8:	e0 2d       	mov	r30, r0
    17ca:	c6 01       	movw	r24, r12
    17cc:	09 95       	icall
    17ce:	ab 01       	movw	r20, r22
    17d0:	bc 01       	movw	r22, r24
    17d2:	83 01       	movw	r16, r6
    17d4:	72 01       	movw	r14, r4
    17d6:	9e 01       	movw	r18, r28
    17d8:	c6 01       	movw	r24, r12
    17da:	f5 01       	movw	r30, r10
    17dc:	09 95       	icall
}
    17de:	df 91       	pop	r29
    17e0:	cf 91       	pop	r28
    17e2:	1f 91       	pop	r17
    17e4:	0f 91       	pop	r16
    17e6:	ff 90       	pop	r15
    17e8:	ef 90       	pop	r14
    17ea:	df 90       	pop	r13
    17ec:	cf 90       	pop	r12
    17ee:	bf 90       	pop	r11
    17f0:	af 90       	pop	r10
    17f2:	7f 90       	pop	r7
    17f4:	6f 90       	pop	r6
    17f6:	5f 90       	pop	r5
    17f8:	4f 90       	pop	r4
    17fa:	08 95       	ret

000017fc <_ZN6SX127x15setDirectActionEPFvvE>:
  return(state);
}

#if !defined(RADIOLIB_EXCLUDE_DIRECT_RECEIVE)
void SX127x::setDirectAction(void (*func)(void)) {
  setDio1Action(func, this->mod->hal->GpioInterruptRising);
    17fc:	fc 01       	movw	r30, r24
    17fe:	e7 5e       	subi	r30, 0xE7	; 231
    1800:	fe 4f       	sbci	r31, 0xFE	; 254
    1802:	01 90       	ld	r0, Z+
    1804:	f0 81       	ld	r31, Z
    1806:	e0 2d       	mov	r30, r0
    1808:	01 90       	ld	r0, Z+
    180a:	f0 81       	ld	r31, Z
    180c:	e0 2d       	mov	r30, r0
    180e:	22 89       	ldd	r18, Z+18	; 0x12
    1810:	33 89       	ldd	r19, Z+19	; 0x13
    1812:	44 89       	ldd	r20, Z+20	; 0x14
    1814:	55 89       	ldd	r21, Z+21	; 0x15
    1816:	0e 94 bb 0b 	call	0x1776	; 0x1776 <_ZN6SX127x13setDio1ActionEPFvvEm>
}
    181a:	08 95       	ret

0000181c <_ZN6SX127x15clearDio0ActionEv>:

void SX127x::setDio0Action(void (*func)(void), uint32_t dir) {
  this->mod->hal->attachInterrupt(this->mod->hal->pinToInterrupt(this->mod->getIrq()), func, dir);
}

void SX127x::clearDio0Action() {
    181c:	0f 93       	push	r16
    181e:	1f 93       	push	r17
    1820:	cf 93       	push	r28
    1822:	df 93       	push	r29
  this->mod->hal->detachInterrupt(this->mod->hal->pinToInterrupt(this->mod->getIrq()));
    1824:	87 5e       	subi	r24, 0xE7	; 231
    1826:	9e 4f       	sbci	r25, 0xFE	; 254
    1828:	fc 01       	movw	r30, r24
    182a:	a0 81       	ld	r26, Z
    182c:	b1 81       	ldd	r27, Z+1	; 0x01
    182e:	cd 91       	ld	r28, X+
    1830:	dc 91       	ld	r29, X
    1832:	11 97       	sbiw	r26, 0x01	; 1
    1834:	e8 81       	ld	r30, Y
    1836:	f9 81       	ldd	r31, Y+1	; 0x01
    1838:	00 85       	ldd	r16, Z+8	; 0x08
    183a:	11 85       	ldd	r17, Z+9	; 0x09
    183c:	00 a4       	ldd	r0, Z+40	; 0x28
    183e:	f1 a5       	ldd	r31, Z+41	; 0x29
    1840:	e0 2d       	mov	r30, r0

    /*!
      \brief Access method to get the pin number of interrupt/GPIO.
      \returns Pin number of interrupt/GPIO configured in the constructor.
    */
    uint32_t getIrq() const { return(irqPin); }
    1842:	50 96       	adiw	r26, 0x10	; 16
    1844:	4d 91       	ld	r20, X+
    1846:	5d 91       	ld	r21, X+
    1848:	6d 91       	ld	r22, X+
    184a:	7c 91       	ld	r23, X
    184c:	53 97       	sbiw	r26, 0x13	; 19
    184e:	ce 01       	movw	r24, r28
    1850:	09 95       	icall
    1852:	ab 01       	movw	r20, r22
    1854:	bc 01       	movw	r22, r24
    1856:	ce 01       	movw	r24, r28
    1858:	f8 01       	movw	r30, r16
    185a:	09 95       	icall
}
    185c:	df 91       	pop	r29
    185e:	cf 91       	pop	r28
    1860:	1f 91       	pop	r17
    1862:	0f 91       	pop	r16
    1864:	08 95       	ret

00001866 <_ZN6SX127x22clearChannelScanActionEv>:
void SX127x::setChannelScanAction(void (*func)(void)) {
  this->setDio0Action(func, this->mod->hal->GpioInterruptRising);
}

void SX127x::clearChannelScanAction() {
  this->clearDio0Action();
    1866:	0e 94 0e 0c 	call	0x181c	; 0x181c <_ZN6SX127x15clearDio0ActionEv>
}
    186a:	08 95       	ret

0000186c <_ZN6SX127x21clearPacketSentActionEv>:
void SX127x::setPacketSentAction(void (*func)(void)) {
  this->setDio0Action(func, this->mod->hal->GpioInterruptRising);
}

void SX127x::clearPacketSentAction() {
  this->clearDio0Action();
    186c:	0e 94 0e 0c 	call	0x181c	; 0x181c <_ZN6SX127x15clearDio0ActionEv>
}
    1870:	08 95       	ret

00001872 <_ZN6SX127x25clearPacketReceivedActionEv>:
void SX127x::setPacketReceivedAction(void (*func)(void)) {
  this->setDio0Action(func, this->mod->hal->GpioInterruptRising);
}

void SX127x::clearPacketReceivedAction() {
  this->clearDio0Action();
    1872:	0e 94 0e 0c 	call	0x181c	; 0x181c <_ZN6SX127x15clearDio0ActionEv>
}
    1876:	08 95       	ret

00001878 <_ZN6SX127x13setDio0ActionEPFvvEm>:
  (void)irqFlags;
  (void)irqMask;
  return(startReceive((uint8_t)len, (uint8_t)mode));
}

void SX127x::setDio0Action(void (*func)(void), uint32_t dir) {
    1878:	4f 92       	push	r4
    187a:	5f 92       	push	r5
    187c:	6f 92       	push	r6
    187e:	7f 92       	push	r7
    1880:	af 92       	push	r10
    1882:	bf 92       	push	r11
    1884:	cf 92       	push	r12
    1886:	df 92       	push	r13
    1888:	ef 92       	push	r14
    188a:	ff 92       	push	r15
    188c:	0f 93       	push	r16
    188e:	1f 93       	push	r17
    1890:	cf 93       	push	r28
    1892:	df 93       	push	r29
    1894:	5b 01       	movw	r10, r22
    1896:	29 01       	movw	r4, r18
    1898:	3a 01       	movw	r6, r20
  this->mod->hal->attachInterrupt(this->mod->hal->pinToInterrupt(this->mod->getIrq()), func, dir);
    189a:	87 5e       	subi	r24, 0xE7	; 231
    189c:	9e 4f       	sbci	r25, 0xFE	; 254
    189e:	fc 01       	movw	r30, r24
    18a0:	a0 81       	ld	r26, Z
    18a2:	b1 81       	ldd	r27, Z+1	; 0x01
    18a4:	cd 91       	ld	r28, X+
    18a6:	dc 91       	ld	r29, X
    18a8:	11 97       	sbiw	r26, 0x01	; 1
    18aa:	e8 81       	ld	r30, Y
    18ac:	f9 81       	ldd	r31, Y+1	; 0x01
    18ae:	c6 80       	ldd	r12, Z+6	; 0x06
    18b0:	d7 80       	ldd	r13, Z+7	; 0x07
    18b2:	00 a4       	ldd	r0, Z+40	; 0x28
    18b4:	f1 a5       	ldd	r31, Z+41	; 0x29
    18b6:	e0 2d       	mov	r30, r0
    18b8:	50 96       	adiw	r26, 0x10	; 16
    18ba:	4d 91       	ld	r20, X+
    18bc:	5d 91       	ld	r21, X+
    18be:	6d 91       	ld	r22, X+
    18c0:	7c 91       	ld	r23, X
    18c2:	53 97       	sbiw	r26, 0x13	; 19
    18c4:	ce 01       	movw	r24, r28
    18c6:	09 95       	icall
    18c8:	ab 01       	movw	r20, r22
    18ca:	bc 01       	movw	r22, r24
    18cc:	83 01       	movw	r16, r6
    18ce:	72 01       	movw	r14, r4
    18d0:	95 01       	movw	r18, r10
    18d2:	ce 01       	movw	r24, r28
    18d4:	f6 01       	movw	r30, r12
    18d6:	09 95       	icall
}
    18d8:	df 91       	pop	r29
    18da:	cf 91       	pop	r28
    18dc:	1f 91       	pop	r17
    18de:	0f 91       	pop	r16
    18e0:	ff 90       	pop	r15
    18e2:	ef 90       	pop	r14
    18e4:	df 90       	pop	r13
    18e6:	cf 90       	pop	r12
    18e8:	bf 90       	pop	r11
    18ea:	af 90       	pop	r10
    18ec:	7f 90       	pop	r7
    18ee:	6f 90       	pop	r6
    18f0:	5f 90       	pop	r5
    18f2:	4f 90       	pop	r4
    18f4:	08 95       	ret

000018f6 <_ZN6SX127x20setChannelScanActionEPFvvE>:
void SX127x::clearPacketSentAction() {
  this->clearDio0Action();
}

void SX127x::setChannelScanAction(void (*func)(void)) {
  this->setDio0Action(func, this->mod->hal->GpioInterruptRising);
    18f6:	fc 01       	movw	r30, r24
    18f8:	e7 5e       	subi	r30, 0xE7	; 231
    18fa:	fe 4f       	sbci	r31, 0xFE	; 254
    18fc:	01 90       	ld	r0, Z+
    18fe:	f0 81       	ld	r31, Z
    1900:	e0 2d       	mov	r30, r0
    1902:	01 90       	ld	r0, Z+
    1904:	f0 81       	ld	r31, Z
    1906:	e0 2d       	mov	r30, r0
    1908:	22 89       	ldd	r18, Z+18	; 0x12
    190a:	33 89       	ldd	r19, Z+19	; 0x13
    190c:	44 89       	ldd	r20, Z+20	; 0x14
    190e:	55 89       	ldd	r21, Z+21	; 0x15
    1910:	0e 94 3c 0c 	call	0x1878	; 0x1878 <_ZN6SX127x13setDio0ActionEPFvvEm>
}
    1914:	08 95       	ret

00001916 <_ZN6SX127x19setPacketSentActionEPFvvE>:
void SX127x::clearPacketReceivedAction() {
  this->clearDio0Action();
}

void SX127x::setPacketSentAction(void (*func)(void)) {
  this->setDio0Action(func, this->mod->hal->GpioInterruptRising);
    1916:	fc 01       	movw	r30, r24
    1918:	e7 5e       	subi	r30, 0xE7	; 231
    191a:	fe 4f       	sbci	r31, 0xFE	; 254
    191c:	01 90       	ld	r0, Z+
    191e:	f0 81       	ld	r31, Z
    1920:	e0 2d       	mov	r30, r0
    1922:	01 90       	ld	r0, Z+
    1924:	f0 81       	ld	r31, Z
    1926:	e0 2d       	mov	r30, r0
    1928:	22 89       	ldd	r18, Z+18	; 0x12
    192a:	33 89       	ldd	r19, Z+19	; 0x13
    192c:	44 89       	ldd	r20, Z+20	; 0x14
    192e:	55 89       	ldd	r21, Z+21	; 0x15
    1930:	0e 94 3c 0c 	call	0x1878	; 0x1878 <_ZN6SX127x13setDio0ActionEPFvvEm>
}
    1934:	08 95       	ret

00001936 <_ZN6SX127x23setPacketReceivedActionEPFvvE>:
  }
  this->mod->hal->detachInterrupt(this->mod->hal->pinToInterrupt(this->mod->getGpio()));
}

void SX127x::setPacketReceivedAction(void (*func)(void)) {
  this->setDio0Action(func, this->mod->hal->GpioInterruptRising);
    1936:	fc 01       	movw	r30, r24
    1938:	e7 5e       	subi	r30, 0xE7	; 231
    193a:	fe 4f       	sbci	r31, 0xFE	; 254
    193c:	01 90       	ld	r0, Z+
    193e:	f0 81       	ld	r31, Z
    1940:	e0 2d       	mov	r30, r0
    1942:	01 90       	ld	r0, Z+
    1944:	f0 81       	ld	r31, Z
    1946:	e0 2d       	mov	r30, r0
    1948:	22 89       	ldd	r18, Z+18	; 0x12
    194a:	33 89       	ldd	r19, Z+19	; 0x13
    194c:	44 89       	ldd	r20, Z+20	; 0x14
    194e:	55 89       	ldd	r21, Z+21	; 0x15
    1950:	0e 94 3c 0c 	call	0x1878	; 0x1878 <_ZN6SX127x13setDio0ActionEPFvvEm>
}
    1954:	08 95       	ret

00001956 <_ZN6SX127x7standbyEh>:
  return(setMode(RADIOLIB_SX127X_STANDBY));
}

int16_t SX127x::standby(uint8_t mode) {
  (void)mode;
  return(standby());
    1956:	dc 01       	movw	r26, r24
    1958:	ed 91       	ld	r30, X+
    195a:	fc 91       	ld	r31, X
    195c:	04 80       	ldd	r0, Z+4	; 0x04
    195e:	f5 81       	ldd	r31, Z+5	; 0x05
    1960:	e0 2d       	mov	r30, r0
    1962:	09 95       	icall
}
    1964:	08 95       	ret

00001966 <_ZN6SX127x11scanChannelEv>:
  state = readData(data, len);

  return(state);
}

int16_t SX127x::scanChannel() {
    1966:	0f 93       	push	r16
    1968:	1f 93       	push	r17
    196a:	cf 93       	push	r28
    196c:	df 93       	push	r29
    196e:	8c 01       	movw	r16, r24
  // start CAD
  int16_t state = startChannelScan();
    1970:	dc 01       	movw	r26, r24
    1972:	ed 91       	ld	r30, X+
    1974:	fc 91       	ld	r31, X
    1976:	04 a8       	ldd	r0, Z+52	; 0x34
    1978:	f5 a9       	ldd	r31, Z+53	; 0x35
    197a:	e0 2d       	mov	r30, r0
    197c:	09 95       	icall
  RADIOLIB_ASSERT(state);
    197e:	00 97       	sbiw	r24, 0x00	; 0
    1980:	09 f0       	breq	.+2      	; 0x1984 <_ZN6SX127x11scanChannelEv+0x1e>
    1982:	42 c0       	rjmp	.+132    	; 0x1a08 <_ZN6SX127x11scanChannelEv+0xa2>

  // wait for channel activity detected or timeout
  while(!this->mod->hal->digitalRead(this->mod->getIrq())) {
    1984:	f8 01       	movw	r30, r16
    1986:	e7 5e       	subi	r30, 0xE7	; 231
    1988:	fe 4f       	sbci	r31, 0xFE	; 254
    198a:	a0 81       	ld	r26, Z
    198c:	b1 81       	ldd	r27, Z+1	; 0x01
    198e:	8d 91       	ld	r24, X+
    1990:	9c 91       	ld	r25, X
    1992:	11 97       	sbiw	r26, 0x01	; 1
    1994:	ec 01       	movw	r28, r24
    1996:	e8 81       	ld	r30, Y
    1998:	f9 81       	ldd	r31, Y+1	; 0x01
    199a:	04 80       	ldd	r0, Z+4	; 0x04
    199c:	f5 81       	ldd	r31, Z+5	; 0x05
    199e:	e0 2d       	mov	r30, r0
    19a0:	50 96       	adiw	r26, 0x10	; 16
    19a2:	4d 91       	ld	r20, X+
    19a4:	5d 91       	ld	r21, X+
    19a6:	6d 91       	ld	r22, X+
    19a8:	7c 91       	ld	r23, X
    19aa:	53 97       	sbiw	r26, 0x13	; 19
    19ac:	09 95       	icall
    19ae:	67 2b       	or	r22, r23
    19b0:	68 2b       	or	r22, r24
    19b2:	69 2b       	or	r22, r25
    19b4:	39 f5       	brne	.+78     	; 0x1a04 <_ZN6SX127x11scanChannelEv+0x9e>
    this->mod->hal->yield();
    19b6:	e8 01       	movw	r28, r16
    19b8:	c7 5e       	subi	r28, 0xE7	; 231
    19ba:	de 4f       	sbci	r29, 0xFE	; 254
    19bc:	e8 81       	ld	r30, Y
    19be:	f9 81       	ldd	r31, Y+1	; 0x01
    19c0:	80 81       	ld	r24, Z
    19c2:	91 81       	ldd	r25, Z+1	; 0x01
    19c4:	dc 01       	movw	r26, r24
    19c6:	ed 91       	ld	r30, X+
    19c8:	fc 91       	ld	r31, X
    19ca:	06 a0       	ldd	r0, Z+38	; 0x26
    19cc:	f7 a1       	ldd	r31, Z+39	; 0x27
    19ce:	e0 2d       	mov	r30, r0
    19d0:	09 95       	icall
    if(this->mod->hal->digitalRead(this->mod->getGpio())) {
    19d2:	a8 81       	ld	r26, Y
    19d4:	b9 81       	ldd	r27, Y+1	; 0x01
    19d6:	8d 91       	ld	r24, X+
    19d8:	9c 91       	ld	r25, X
    19da:	11 97       	sbiw	r26, 0x01	; 1
    19dc:	ec 01       	movw	r28, r24
    19de:	e8 81       	ld	r30, Y
    19e0:	f9 81       	ldd	r31, Y+1	; 0x01
    19e2:	04 80       	ldd	r0, Z+4	; 0x04
    19e4:	f5 81       	ldd	r31, Z+5	; 0x05
    19e6:	e0 2d       	mov	r30, r0

    /*!
      \brief Access method to get the pin number of second interrupt/GPIO.
      \returns Pin number of second interrupt/GPIO configured in the constructor.
    */
    uint32_t getGpio() const { return(gpioPin); }
    19e8:	58 96       	adiw	r26, 0x18	; 24
    19ea:	4d 91       	ld	r20, X+
    19ec:	5d 91       	ld	r21, X+
    19ee:	6d 91       	ld	r22, X+
    19f0:	7c 91       	ld	r23, X
    19f2:	5b 97       	sbiw	r26, 0x1b	; 27
    19f4:	09 95       	icall
    19f6:	67 2b       	or	r22, r23
    19f8:	68 2b       	or	r22, r24
    19fa:	69 2b       	or	r22, r25
    19fc:	19 f2       	breq	.-122    	; 0x1984 <_ZN6SX127x11scanChannelEv+0x1e>
      return(RADIOLIB_PREAMBLE_DETECTED);
    19fe:	82 ef       	ldi	r24, 0xF2	; 242
    1a00:	9f ef       	ldi	r25, 0xFF	; 255
    1a02:	02 c0       	rjmp	.+4      	; 0x1a08 <_ZN6SX127x11scanChannelEv+0xa2>
    }
  }

  return(RADIOLIB_CHANNEL_FREE);
    1a04:	81 ef       	ldi	r24, 0xF1	; 241
    1a06:	9f ef       	ldi	r25, 0xFF	; 255
}
    1a08:	df 91       	pop	r29
    1a0a:	cf 91       	pop	r28
    1a0c:	1f 91       	pop	r17
    1a0e:	0f 91       	pop	r16
    1a10:	08 95       	ret

00001a12 <_ZN6SX127x6getModEv>:
SX127x::SX127x(Module* mod) : PhysicalLayer(RADIOLIB_SX127X_FREQUENCY_STEP_SIZE, RADIOLIB_SX127X_MAX_PACKET_LENGTH) {
  this->mod = mod;
}

Module* SX127x::getMod() {
  return(this->mod);
    1a12:	87 5e       	subi	r24, 0xE7	; 231
    1a14:	9e 4f       	sbci	r25, 0xFE	; 254
}
    1a16:	fc 01       	movw	r30, r24
    1a18:	80 81       	ld	r24, Z
    1a1a:	91 81       	ldd	r25, Z+1	; 0x01
    1a1c:	08 95       	ret

00001a1e <_ZN6SX127xC2EP6Module>:
#include "SX127x.h"
#include <math.h>
#if !defined(RADIOLIB_EXCLUDE_SX127X)

SX127x::SX127x(Module* mod) : PhysicalLayer(RADIOLIB_SX127X_FREQUENCY_STEP_SIZE, RADIOLIB_SX127X_MAX_PACKET_LENGTH) {
    1a1e:	0f 93       	push	r16
    1a20:	1f 93       	push	r17
    1a22:	cf 93       	push	r28
    1a24:	df 93       	push	r29
    1a26:	ec 01       	movw	r28, r24
    1a28:	8b 01       	movw	r16, r22
    1a2a:	2f ef       	ldi	r18, 0xFF	; 255
    1a2c:	30 e0       	ldi	r19, 0x00	; 0
    1a2e:	40 e0       	ldi	r20, 0x00	; 0
    1a30:	54 e2       	ldi	r21, 0x24	; 36
    1a32:	64 e7       	ldi	r22, 0x74	; 116
    1a34:	72 e4       	ldi	r23, 0x42	; 66
    1a36:	0e 94 95 0b 	call	0x172a	; 0x172a <_ZN13PhysicalLayerC2Efj>
    1a3a:	8c e7       	ldi	r24, 0x7C	; 124
    1a3c:	91 e0       	ldi	r25, 0x01	; 1
    1a3e:	99 83       	std	Y+1, r25	; 0x01
    1a40:	88 83       	st	Y, r24
    1a42:	fe 01       	movw	r30, r28
    1a44:	e5 5e       	subi	r30, 0xE5	; 229
    1a46:	fe 4f       	sbci	r31, 0xFE	; 254
    1a48:	10 82       	st	Z, r1
    1a4a:	11 82       	std	Z+1, r1	; 0x01
    1a4c:	12 82       	std	Z+2, r1	; 0x02
    1a4e:	13 82       	std	Z+3, r1	; 0x03
    1a50:	34 96       	adiw	r30, 0x04	; 4
    1a52:	10 82       	st	Z, r1
    1a54:	11 82       	std	Z+1, r1	; 0x01
    1a56:	12 82       	std	Z+2, r1	; 0x02
    1a58:	13 82       	std	Z+3, r1	; 0x03
    1a5a:	34 96       	adiw	r30, 0x04	; 4
    1a5c:	10 82       	st	Z, r1
    1a5e:	31 96       	adiw	r30, 0x01	; 1
    1a60:	10 82       	st	Z, r1
    1a62:	31 96       	adiw	r30, 0x01	; 1
    1a64:	10 82       	st	Z, r1
    1a66:	11 82       	std	Z+1, r1	; 0x01
    1a68:	12 82       	std	Z+2, r1	; 0x02
    1a6a:	13 82       	std	Z+3, r1	; 0x03
    1a6c:	34 96       	adiw	r30, 0x04	; 4
    1a6e:	10 82       	st	Z, r1
    1a70:	31 96       	adiw	r30, 0x01	; 1
    1a72:	10 82       	st	Z, r1
    1a74:	31 96       	adiw	r30, 0x01	; 1
    1a76:	81 e0       	ldi	r24, 0x01	; 1
    1a78:	80 83       	st	Z, r24
    1a7a:	31 96       	adiw	r30, 0x01	; 1
    1a7c:	11 82       	std	Z+1, r1	; 0x01
    1a7e:	10 82       	st	Z, r1
    1a80:	32 96       	adiw	r30, 0x02	; 2
    1a82:	10 82       	st	Z, r1
    1a84:	11 82       	std	Z+1, r1	; 0x01
    1a86:	12 82       	std	Z+2, r1	; 0x02
    1a88:	13 82       	std	Z+3, r1	; 0x03
    1a8a:	34 96       	adiw	r30, 0x04	; 4
    1a8c:	10 82       	st	Z, r1
    1a8e:	31 96       	adiw	r30, 0x01	; 1
    1a90:	80 e8       	ldi	r24, 0x80	; 128
    1a92:	80 83       	st	Z, r24
  this->mod = mod;
    1a94:	c7 5e       	subi	r28, 0xE7	; 231
    1a96:	de 4f       	sbci	r29, 0xFE	; 254
    1a98:	19 83       	std	Y+1, r17	; 0x01
    1a9a:	08 83       	st	Y, r16
}
    1a9c:	df 91       	pop	r29
    1a9e:	cf 91       	pop	r28
    1aa0:	1f 91       	pop	r17
    1aa2:	0f 91       	pop	r16
    1aa4:	08 95       	ret

00001aa6 <_ZN6SX12785resetEv>:
  RADIOLIB_ASSERT(state);

  return(state);
}

void SX1278::reset() {
    1aa6:	ef 92       	push	r14
    1aa8:	ff 92       	push	r15
    1aaa:	0f 93       	push	r16
    1aac:	1f 93       	push	r17
    1aae:	cf 93       	push	r28
    1ab0:	df 93       	push	r29
  this->mod->hal->pinMode(this->mod->getRst(), this->mod->hal->GpioModeOutput);
    1ab2:	ec 01       	movw	r28, r24
    1ab4:	c7 5e       	subi	r28, 0xE7	; 231
    1ab6:	de 4f       	sbci	r29, 0xFE	; 254
    1ab8:	a8 81       	ld	r26, Y
    1aba:	b9 81       	ldd	r27, Y+1	; 0x01
    1abc:	8d 91       	ld	r24, X+
    1abe:	9c 91       	ld	r25, X
    1ac0:	11 97       	sbiw	r26, 0x01	; 1
    1ac2:	fc 01       	movw	r30, r24
    1ac4:	20 81       	ld	r18, Z
    1ac6:	31 81       	ldd	r19, Z+1	; 0x01
    1ac8:	f9 01       	movw	r30, r18
    1aca:	e0 80       	ld	r14, Z
    1acc:	f1 80       	ldd	r15, Z+1	; 0x01
    1ace:	fc 01       	movw	r30, r24
    1ad0:	06 81       	ldd	r16, Z+6	; 0x06
    1ad2:	17 81       	ldd	r17, Z+7	; 0x07
    1ad4:	20 85       	ldd	r18, Z+8	; 0x08
    1ad6:	31 85       	ldd	r19, Z+9	; 0x09

    /*!
      \brief Access method to get the pin number of hardware reset pin.
      \returns Pin number of hardware reset pin configured in the constructor.
    */
    uint32_t getRst() const { return(rstPin); }
    1ad8:	54 96       	adiw	r26, 0x14	; 20
    1ada:	4d 91       	ld	r20, X+
    1adc:	5d 91       	ld	r21, X+
    1ade:	6d 91       	ld	r22, X+
    1ae0:	7c 91       	ld	r23, X
    1ae2:	57 97       	sbiw	r26, 0x17	; 23
    1ae4:	f7 01       	movw	r30, r14
    1ae6:	09 95       	icall
  this->mod->hal->digitalWrite(this->mod->getRst(), this->mod->hal->GpioLevelLow);
    1ae8:	a8 81       	ld	r26, Y
    1aea:	b9 81       	ldd	r27, Y+1	; 0x01
    1aec:	8d 91       	ld	r24, X+
    1aee:	9c 91       	ld	r25, X
    1af0:	11 97       	sbiw	r26, 0x01	; 1
    1af2:	fc 01       	movw	r30, r24
    1af4:	20 81       	ld	r18, Z
    1af6:	31 81       	ldd	r19, Z+1	; 0x01
    1af8:	f9 01       	movw	r30, r18
    1afa:	e2 80       	ldd	r14, Z+2	; 0x02
    1afc:	f3 80       	ldd	r15, Z+3	; 0x03
    1afe:	fc 01       	movw	r30, r24
    1b00:	02 85       	ldd	r16, Z+10	; 0x0a
    1b02:	13 85       	ldd	r17, Z+11	; 0x0b
    1b04:	24 85       	ldd	r18, Z+12	; 0x0c
    1b06:	35 85       	ldd	r19, Z+13	; 0x0d
    1b08:	54 96       	adiw	r26, 0x14	; 20
    1b0a:	4d 91       	ld	r20, X+
    1b0c:	5d 91       	ld	r21, X+
    1b0e:	6d 91       	ld	r22, X+
    1b10:	7c 91       	ld	r23, X
    1b12:	57 97       	sbiw	r26, 0x17	; 23
    1b14:	f7 01       	movw	r30, r14
    1b16:	09 95       	icall
  this->mod->hal->delay(1);
    1b18:	e8 81       	ld	r30, Y
    1b1a:	f9 81       	ldd	r31, Y+1	; 0x01
    1b1c:	80 81       	ld	r24, Z
    1b1e:	91 81       	ldd	r25, Z+1	; 0x01
    1b20:	dc 01       	movw	r26, r24
    1b22:	ed 91       	ld	r30, X+
    1b24:	fc 91       	ld	r31, X
    1b26:	02 84       	ldd	r0, Z+10	; 0x0a
    1b28:	f3 85       	ldd	r31, Z+11	; 0x0b
    1b2a:	e0 2d       	mov	r30, r0
    1b2c:	41 e0       	ldi	r20, 0x01	; 1
    1b2e:	50 e0       	ldi	r21, 0x00	; 0
    1b30:	60 e0       	ldi	r22, 0x00	; 0
    1b32:	70 e0       	ldi	r23, 0x00	; 0
    1b34:	09 95       	icall
  this->mod->hal->digitalWrite(this->mod->getRst(), this->mod->hal->GpioLevelHigh);
    1b36:	a8 81       	ld	r26, Y
    1b38:	b9 81       	ldd	r27, Y+1	; 0x01
    1b3a:	8d 91       	ld	r24, X+
    1b3c:	9c 91       	ld	r25, X
    1b3e:	11 97       	sbiw	r26, 0x01	; 1
    1b40:	fc 01       	movw	r30, r24
    1b42:	20 81       	ld	r18, Z
    1b44:	31 81       	ldd	r19, Z+1	; 0x01
    1b46:	f9 01       	movw	r30, r18
    1b48:	e2 80       	ldd	r14, Z+2	; 0x02
    1b4a:	f3 80       	ldd	r15, Z+3	; 0x03
    1b4c:	fc 01       	movw	r30, r24
    1b4e:	06 85       	ldd	r16, Z+14	; 0x0e
    1b50:	17 85       	ldd	r17, Z+15	; 0x0f
    1b52:	20 89       	ldd	r18, Z+16	; 0x10
    1b54:	31 89       	ldd	r19, Z+17	; 0x11
    1b56:	54 96       	adiw	r26, 0x14	; 20
    1b58:	4d 91       	ld	r20, X+
    1b5a:	5d 91       	ld	r21, X+
    1b5c:	6d 91       	ld	r22, X+
    1b5e:	7c 91       	ld	r23, X
    1b60:	57 97       	sbiw	r26, 0x17	; 23
    1b62:	f7 01       	movw	r30, r14
    1b64:	09 95       	icall
  this->mod->hal->delay(5);
    1b66:	e8 81       	ld	r30, Y
    1b68:	f9 81       	ldd	r31, Y+1	; 0x01
    1b6a:	80 81       	ld	r24, Z
    1b6c:	91 81       	ldd	r25, Z+1	; 0x01
    1b6e:	dc 01       	movw	r26, r24
    1b70:	ed 91       	ld	r30, X+
    1b72:	fc 91       	ld	r31, X
    1b74:	02 84       	ldd	r0, Z+10	; 0x0a
    1b76:	f3 85       	ldd	r31, Z+11	; 0x0b
    1b78:	e0 2d       	mov	r30, r0
    1b7a:	45 e0       	ldi	r20, 0x05	; 5
    1b7c:	50 e0       	ldi	r21, 0x00	; 0
    1b7e:	60 e0       	ldi	r22, 0x00	; 0
    1b80:	70 e0       	ldi	r23, 0x00	; 0
    1b82:	09 95       	icall
}
    1b84:	df 91       	pop	r29
    1b86:	cf 91       	pop	r28
    1b88:	1f 91       	pop	r17
    1b8a:	0f 91       	pop	r16
    1b8c:	ff 90       	pop	r15
    1b8e:	ef 90       	pop	r14
    1b90:	08 95       	ret

00001b92 <_ZN6SX1278C1EP6Module>:
#include "SX1278.h"
#include <math.h>
#if !defined(RADIOLIB_EXCLUDE_SX127X)

SX1278::SX1278(Module* mod) : SX127x(mod) {
    1b92:	cf 93       	push	r28
    1b94:	df 93       	push	r29
    1b96:	ec 01       	movw	r28, r24
    1b98:	0e 94 0f 0d 	call	0x1a1e	; 0x1a1e <_ZN6SX127xC2EP6Module>
    1b9c:	84 e2       	ldi	r24, 0x24	; 36
    1b9e:	91 e0       	ldi	r25, 0x01	; 1
    1ba0:	99 83       	std	Y+1, r25	; 0x01
    1ba2:	88 83       	st	Y, r24
    1ba4:	fe 01       	movw	r30, r28
    1ba6:	ec 5c       	subi	r30, 0xCC	; 204
    1ba8:	fe 4f       	sbci	r31, 0xFE	; 254
    1baa:	81 e0       	ldi	r24, 0x01	; 1
    1bac:	80 83       	st	Z, r24
    1bae:	cb 5c       	subi	r28, 0xCB	; 203
    1bb0:	de 4f       	sbci	r29, 0xFE	; 254
    1bb2:	18 82       	st	Y, r1

}
    1bb4:	df 91       	pop	r29
    1bb6:	cf 91       	pop	r28
    1bb8:	08 95       	ret

00001bba <_Z41__static_initialization_and_destruction_0ii.lto_priv.0>:

void loop()
{
    // gps.update();
    link.update();
    1bba:	cf 93       	push	r28
    1bbc:	df 93       	push	r29
    1bbe:	01 97       	sbiw	r24, 0x01	; 1
    1bc0:	19 f0       	breq	.+6      	; 0x1bc8 <_Z41__static_initialization_and_destruction_0ii.lto_priv.0+0xe>
    1bc2:	df 91       	pop	r29
    1bc4:	cf 91       	pop	r28
    1bc6:	08 95       	ret
    1bc8:	6f 3f       	cpi	r22, 0xFF	; 255
    1bca:	7f 4f       	sbci	r23, 0xFF	; 255
    1bcc:	d1 f7       	brne	.-12     	; 0x1bc2 <_Z41__static_initialization_and_destruction_0ii.lto_priv.0+0x8>
#include <SoftwareSerial.h>
#include <gel.h>

#include "Message.h"

gel::Radio radio{};
    1bce:	e9 e6       	ldi	r30, 0x69	; 105
    1bd0:	f5 e0       	ldi	r31, 0x05	; 5
    1bd2:	80 e7       	ldi	r24, 0x70	; 112
    1bd4:	91 e0       	ldi	r25, 0x01	; 1
    1bd6:	df 01       	movw	r26, r30
    1bd8:	ec 01       	movw	r28, r24
    1bda:	1d 92       	st	X+, r1
    1bdc:	21 97       	sbiw	r28, 0x01	; 1
    1bde:	e9 f7       	brne	.-6      	; 0x1bda <_Z41__static_initialization_and_destruction_0ii.lto_priv.0+0x20>
        Scanning,
    };

public:
    // Construction
    Radio() = default;
    1be0:	10 82       	st	Z, r1
    //***************************************************************************
    /// Constructor.
    //***************************************************************************
    ETL_CONSTEXPR14 optional()
      : valid(false)
      , storage()
    1be2:	14 82       	std	Z+4, r1	; 0x04
    1be4:	16 82       	std	Z+6, r1	; 0x06
    1be6:	10 86       	std	Z+8, r1	; 0x08
    1be8:	12 86       	std	Z+10, r1	; 0x0a
    1bea:	14 86       	std	Z+12, r1	; 0x0c
{   
    LoRaConfig lora;
    FSKConfig fsk;
};

struct RadioConfig
    1bec:	84 e8       	ldi	r24, 0x84	; 132
    1bee:	92 ef       	ldi	r25, 0xF2	; 242
    1bf0:	ae ec       	ldi	r26, 0xCE	; 206
    1bf2:	bd e4       	ldi	r27, 0x4D	; 77
    1bf4:	87 87       	std	Z+15, r24	; 0x0f
    1bf6:	90 8b       	std	Z+16, r25	; 0x10
    1bf8:	a1 8b       	std	Z+17, r26	; 0x11
    1bfa:	b2 8b       	std	Z+18, r27	; 0x12
    1bfc:	82 e1       	ldi	r24, 0x12	; 18
    1bfe:	90 e0       	ldi	r25, 0x00	; 0
    1c00:	a0 e0       	ldi	r26, 0x00	; 0
    1c02:	b0 e0       	ldi	r27, 0x00	; 0
    1c04:	83 8b       	std	Z+19, r24	; 0x13
    1c06:	94 8b       	std	Z+20, r25	; 0x14
    1c08:	a5 8b       	std	Z+21, r26	; 0x15
    1c0a:	b6 8b       	std	Z+22, r27	; 0x16
    1c0c:	8a e0       	ldi	r24, 0x0A	; 10
    1c0e:	87 8b       	std	Z+23, r24	; 0x17
    1c10:	80 8f       	std	Z+24, r24	; 0x18
    //***************************************************************************
    /// Constructor with nullopt.
    //***************************************************************************
    ETL_CONSTEXPR14 optional(etl::nullopt_t)
      : valid(false)
      , storage()
    1c12:	11 8e       	std	Z+25, r1	; 0x19
    1c14:	15 8e       	std	Z+29, r1	; 0x1d
    1c16:	14 8e       	std	Z+28, r1	; 0x1c
    1c18:	a7 e8       	ldi	r26, 0x87	; 135
    1c1a:	b5 e0       	ldi	r27, 0x05	; 5
    1c1c:	80 e1       	ldi	r24, 0x10	; 16
    1c1e:	ed 01       	movw	r28, r26
    1c20:	19 92       	st	Y+, r1
    1c22:	8a 95       	dec	r24
    1c24:	e9 f7       	brne	.-6      	; 0x1c20 <_Z41__static_initialization_and_destruction_0ii.lto_priv.0+0x66>
        Scanning,
    };

public:
    // Construction
    Radio() = default;
    1c26:	13 aa       	std	Z+51, r1	; 0x33
    1c28:	12 aa       	std	Z+50, r1	; 0x32
    1c2a:	70 e0       	ldi	r23, 0x00	; 0
    1c2c:	60 e0       	ldi	r22, 0x00	; 0
    1c2e:	8d e9       	ldi	r24, 0x9D	; 157
    1c30:	95 e0       	ldi	r25, 0x05	; 5
    1c32:	0e 94 c9 0d 	call	0x1b92	; 0x1b92 <_ZN6SX1278C1EP6Module>
    1c36:	10 92 d4 06 	sts	0x06D4, r1	; 0x8006d4 <radio+0x16b>
    1c3a:	10 92 d6 06 	sts	0x06D6, r1	; 0x8006d6 <radio+0x16d>
    1c3e:	10 92 d5 06 	sts	0x06D5, r1	; 0x8006d5 <radio+0x16c>
    1c42:	10 92 d8 06 	sts	0x06D8, r1	; 0x8006d8 <radio+0x16f>
    1c46:	10 92 d7 06 	sts	0x06D7, r1	; 0x8006d7 <radio+0x16e>
gel::Link link{};
    1c4a:	e2 e4       	ldi	r30, 0x42	; 66
    1c4c:	f3 e0       	ldi	r31, 0x03	; 3
    1c4e:	87 e2       	ldi	r24, 0x27	; 39
    1c50:	92 e0       	ldi	r25, 0x02	; 2
    1c52:	df 01       	movw	r26, r30
    1c54:	ec 01       	movw	r28, r24
    1c56:	1d 92       	st	X+, r1
    1c58:	21 97       	sbiw	r28, 0x01	; 1
    1c5a:	e9 f7       	brne	.-6      	; 0x1c56 <_Z41__static_initialization_and_destruction_0ii.lto_priv.0+0x9c>

#define LINK_MAX_PAYLOAD 255

namespace gel {

struct LinkConfig
    1c5c:	88 e2       	ldi	r24, 0x28	; 40
    1c5e:	93 e2       	ldi	r25, 0x23	; 35
    1c60:	a0 e0       	ldi	r26, 0x00	; 0
    1c62:	b0 e0       	ldi	r27, 0x00	; 0
    1c64:	84 83       	std	Z+4, r24	; 0x04
    1c66:	95 83       	std	Z+5, r25	; 0x05
    1c68:	a6 83       	std	Z+6, r26	; 0x06
    1c6a:	b7 83       	std	Z+7, r27	; 0x07
    1c6c:	88 ee       	ldi	r24, 0xE8	; 232
    1c6e:	93 e0       	ldi	r25, 0x03	; 3
    1c70:	a0 e0       	ldi	r26, 0x00	; 0
    1c72:	b0 e0       	ldi	r27, 0x00	; 0
    1c74:	80 87       	std	Z+8, r24	; 0x08
    1c76:	91 87       	std	Z+9, r25	; 0x09
    1c78:	a2 87       	std	Z+10, r26	; 0x0a
    1c7a:	b3 87       	std	Z+11, r27	; 0x0b

    //*************************************************************************
    /// Constructor.
    //*************************************************************************
    vector_base(size_t max_size_)
      : CAPACITY(max_size_)
    1c7c:	8f ef       	ldi	r24, 0xFF	; 255
    1c7e:	90 e0       	ldi	r25, 0x00	; 0
    1c80:	94 8f       	std	Z+28, r25	; 0x1c
    1c82:	83 8f       	std	Z+27, r24	; 0x1b
    /// Constructor.
    //*********************************************************************
    ivector(T* p_buffer_, size_t MAX_SIZE)
      : vector_base(MAX_SIZE)
      , p_buffer(p_buffer_)
      , p_end(p_buffer_)
    1c84:	24 e6       	ldi	r18, 0x64	; 100
    1c86:	33 e0       	ldi	r19, 0x03	; 3
    1c88:	37 8f       	std	Z+31, r19	; 0x1f
    1c8a:	26 8f       	std	Z+30, r18	; 0x1e
    1c8c:	31 a3       	std	Z+33, r19	; 0x21
    1c8e:	20 a3       	std	Z+32, r18	; 0x20
    1c90:	90 93 64 04 	sts	0x0464, r25	; 0x800464 <link+0x122>
    1c94:	80 93 63 04 	sts	0x0463, r24	; 0x800463 <link+0x121>
    1c98:	8a e6       	ldi	r24, 0x6A	; 106
    1c9a:	94 e0       	ldi	r25, 0x04	; 4
    1c9c:	90 93 67 04 	sts	0x0467, r25	; 0x800467 <link+0x125>
    1ca0:	80 93 66 04 	sts	0x0466, r24	; 0x800466 <link+0x124>
    1ca4:	90 93 69 04 	sts	0x0469, r25	; 0x800469 <link+0x127>
    1ca8:	80 93 68 04 	sts	0x0468, r24	; 0x800468 <link+0x126>
    1cac:	8a cf       	rjmp	.-236    	; 0x1bc2 <_Z41__static_initialization_and_destruction_0ii.lto_priv.0+0x8>

00001cae <_Z9setupLinkv>:

    return radio.begin(pins, config);
}

gel::Error setupLink()
{
    1cae:	8f 92       	push	r8
    1cb0:	9f 92       	push	r9
    1cb2:	af 92       	push	r10
    1cb4:	bf 92       	push	r11
    1cb6:	cf 92       	push	r12
    1cb8:	df 92       	push	r13
    1cba:	ef 92       	push	r14
    1cbc:	ff 92       	push	r15
    1cbe:	0f 93       	push	r16
    1cc0:	1f 93       	push	r17
    1cc2:	cf 93       	push	r28
    1cc4:	df 93       	push	r29
    1cc6:	cd b7       	in	r28, 0x3d	; 61
    1cc8:	de b7       	in	r29, 0x3e	; 62
    1cca:	2f 97       	sbiw	r28, 0x0f	; 15
    1ccc:	0f b6       	in	r0, 0x3f	; 63
    1cce:	f8 94       	cli
    1cd0:	de bf       	out	0x3e, r29	; 62
    1cd2:	0f be       	out	0x3f, r0	; 63
    1cd4:	cd bf       	out	0x3d, r28	; 61
    1cd6:	4c 01       	movw	r8, r24
    gel::LinkConfig config{};
    1cd8:	89 e0       	ldi	r24, 0x09	; 9
    1cda:	eb e0       	ldi	r30, 0x0B	; 11
    1cdc:	f1 e0       	ldi	r31, 0x01	; 1
    1cde:	de 01       	movw	r26, r28
    1ce0:	11 96       	adiw	r26, 0x01	; 1
    1ce2:	01 90       	ld	r0, Z+
    1ce4:	0d 92       	st	X+, r0
    1ce6:	8a 95       	dec	r24
    1ce8:	e1 f7       	brne	.-8      	; 0x1ce2 <_Z9setupLinkv+0x34>

    config.controller = false;
    if (gel::Error err = link.begin(radio, config))
    1cea:	a1 2c       	mov	r10, r1
    1cec:	ba 80       	ldd	r11, Y+2	; 0x02
    1cee:	cb 80       	ldd	r12, Y+3	; 0x03
    1cf0:	dc 80       	ldd	r13, Y+4	; 0x04
    1cf2:	ed 80       	ldd	r14, Y+5	; 0x05
    1cf4:	fe 80       	ldd	r15, Y+6	; 0x06
    1cf6:	0f 81       	ldd	r16, Y+7	; 0x07
    1cf8:	18 85       	ldd	r17, Y+8	; 0x08
    1cfa:	29 85       	ldd	r18, Y+9	; 0x09
    1cfc:	49 e6       	ldi	r20, 0x69	; 105
    1cfe:	55 e0       	ldi	r21, 0x05	; 5
    1d00:	62 e4       	ldi	r22, 0x42	; 66
    1d02:	73 e0       	ldi	r23, 0x03	; 3
    1d04:	ce 01       	movw	r24, r28
    1d06:	0a 96       	adiw	r24, 0x0a	; 10
    1d08:	0e 94 e6 07 	call	0xfcc	; 0xfcc <_ZN3gel4Link5beginERNS_5RadioENS_10LinkConfigE>

    // Methods
    explicit operator bool() { return code != Error::None; }
    1d0c:	8c 85       	ldd	r24, Y+12	; 0x0c
    1d0e:	9d 85       	ldd	r25, Y+13	; 0x0d
    1d10:	89 2b       	or	r24, r25
    1d12:	39 f5       	brne	.+78     	; 0x1d62 <_Z9setupLinkv+0xb4>
    
    Error begin(Radio &radio, LinkConfig config);
    Error update();

    void setTelecommandCallback(TelecommandCallback callback) { this->telecommandCallback = callback; };
    void setTelemetryCallback(TelemetryCallback callback) { this->telemetryCallback = callback; };
    1d14:	e2 e4       	ldi	r30, 0x42	; 66
    1d16:	f3 e0       	ldi	r31, 0x03	; 3
    1d18:	8d e6       	ldi	r24, 0x6D	; 109
    1d1a:	93 e1       	ldi	r25, 0x13	; 19
    1d1c:	91 8b       	std	Z+17, r25	; 0x11
    1d1e:	80 8b       	std	Z+16, r24	; 0x10
    Link() = default;
    
    Error begin(Radio &radio, LinkConfig config);
    Error update();

    void setTelecommandCallback(TelecommandCallback callback) { this->telecommandCallback = callback; };
    1d20:	8e ee       	ldi	r24, 0xEE	; 238
    1d22:	92 e1       	ldi	r25, 0x12	; 18
    1d24:	97 87       	std	Z+15, r25	; 0x0f
    1d26:	86 87       	std	Z+14, r24	; 0x0e
        CapacityFull,
        NotImplemented,
    };

    Error() = default;
    Error(Code other) : code(other) {}
    1d28:	8c e8       	ldi	r24, 0x8C	; 140
    1d2a:	92 e0       	ldi	r25, 0x02	; 2
    1d2c:	f4 01       	movw	r30, r8
    1d2e:	91 83       	std	Z+1, r25	; 0x01
    1d30:	80 83       	st	Z, r24
    1d32:	13 82       	std	Z+3, r1	; 0x03
    1d34:	12 82       	std	Z+2, r1	; 0x02
    1d36:	15 82       	std	Z+5, r1	; 0x05
    1d38:	14 82       	std	Z+4, r1	; 0x04

    link.setTelemetryCallback(telemetryCallback);
    link.setTelecommandCallback(telecommandCallback);

    return gel::Error::None;
}
    1d3a:	c4 01       	movw	r24, r8
    1d3c:	2f 96       	adiw	r28, 0x0f	; 15
    1d3e:	0f b6       	in	r0, 0x3f	; 63
    1d40:	f8 94       	cli
    1d42:	de bf       	out	0x3e, r29	; 62
    1d44:	0f be       	out	0x3f, r0	; 63
    1d46:	cd bf       	out	0x3d, r28	; 61
    1d48:	df 91       	pop	r29
    1d4a:	cf 91       	pop	r28
    1d4c:	1f 91       	pop	r17
    1d4e:	0f 91       	pop	r16
    1d50:	ff 90       	pop	r15
    1d52:	ef 90       	pop	r14
    1d54:	df 90       	pop	r13
    1d56:	cf 90       	pop	r12
    1d58:	bf 90       	pop	r11
    1d5a:	af 90       	pop	r10
    1d5c:	9f 90       	pop	r9
    1d5e:	8f 90       	pop	r8
    1d60:	08 95       	ret
#include <gel/Core.h>

namespace gel
{

struct Error : Printable
    1d62:	8c e8       	ldi	r24, 0x8C	; 140
    1d64:	92 e0       	ldi	r25, 0x02	; 2
    1d66:	f4 01       	movw	r30, r8
    1d68:	91 83       	std	Z+1, r25	; 0x01
    1d6a:	80 83       	st	Z, r24
    1d6c:	8c 85       	ldd	r24, Y+12	; 0x0c
    1d6e:	9d 85       	ldd	r25, Y+13	; 0x0d
    1d70:	93 83       	std	Z+3, r25	; 0x03
    1d72:	82 83       	std	Z+2, r24	; 0x02
    1d74:	8e 85       	ldd	r24, Y+14	; 0x0e
    1d76:	9f 85       	ldd	r25, Y+15	; 0x0f
    1d78:	95 83       	std	Z+5, r25	; 0x05
    1d7a:	84 83       	std	Z+4, r24	; 0x04
    1d7c:	de cf       	rjmp	.-68     	; 0x1d3a <_Z9setupLinkv+0x8c>

00001d7e <pulseIn>:
 * before the start of the pulse.
 *
 * This function performs better with short pulses in noInterrupt() context
 */
unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout)
{
    1d7e:	0f 93       	push	r16
    1d80:	1f 93       	push	r17
	// cache the port and bit of the pin in order to speed up the
	// pulse width measuring loop and achieve finer resolution.  calling
	// digitalRead() instead yields much coarser resolution.
	uint8_t bit = digitalPinToBitMask(pin);
    1d82:	90 e0       	ldi	r25, 0x00	; 0
    1d84:	fc 01       	movw	r30, r24
    1d86:	e5 56       	subi	r30, 0x65	; 101
    1d88:	ff 4f       	sbci	r31, 0xFF	; 255
    1d8a:	74 91       	lpm	r23, Z
	uint8_t port = digitalPinToPort(pin);
    1d8c:	fc 01       	movw	r30, r24
    1d8e:	e1 55       	subi	r30, 0x51	; 81
    1d90:	ff 4f       	sbci	r31, 0xFF	; 255
    1d92:	e4 91       	lpm	r30, Z
	uint8_t stateMask = (state ? bit : 0);
    1d94:	61 11       	cpse	r22, r1
    1d96:	67 2f       	mov	r22, r23

	// convert the timeout from microseconds to a number of times through
	// the initial loop; it takes approximately 16 clock cycles per iteration
	unsigned long maxloops = microsecondsToClockCycles(timeout)/16;
    1d98:	89 01       	movw	r16, r18
    1d9a:	9a 01       	movw	r18, r20
    1d9c:	3f 70       	andi	r19, 0x0F	; 15

	unsigned long width = countPulseASM(portInputRegister(port), bit, stateMask, maxloops);
    1d9e:	f0 e0       	ldi	r31, 0x00	; 0
    1da0:	ee 0f       	add	r30, r30
    1da2:	ff 1f       	adc	r31, r31
    1da4:	e9 57       	subi	r30, 0x79	; 121
    1da6:	ff 4f       	sbci	r31, 0xFF	; 255
    1da8:	85 91       	lpm	r24, Z+
    1daa:	94 91       	lpm	r25, Z
    1dac:	46 2f       	mov	r20, r22
    1dae:	67 2f       	mov	r22, r23
    1db0:	0e 94 f7 38 	call	0x71ee	; 0x71ee <countPulseASM>

	// prevent clockCyclesToMicroseconds to return bogus values if countPulseASM timed out
	if (width)
    1db4:	61 15       	cp	r22, r1
    1db6:	71 05       	cpc	r23, r1
    1db8:	81 05       	cpc	r24, r1
    1dba:	91 05       	cpc	r25, r1
    1dbc:	29 f0       	breq	.+10     	; 0x1dc8 <pulseIn+0x4a>
		return clockCyclesToMicroseconds(width * 16 + 16);
    1dbe:	6f 5f       	subi	r22, 0xFF	; 255
    1dc0:	7f 4f       	sbci	r23, 0xFF	; 255
    1dc2:	8f 4f       	sbci	r24, 0xFF	; 255
    1dc4:	9f 4f       	sbci	r25, 0xFF	; 255
    1dc6:	9f 70       	andi	r25, 0x0F	; 15
	else
		return 0;
}
    1dc8:	1f 91       	pop	r17
    1dca:	0f 91       	pop	r16
    1dcc:	08 95       	ret

00001dce <_ZN10ArduinoHal7pulseInEmmm>:

unsigned long inline ArduinoHal::micros() {
  return(::micros());
}

long inline ArduinoHal::pulseIn(uint32_t pin, uint32_t state, unsigned long timeout) {
    1dce:	cf 92       	push	r12
    1dd0:	df 92       	push	r13
    1dd2:	ef 92       	push	r14
    1dd4:	ff 92       	push	r15
    1dd6:	0f 93       	push	r16
  if(pin == RADIOLIB_NC) {
    1dd8:	4f 3f       	cpi	r20, 0xFF	; 255
    1dda:	8f ef       	ldi	r24, 0xFF	; 255
    1ddc:	58 07       	cpc	r21, r24
    1dde:	68 07       	cpc	r22, r24
    1de0:	78 07       	cpc	r23, r24
    1de2:	61 f0       	breq	.+24     	; 0x1dfc <_ZN10ArduinoHal7pulseInEmmm+0x2e>
    1de4:	ca 01       	movw	r24, r20
    return 0;
  }
  return(::pulseIn(pin, state, timeout));
    1de6:	a7 01       	movw	r20, r14
    1de8:	96 01       	movw	r18, r12
    1dea:	60 2f       	mov	r22, r16
    1dec:	0e 94 bf 0e 	call	0x1d7e	; 0x1d7e <pulseIn>
}
    1df0:	0f 91       	pop	r16
    1df2:	ff 90       	pop	r15
    1df4:	ef 90       	pop	r14
    1df6:	df 90       	pop	r13
    1df8:	cf 90       	pop	r12
    1dfa:	08 95       	ret
  return(::micros());
}

long inline ArduinoHal::pulseIn(uint32_t pin, uint32_t state, unsigned long timeout) {
  if(pin == RADIOLIB_NC) {
    return 0;
    1dfc:	60 e0       	ldi	r22, 0x00	; 0
    1dfe:	70 e0       	ldi	r23, 0x00	; 0
    1e00:	cb 01       	movw	r24, r22
    1e02:	f6 cf       	rjmp	.-20     	; 0x1df0 <_ZN10ArduinoHal7pulseInEmmm+0x22>

00001e04 <_ZdaPv>:
void operator delete(void * ptr) {
  free(ptr);
}

void operator delete[](void * ptr) {
  free(ptr);
    1e04:	0e 94 72 3d 	call	0x7ae4	; 0x7ae4 <free>
}
    1e08:	08 95       	ret

00001e0a <_ZN6String10invalidateEv>:
	capacity = 0;
	len = 0;
}

void String::invalidate(void)
{
    1e0a:	cf 93       	push	r28
    1e0c:	df 93       	push	r29
    1e0e:	ec 01       	movw	r28, r24
	if (buffer) free(buffer);
    1e10:	88 81       	ld	r24, Y
    1e12:	99 81       	ldd	r25, Y+1	; 0x01
    1e14:	00 97       	sbiw	r24, 0x00	; 0
    1e16:	11 f0       	breq	.+4      	; 0x1e1c <_ZN6String10invalidateEv+0x12>
    1e18:	0e 94 72 3d 	call	0x7ae4	; 0x7ae4 <free>
	buffer = NULL;
    1e1c:	19 82       	std	Y+1, r1	; 0x01
    1e1e:	18 82       	st	Y, r1
	capacity = len = 0;
    1e20:	1d 82       	std	Y+5, r1	; 0x05
    1e22:	1c 82       	std	Y+4, r1	; 0x04
    1e24:	1b 82       	std	Y+3, r1	; 0x03
    1e26:	1a 82       	std	Y+2, r1	; 0x02
}
    1e28:	df 91       	pop	r29
    1e2a:	cf 91       	pop	r28
    1e2c:	08 95       	ret

00001e2e <_ZN6StringD1Ev>:
	*this = dtostrf(value, (decimalPlaces + 2), decimalPlaces, buf);
}

String::~String()
{
	if (buffer) free(buffer);
    1e2e:	fc 01       	movw	r30, r24
    1e30:	80 81       	ld	r24, Z
    1e32:	91 81       	ldd	r25, Z+1	; 0x01
    1e34:	00 97       	sbiw	r24, 0x00	; 0
    1e36:	11 f0       	breq	.+4      	; 0x1e3c <_ZN6StringD1Ev+0xe>
    1e38:	0e 94 72 3d 	call	0x7ae4	; 0x7ae4 <free>
}
    1e3c:	08 95       	ret

00001e3e <_Znaj>:
void *operator new(size_t size) {
  return malloc(size);
}

void *operator new[](size_t size) {
  return malloc(size);
    1e3e:	0e 94 d6 3c 	call	0x79ac	; 0x79ac <malloc>
}
    1e42:	08 95       	ret

00001e44 <_Znwj>:
*/

#include <stdlib.h>

void *operator new(size_t size) {
  return malloc(size);
    1e44:	0e 94 d6 3c 	call	0x79ac	; 0x79ac <malloc>
}
    1e48:	08 95       	ret

00001e4a <_ZN6ModuleC1Emmmm>:
#endif

#if defined(RADIOLIB_BUILD_ARDUINO)
#include "ArduinoHal.h"

Module::Module(uint32_t cs, uint32_t irq, uint32_t rst, uint32_t gpio) : csPin(cs), irqPin(irq), rstPin(rst), gpioPin(gpio) {
    1e4a:	6f 92       	push	r6
    1e4c:	7f 92       	push	r7
    1e4e:	8f 92       	push	r8
    1e50:	9f 92       	push	r9
    1e52:	af 92       	push	r10
    1e54:	bf 92       	push	r11
    1e56:	cf 92       	push	r12
    1e58:	df 92       	push	r13
    1e5a:	ef 92       	push	r14
    1e5c:	ff 92       	push	r15
    1e5e:	0f 93       	push	r16
    1e60:	1f 93       	push	r17
    1e62:	cf 93       	push	r28
    1e64:	df 93       	push	r29
    1e66:	cd b7       	in	r28, 0x3d	; 61
    1e68:	de b7       	in	r29, 0x3e	; 62
    1e6a:	3c 01       	movw	r6, r24
    1e6c:	fc 01       	movw	r30, r24
    1e6e:	11 82       	std	Z+1, r1	; 0x01
    1e70:	10 82       	st	Z, r1
    1e72:	12 82       	std	Z+2, r1	; 0x02
    1e74:	80 e8       	ldi	r24, 0x80	; 128
    1e76:	83 83       	std	Z+3, r24	; 0x03
    1e78:	14 82       	std	Z+4, r1	; 0x04
    1e7a:	15 82       	std	Z+5, r1	; 0x05
    1e7c:	88 e0       	ldi	r24, 0x08	; 8
    1e7e:	86 83       	std	Z+6, r24	; 0x06
    1e80:	17 82       	std	Z+7, r1	; 0x07
    1e82:	8f ef       	ldi	r24, 0xFF	; 255
    1e84:	9f ef       	ldi	r25, 0xFF	; 255
    1e86:	91 87       	std	Z+9, r25	; 0x09
    1e88:	80 87       	std	Z+8, r24	; 0x08
    1e8a:	13 86       	std	Z+11, r1	; 0x0b
    1e8c:	12 86       	std	Z+10, r1	; 0x0a
    1e8e:	44 87       	std	Z+12, r20	; 0x0c
    1e90:	55 87       	std	Z+13, r21	; 0x0d
    1e92:	66 87       	std	Z+14, r22	; 0x0e
    1e94:	77 87       	std	Z+15, r23	; 0x0f
    1e96:	00 8b       	std	Z+16, r16	; 0x10
    1e98:	11 8b       	std	Z+17, r17	; 0x11
    1e9a:	22 8b       	std	Z+18, r18	; 0x12
    1e9c:	33 8b       	std	Z+19, r19	; 0x13
    1e9e:	c4 8a       	std	Z+20, r12	; 0x14
    1ea0:	d5 8a       	std	Z+21, r13	; 0x15
    1ea2:	e6 8a       	std	Z+22, r14	; 0x16
    1ea4:	f7 8a       	std	Z+23, r15	; 0x17
    1ea6:	80 8e       	std	Z+24, r8	; 0x18
    1ea8:	91 8e       	std	Z+25, r9	; 0x19
    1eaa:	a2 8e       	std	Z+26, r10	; 0x1a
    1eac:	b3 8e       	std	Z+27, r11	; 0x1b
    1eae:	8c e0       	ldi	r24, 0x0C	; 12
    1eb0:	e4 e1       	ldi	r30, 0x14	; 20
    1eb2:	f1 e0       	ldi	r31, 0x01	; 1
    1eb4:	d3 01       	movw	r26, r6
    1eb6:	5c 96       	adiw	r26, 0x1c	; 28
    1eb8:	01 90       	ld	r0, Z+
    1eba:	0d 92       	st	X+, r0
    1ebc:	8a 95       	dec	r24
    1ebe:	e1 f7       	brne	.-8      	; 0x1eb8 <_ZN6ModuleC1Emmmm+0x6e>
    1ec0:	f3 01       	movw	r30, r6
    1ec2:	11 a6       	std	Z+41, r1	; 0x29
    1ec4:	10 a6       	std	Z+40, r1	; 0x28
  this->hal = new ArduinoHal();
    1ec6:	8f e1       	ldi	r24, 0x1F	; 31
    1ec8:	90 e0       	ldi	r25, 0x00	; 0
    1eca:	0e 94 22 0f 	call	0x1e44	; 0x1e44 <_Znwj>
    1ece:	8c 01       	movw	r16, r24
    1ed0:	0e 94 68 09 	call	0x12d0	; 0x12d0 <_ZN10ArduinoHalC1Ev>
    1ed4:	f3 01       	movw	r30, r6
    1ed6:	11 83       	std	Z+1, r17	; 0x01
    1ed8:	00 83       	st	Z, r16
}
    1eda:	df 91       	pop	r29
    1edc:	cf 91       	pop	r28
    1ede:	1f 91       	pop	r17
    1ee0:	0f 91       	pop	r16
    1ee2:	ff 90       	pop	r15
    1ee4:	ef 90       	pop	r14
    1ee6:	df 90       	pop	r13
    1ee8:	cf 90       	pop	r12
    1eea:	bf 90       	pop	r11
    1eec:	af 90       	pop	r10
    1eee:	9f 90       	pop	r9
    1ef0:	8f 90       	pop	r8
    1ef2:	7f 90       	pop	r7
    1ef4:	6f 90       	pop	r6
    1ef6:	08 95       	ret

00001ef8 <__cxa_pure_virtual>:
extern "C" void __cxa_deleted_virtual(void) __attribute__ ((__noreturn__));

void __cxa_pure_virtual(void) {
  // We might want to write some diagnostics to uart in this case
  //std::terminate();
  abort();
    1ef8:	0e 94 b8 3e 	call	0x7d70	; 0x7d70 <abort>

00001efc <_ZN5Print5writeEPKc>:
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }
  
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
    1efc:	61 15       	cp	r22, r1
    1efe:	71 05       	cpc	r23, r1
    1f00:	81 f0       	breq	.+32     	; 0x1f22 <_ZN5Print5writeEPKc+0x26>
      return write((const uint8_t *)str, strlen(str));
    1f02:	fb 01       	movw	r30, r22
    1f04:	01 90       	ld	r0, Z+
    1f06:	00 20       	and	r0, r0
    1f08:	e9 f7       	brne	.-6      	; 0x1f04 <_ZN5Print5writeEPKc+0x8>
    1f0a:	31 97       	sbiw	r30, 0x01	; 1
    1f0c:	af 01       	movw	r20, r30
    1f0e:	46 1b       	sub	r20, r22
    1f10:	57 0b       	sbc	r21, r23
    1f12:	dc 01       	movw	r26, r24
    1f14:	ed 91       	ld	r30, X+
    1f16:	fc 91       	ld	r31, X
    1f18:	02 80       	ldd	r0, Z+2	; 0x02
    1f1a:	f3 81       	ldd	r31, Z+3	; 0x03
    1f1c:	e0 2d       	mov	r30, r0
    1f1e:	09 95       	icall
    1f20:	08 95       	ret
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }
  
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
    1f22:	90 e0       	ldi	r25, 0x00	; 0
    1f24:	80 e0       	ldi	r24, 0x00	; 0
      return write((const uint8_t *)str, strlen(str));
    }
    1f26:	08 95       	ret

00001f28 <_ZN5Print7printlnEv>:
  return x.printTo(*this);
}

size_t Print::println(void)
{
  return write("\r\n");
    1f28:	60 ea       	ldi	r22, 0xA0	; 160
    1f2a:	72 e0       	ldi	r23, 0x02	; 2
    1f2c:	0e 94 7e 0f 	call	0x1efc	; 0x1efc <_ZN5Print5writeEPKc>
}
    1f30:	08 95       	ret

00001f32 <_ZN5Print7printlnERK9Printable>:
  n += println();
  return n;
}

size_t Print::println(const Printable& x)
{
    1f32:	0f 93       	push	r16
    1f34:	1f 93       	push	r17
    1f36:	cf 93       	push	r28
    1f38:	df 93       	push	r29
    1f3a:	ec 01       	movw	r28, r24
  size_t n = print(x);
    1f3c:	0e 94 05 05 	call	0xa0a	; 0xa0a <_ZN5Print5printERK9Printable>
    1f40:	8c 01       	movw	r16, r24
  n += println();
    1f42:	ce 01       	movw	r24, r28
    1f44:	0e 94 94 0f 	call	0x1f28	; 0x1f28 <_ZN5Print7printlnEv>
  return n;
}
    1f48:	80 0f       	add	r24, r16
    1f4a:	91 1f       	adc	r25, r17
    1f4c:	df 91       	pop	r29
    1f4e:	cf 91       	pop	r28
    1f50:	1f 91       	pop	r17
    1f52:	0f 91       	pop	r16
    1f54:	08 95       	ret

00001f56 <_ZN5Print11printNumberEmh>:

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base)
{
    1f56:	df 92       	push	r13
    1f58:	ef 92       	push	r14
    1f5a:	ff 92       	push	r15
    1f5c:	0f 93       	push	r16
    1f5e:	1f 93       	push	r17
    1f60:	cf 93       	push	r28
    1f62:	df 93       	push	r29
    1f64:	cd b7       	in	r28, 0x3d	; 61
    1f66:	de b7       	in	r29, 0x3e	; 62
    1f68:	a1 97       	sbiw	r28, 0x21	; 33
    1f6a:	0f b6       	in	r0, 0x3f	; 63
    1f6c:	f8 94       	cli
    1f6e:	de bf       	out	0x3e, r29	; 62
    1f70:	0f be       	out	0x3f, r0	; 63
    1f72:	cd bf       	out	0x3d, r28	; 61
    1f74:	7c 01       	movw	r14, r24
    1f76:	cb 01       	movw	r24, r22
    1f78:	ba 01       	movw	r22, r20
    1f7a:	d2 2e       	mov	r13, r18
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
    1f7c:	19 a2       	std	Y+33, r1	; 0x21

  // prevent crash if called with base == 1
  if (base < 2) base = 10;
    1f7e:	21 e0       	ldi	r18, 0x01	; 1
    1f80:	2d 15       	cp	r18, r13
    1f82:	20 f4       	brcc	.+8      	; 0x1f8c <_ZN5Print11printNumberEmh+0x36>
    1f84:	8e 01       	movw	r16, r28
    1f86:	0f 5d       	subi	r16, 0xDF	; 223
    1f88:	1f 4f       	sbci	r17, 0xFF	; 255
    1f8a:	0e c0       	rjmp	.+28     	; 0x1fa8 <_ZN5Print11printNumberEmh+0x52>
    1f8c:	0f 2e       	mov	r0, r31
    1f8e:	fa e0       	ldi	r31, 0x0A	; 10
    1f90:	df 2e       	mov	r13, r31
    1f92:	f0 2d       	mov	r31, r0
    1f94:	f7 cf       	rjmp	.-18     	; 0x1f84 <_ZN5Print11printNumberEmh+0x2e>

  do {
    char c = n % base;
    n /= base;

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
    1f96:	e9 5c       	subi	r30, 0xC9	; 201
    1f98:	d8 01       	movw	r26, r16
    1f9a:	ee 93       	st	-X, r30
    1f9c:	8d 01       	movw	r16, r26
  } while(n);
    1f9e:	61 15       	cp	r22, r1
    1fa0:	71 05       	cpc	r23, r1
    1fa2:	81 05       	cpc	r24, r1
    1fa4:	91 05       	cpc	r25, r1
    1fa6:	79 f0       	breq	.+30     	; 0x1fc6 <_ZN5Print11printNumberEmh+0x70>

  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
    char c = n % base;
    1fa8:	2d 2d       	mov	r18, r13
    1faa:	30 e0       	ldi	r19, 0x00	; 0
    1fac:	50 e0       	ldi	r21, 0x00	; 0
    1fae:	40 e0       	ldi	r20, 0x00	; 0
    1fb0:	0e 94 10 3b 	call	0x7620	; 0x7620 <__udivmodsi4>
    1fb4:	e6 2f       	mov	r30, r22
    n /= base;
    1fb6:	62 2f       	mov	r22, r18
    1fb8:	73 2f       	mov	r23, r19
    1fba:	84 2f       	mov	r24, r20
    1fbc:	95 2f       	mov	r25, r21

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
    1fbe:	ea 30       	cpi	r30, 0x0A	; 10
    1fc0:	54 f7       	brge	.-44     	; 0x1f96 <_ZN5Print11printNumberEmh+0x40>
    1fc2:	e0 5d       	subi	r30, 0xD0	; 208
    1fc4:	e9 cf       	rjmp	.-46     	; 0x1f98 <_ZN5Print11printNumberEmh+0x42>
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }
  
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
    1fc6:	10 97       	sbiw	r26, 0x00	; 0
    1fc8:	f9 f0       	breq	.+62     	; 0x2008 <_ZN5Print11printNumberEmh+0xb2>
      return write((const uint8_t *)str, strlen(str));
    1fca:	fd 01       	movw	r30, r26
    1fcc:	01 90       	ld	r0, Z+
    1fce:	00 20       	and	r0, r0
    1fd0:	e9 f7       	brne	.-6      	; 0x1fcc <_ZN5Print11printNumberEmh+0x76>
    1fd2:	31 97       	sbiw	r30, 0x01	; 1
    1fd4:	af 01       	movw	r20, r30
    1fd6:	4a 1b       	sub	r20, r26
    1fd8:	5b 0b       	sbc	r21, r27
    1fda:	d7 01       	movw	r26, r14
    1fdc:	ed 91       	ld	r30, X+
    1fde:	fc 91       	ld	r31, X
    1fe0:	02 80       	ldd	r0, Z+2	; 0x02
    1fe2:	f3 81       	ldd	r31, Z+3	; 0x03
    1fe4:	e0 2d       	mov	r30, r0
    1fe6:	b8 01       	movw	r22, r16
    1fe8:	c7 01       	movw	r24, r14
    1fea:	09 95       	icall
  } while(n);

  return write(str);
}
    1fec:	a1 96       	adiw	r28, 0x21	; 33
    1fee:	0f b6       	in	r0, 0x3f	; 63
    1ff0:	f8 94       	cli
    1ff2:	de bf       	out	0x3e, r29	; 62
    1ff4:	0f be       	out	0x3f, r0	; 63
    1ff6:	cd bf       	out	0x3d, r28	; 61
    1ff8:	df 91       	pop	r29
    1ffa:	cf 91       	pop	r28
    1ffc:	1f 91       	pop	r17
    1ffe:	0f 91       	pop	r16
    2000:	ff 90       	pop	r15
    2002:	ef 90       	pop	r14
    2004:	df 90       	pop	r13
    2006:	08 95       	ret
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }
  
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
    2008:	90 e0       	ldi	r25, 0x00	; 0
    200a:	80 e0       	ldi	r24, 0x00	; 0
    200c:	ef cf       	rjmp	.-34     	; 0x1fec <_ZN5Print11printNumberEmh+0x96>

0000200e <_ZN5Print5printEmi>:
  }
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
    200e:	21 15       	cp	r18, r1
    2010:	31 05       	cpc	r19, r1
    2012:	49 f4       	brne	.+18     	; 0x2026 <_ZN5Print5printEmi+0x18>
    2014:	dc 01       	movw	r26, r24
    2016:	ed 91       	ld	r30, X+
    2018:	fc 91       	ld	r31, X
    201a:	01 90       	ld	r0, Z+
    201c:	f0 81       	ld	r31, Z
    201e:	e0 2d       	mov	r30, r0
    2020:	64 2f       	mov	r22, r20
    2022:	09 95       	icall
    2024:	08 95       	ret
  else return printNumber(n, base);
    2026:	0e 94 ab 0f 	call	0x1f56	; 0x1f56 <_ZN5Print11printNumberEmh>
}
    202a:	08 95       	ret

0000202c <_ZN5Print5printEji>:
{
  return print((long) n, base);
}

size_t Print::print(unsigned int n, int base)
{
    202c:	9a 01       	movw	r18, r20
  return print((unsigned long) n, base);
    202e:	ab 01       	movw	r20, r22
    2030:	70 e0       	ldi	r23, 0x00	; 0
    2032:	60 e0       	ldi	r22, 0x00	; 0
    2034:	0e 94 07 10 	call	0x200e	; 0x200e <_ZN5Print5printEmi>
}
    2038:	08 95       	ret

0000203a <_ZN5Print5printEPKc>:
    203a:	61 15       	cp	r22, r1
    203c:	71 05       	cpc	r23, r1
    203e:	81 f0       	breq	.+32     	; 0x2060 <_ZN5Print5printEPKc+0x26>
      return write((const uint8_t *)str, strlen(str));
    2040:	fb 01       	movw	r30, r22
    2042:	01 90       	ld	r0, Z+
    2044:	00 20       	and	r0, r0
    2046:	e9 f7       	brne	.-6      	; 0x2042 <_ZN5Print5printEPKc+0x8>
    2048:	31 97       	sbiw	r30, 0x01	; 1
    204a:	af 01       	movw	r20, r30
    204c:	46 1b       	sub	r20, r22
    204e:	57 0b       	sbc	r21, r23
    2050:	dc 01       	movw	r26, r24
    2052:	ed 91       	ld	r30, X+
    2054:	fc 91       	ld	r31, X
    2056:	02 80       	ldd	r0, Z+2	; 0x02
    2058:	f3 81       	ldd	r31, Z+3	; 0x03
    205a:	e0 2d       	mov	r30, r0
    205c:	09 95       	icall
    205e:	08 95       	ret
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }
  
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
    2060:	90 e0       	ldi	r25, 0x00	; 0
    2062:	80 e0       	ldi	r24, 0x00	; 0
}

size_t Print::print(const char str[])
{
  return write(str);
}
    2064:	08 95       	ret

00002066 <_ZN5Print7printlnEPKc>:
  n += println();
  return n;
}

size_t Print::println(const char c[])
{
    2066:	0f 93       	push	r16
    2068:	1f 93       	push	r17
    206a:	cf 93       	push	r28
    206c:	df 93       	push	r29
    206e:	ec 01       	movw	r28, r24
  size_t n = print(c);
    2070:	0e 94 1d 10 	call	0x203a	; 0x203a <_ZN5Print5printEPKc>
    2074:	8c 01       	movw	r16, r24
  n += println();
    2076:	ce 01       	movw	r24, r28
    2078:	0e 94 94 0f 	call	0x1f28	; 0x1f28 <_ZN5Print7printlnEv>
  return n;
}
    207c:	80 0f       	add	r24, r16
    207e:	91 1f       	adc	r25, r17
    2080:	df 91       	pop	r29
    2082:	cf 91       	pop	r28
    2084:	1f 91       	pop	r17
    2086:	0f 91       	pop	r16
    2088:	08 95       	ret

0000208a <_ZNK3gel5Error7printToER5Print>:

namespace gel
{

size_t Error::printTo(Print& p) const
{
    208a:	ef 92       	push	r14
    208c:	ff 92       	push	r15
    208e:	0f 93       	push	r16
    2090:	1f 93       	push	r17
    2092:	cf 93       	push	r28
    2094:	df 93       	push	r29
    2096:	7c 01       	movw	r14, r24
    2098:	8b 01       	movw	r16, r22
    size_t n = 0;
    n += p.print("Code: ");
    209a:	63 ea       	ldi	r22, 0xA3	; 163
    209c:	72 e0       	ldi	r23, 0x02	; 2
    209e:	c8 01       	movw	r24, r16
    20a0:	0e 94 1d 10 	call	0x203a	; 0x203a <_ZN5Print5printEPKc>
    20a4:	ec 01       	movw	r28, r24
    n += p.print(static_cast<size_t>(code));
    20a6:	f7 01       	movw	r30, r14
    20a8:	62 81       	ldd	r22, Z+2	; 0x02
    20aa:	73 81       	ldd	r23, Z+3	; 0x03
    20ac:	4a e0       	ldi	r20, 0x0A	; 10
    20ae:	50 e0       	ldi	r21, 0x00	; 0
    20b0:	c8 01       	movw	r24, r16
    20b2:	0e 94 16 10 	call	0x202c	; 0x202c <_ZN5Print5printEji>
    20b6:	c8 0f       	add	r28, r24
    20b8:	d9 1f       	adc	r29, r25
    if (message)
    20ba:	f7 01       	movw	r30, r14
    20bc:	64 81       	ldd	r22, Z+4	; 0x04
    20be:	75 81       	ldd	r23, Z+5	; 0x05
    20c0:	61 15       	cp	r22, r1
    20c2:	71 05       	cpc	r23, r1
    20c4:	29 f0       	breq	.+10     	; 0x20d0 <_ZNK3gel5Error7printToER5Print+0x46>
    {
        n += p.print(message);
    20c6:	c8 01       	movw	r24, r16
    20c8:	0e 94 1d 10 	call	0x203a	; 0x203a <_ZN5Print5printEPKc>
    20cc:	c8 0f       	add	r28, r24
    20ce:	d9 1f       	adc	r29, r25
    }

    return n;
}
    20d0:	ce 01       	movw	r24, r28
    20d2:	df 91       	pop	r29
    20d4:	cf 91       	pop	r28
    20d6:	1f 91       	pop	r17
    20d8:	0f 91       	pop	r16
    20da:	ff 90       	pop	r15
    20dc:	ef 90       	pop	r14
    20de:	08 95       	ret

000020e0 <_Z11handleErrorN3gel5ErrorEPKcb>:

    return gel::Error::None;
}

void handleError(gel::Error err, const char* msg = nullptr, bool critical = false)
{
    20e0:	ec 01       	movw	r28, r24
    Serial.print(msg);
    20e2:	80 ee       	ldi	r24, 0xE0	; 224
    20e4:	96 e0       	ldi	r25, 0x06	; 6
    20e6:	0e 94 1d 10 	call	0x203a	; 0x203a <_ZN5Print5printEPKc>
    Serial.print("Error: ");
    20ea:	6a ea       	ldi	r22, 0xAA	; 170
    20ec:	72 e0       	ldi	r23, 0x02	; 2
    20ee:	80 ee       	ldi	r24, 0xE0	; 224
    20f0:	96 e0       	ldi	r25, 0x06	; 6
    20f2:	0e 94 1d 10 	call	0x203a	; 0x203a <_ZN5Print5printEPKc>
    Serial.println(err);
    20f6:	be 01       	movw	r22, r28
    20f8:	80 ee       	ldi	r24, 0xE0	; 224
    20fa:	96 e0       	ldi	r25, 0x06	; 6
    20fc:	0e 94 99 0f 	call	0x1f32	; 0x1f32 <_ZN5Print7printlnERK9Printable>
    2100:	ff cf       	rjmp	.-2      	; 0x2100 <_Z11handleErrorN3gel5ErrorEPKcb+0x20>

00002102 <_ZN6String4moveERS_>:
	return *this;
}

#if __cplusplus >= 201103L || defined(__GXX_EXPERIMENTAL_CXX0X__)
void String::move(String &rhs)
{
    2102:	0f 93       	push	r16
    2104:	1f 93       	push	r17
    2106:	cf 93       	push	r28
    2108:	df 93       	push	r29
    210a:	8c 01       	movw	r16, r24
    210c:	eb 01       	movw	r28, r22
	if (buffer) {
    210e:	fc 01       	movw	r30, r24
    2110:	80 81       	ld	r24, Z
    2112:	91 81       	ldd	r25, Z+1	; 0x01
    2114:	89 2b       	or	r24, r25
    2116:	b1 f0       	breq	.+44     	; 0x2144 <_ZN6String4moveERS_+0x42>
	friend StringSumHelper & operator + (const StringSumHelper &lhs, float num);
	friend StringSumHelper & operator + (const StringSumHelper &lhs, double num);
	friend StringSumHelper & operator + (const StringSumHelper &lhs, const __FlashStringHelper *rhs);

	// comparison (only works w/ Strings and "strings")
	operator StringIfHelperType() const { return buffer ? &String::StringIfHelper : 0; }
    2118:	88 81       	ld	r24, Y
    211a:	99 81       	ldd	r25, Y+1	; 0x01
    211c:	89 2b       	or	r24, r25
    211e:	51 f1       	breq	.+84     	; 0x2174 <_ZN6String4moveERS_+0x72>
    2120:	8a e5       	ldi	r24, 0x5A	; 90
    2122:	92 e0       	ldi	r25, 0x02	; 2
    2124:	a0 e0       	ldi	r26, 0x00	; 0
		if (rhs && capacity >= rhs.len) {
    2126:	89 2b       	or	r24, r25
    2128:	49 f1       	breq	.+82     	; 0x217c <_ZN6String4moveERS_+0x7a>
    212a:	f8 01       	movw	r30, r16
    212c:	22 81       	ldd	r18, Z+2	; 0x02
    212e:	33 81       	ldd	r19, Z+3	; 0x03
    2130:	8c 81       	ldd	r24, Y+4	; 0x04
    2132:	9d 81       	ldd	r25, Y+5	; 0x05
    2134:	28 17       	cp	r18, r24
    2136:	39 07       	cpc	r19, r25
    2138:	20 f5       	brcc	.+72     	; 0x2182 <_ZN6String4moveERS_+0x80>
			strcpy(buffer, rhs.buffer);
			len = rhs.len;
			rhs.len = 0;
			return;
		} else {
			free(buffer);
    213a:	f8 01       	movw	r30, r16
    213c:	80 81       	ld	r24, Z
    213e:	91 81       	ldd	r25, Z+1	; 0x01
    2140:	0e 94 72 3d 	call	0x7ae4	; 0x7ae4 <free>
		}
	}
	buffer = rhs.buffer;
    2144:	88 81       	ld	r24, Y
    2146:	99 81       	ldd	r25, Y+1	; 0x01
    2148:	f8 01       	movw	r30, r16
    214a:	91 83       	std	Z+1, r25	; 0x01
    214c:	80 83       	st	Z, r24
	capacity = rhs.capacity;
    214e:	8a 81       	ldd	r24, Y+2	; 0x02
    2150:	9b 81       	ldd	r25, Y+3	; 0x03
    2152:	93 83       	std	Z+3, r25	; 0x03
    2154:	82 83       	std	Z+2, r24	; 0x02
	len = rhs.len;
    2156:	8c 81       	ldd	r24, Y+4	; 0x04
    2158:	9d 81       	ldd	r25, Y+5	; 0x05
    215a:	95 83       	std	Z+5, r25	; 0x05
    215c:	84 83       	std	Z+4, r24	; 0x04
	rhs.buffer = NULL;
    215e:	19 82       	std	Y+1, r1	; 0x01
    2160:	18 82       	st	Y, r1
	rhs.capacity = 0;
    2162:	1b 82       	std	Y+3, r1	; 0x03
    2164:	1a 82       	std	Y+2, r1	; 0x02
	rhs.len = 0;
    2166:	1d 82       	std	Y+5, r1	; 0x05
    2168:	1c 82       	std	Y+4, r1	; 0x04
}
    216a:	df 91       	pop	r29
    216c:	cf 91       	pop	r28
    216e:	1f 91       	pop	r17
    2170:	0f 91       	pop	r16
    2172:	08 95       	ret
    2174:	80 e0       	ldi	r24, 0x00	; 0
    2176:	90 e0       	ldi	r25, 0x00	; 0
    2178:	dc 01       	movw	r26, r24
    217a:	d5 cf       	rjmp	.-86     	; 0x2126 <_ZN6String4moveERS_+0x24>

#if __cplusplus >= 201103L || defined(__GXX_EXPERIMENTAL_CXX0X__)
void String::move(String &rhs)
{
	if (buffer) {
		if (rhs && capacity >= rhs.len) {
    217c:	a0 ff       	sbrs	r26, 0
    217e:	dd cf       	rjmp	.-70     	; 0x213a <_ZN6String4moveERS_+0x38>
    2180:	d4 cf       	rjmp	.-88     	; 0x212a <_ZN6String4moveERS_+0x28>
			strcpy(buffer, rhs.buffer);
    2182:	68 81       	ld	r22, Y
    2184:	79 81       	ldd	r23, Y+1	; 0x01
    2186:	80 81       	ld	r24, Z
    2188:	91 81       	ldd	r25, Z+1	; 0x01
    218a:	0e 94 cd 3e 	call	0x7d9a	; 0x7d9a <strcpy>
			len = rhs.len;
    218e:	8c 81       	ldd	r24, Y+4	; 0x04
    2190:	9d 81       	ldd	r25, Y+5	; 0x05
    2192:	f8 01       	movw	r30, r16
    2194:	95 83       	std	Z+5, r25	; 0x05
    2196:	84 83       	std	Z+4, r24	; 0x04
			rhs.len = 0;
    2198:	1d 82       	std	Y+5, r1	; 0x05
    219a:	1c 82       	std	Y+4, r1	; 0x04
    219c:	e6 cf       	rjmp	.-52     	; 0x216a <_ZN6String4moveERS_+0x68>

0000219e <_ZN6StringaSEOS_>:
	return *this;
}

#if __cplusplus >= 201103L || defined(__GXX_EXPERIMENTAL_CXX0X__)
String & String::operator = (String &&rval)
{
    219e:	cf 93       	push	r28
    21a0:	df 93       	push	r29
    21a2:	ec 01       	movw	r28, r24
	if (this != &rval) move(rval);
    21a4:	86 17       	cp	r24, r22
    21a6:	97 07       	cpc	r25, r23
    21a8:	11 f0       	breq	.+4      	; 0x21ae <_ZN6StringaSEOS_+0x10>
    21aa:	0e 94 81 10 	call	0x2102	; 0x2102 <_ZN6String4moveERS_>
	return *this;
}
    21ae:	ce 01       	movw	r24, r28
    21b0:	df 91       	pop	r29
    21b2:	cf 91       	pop	r28
    21b4:	08 95       	ret

000021b6 <_ZN6StringC1EOS_>:
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    21b6:	fc 01       	movw	r30, r24
    21b8:	11 82       	std	Z+1, r1	; 0x01
    21ba:	10 82       	st	Z, r1
	capacity = 0;
    21bc:	13 82       	std	Z+3, r1	; 0x03
    21be:	12 82       	std	Z+2, r1	; 0x02
	len = 0;
    21c0:	15 82       	std	Z+5, r1	; 0x05
    21c2:	14 82       	std	Z+4, r1	; 0x04

#if __cplusplus >= 201103L || defined(__GXX_EXPERIMENTAL_CXX0X__)
String::String(String &&rval)
{
	init();
	move(rval);
    21c4:	0e 94 81 10 	call	0x2102	; 0x2102 <_ZN6String4moveERS_>
}
    21c8:	08 95       	ret

000021ca <_ZN6String12changeBufferEj>:
	}
	return 0;
}

unsigned char String::changeBuffer(unsigned int maxStrLen)
{
    21ca:	0f 93       	push	r16
    21cc:	1f 93       	push	r17
    21ce:	cf 93       	push	r28
    21d0:	df 93       	push	r29
    21d2:	ec 01       	movw	r28, r24
    21d4:	8b 01       	movw	r16, r22
	char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
    21d6:	6f 5f       	subi	r22, 0xFF	; 255
    21d8:	7f 4f       	sbci	r23, 0xFF	; 255
    21da:	88 81       	ld	r24, Y
    21dc:	99 81       	ldd	r25, Y+1	; 0x01
    21de:	0e 94 fb 3d 	call	0x7bf6	; 0x7bf6 <realloc>
	if (newbuffer) {
    21e2:	00 97       	sbiw	r24, 0x00	; 0
    21e4:	51 f0       	breq	.+20     	; 0x21fa <_ZN6String12changeBufferEj+0x30>
		buffer = newbuffer;
    21e6:	99 83       	std	Y+1, r25	; 0x01
    21e8:	88 83       	st	Y, r24
		capacity = maxStrLen;
    21ea:	1b 83       	std	Y+3, r17	; 0x03
    21ec:	0a 83       	std	Y+2, r16	; 0x02
		return 1;
    21ee:	81 e0       	ldi	r24, 0x01	; 1
	}
	return 0;
}
    21f0:	df 91       	pop	r29
    21f2:	cf 91       	pop	r28
    21f4:	1f 91       	pop	r17
    21f6:	0f 91       	pop	r16
    21f8:	08 95       	ret
	if (newbuffer) {
		buffer = newbuffer;
		capacity = maxStrLen;
		return 1;
	}
	return 0;
    21fa:	80 e0       	ldi	r24, 0x00	; 0
    21fc:	f9 cf       	rjmp	.-14     	; 0x21f0 <_ZN6String12changeBufferEj+0x26>

000021fe <_ZN6String7reserveEj>:
	buffer = NULL;
	capacity = len = 0;
}

unsigned char String::reserve(unsigned int size)
{
    21fe:	cf 93       	push	r28
    2200:	df 93       	push	r29
    2202:	ec 01       	movw	r28, r24
	if (buffer && capacity >= size) return 1;
    2204:	28 81       	ld	r18, Y
    2206:	39 81       	ldd	r19, Y+1	; 0x01
    2208:	23 2b       	or	r18, r19
    220a:	29 f0       	breq	.+10     	; 0x2216 <_ZN6String7reserveEj+0x18>
    220c:	2a 81       	ldd	r18, Y+2	; 0x02
    220e:	3b 81       	ldd	r19, Y+3	; 0x03
    2210:	26 17       	cp	r18, r22
    2212:	37 07       	cpc	r19, r23
    2214:	70 f4       	brcc	.+28     	; 0x2232 <_ZN6String7reserveEj+0x34>
	if (changeBuffer(size)) {
    2216:	ce 01       	movw	r24, r28
    2218:	0e 94 e5 10 	call	0x21ca	; 0x21ca <_ZN6String12changeBufferEj>
    221c:	88 23       	and	r24, r24
    221e:	51 f0       	breq	.+20     	; 0x2234 <_ZN6String7reserveEj+0x36>
		if (len == 0) buffer[0] = 0;
    2220:	8c 81       	ldd	r24, Y+4	; 0x04
    2222:	9d 81       	ldd	r25, Y+5	; 0x05
    2224:	89 2b       	or	r24, r25
    2226:	49 f4       	brne	.+18     	; 0x223a <_ZN6String7reserveEj+0x3c>
    2228:	e8 81       	ld	r30, Y
    222a:	f9 81       	ldd	r31, Y+1	; 0x01
    222c:	10 82       	st	Z, r1
		return 1;
    222e:	81 e0       	ldi	r24, 0x01	; 1
    2230:	01 c0       	rjmp	.+2      	; 0x2234 <_ZN6String7reserveEj+0x36>
	capacity = len = 0;
}

unsigned char String::reserve(unsigned int size)
{
	if (buffer && capacity >= size) return 1;
    2232:	81 e0       	ldi	r24, 0x01	; 1
	if (changeBuffer(size)) {
		if (len == 0) buffer[0] = 0;
		return 1;
	}
	return 0;
}
    2234:	df 91       	pop	r29
    2236:	cf 91       	pop	r28
    2238:	08 95       	ret
unsigned char String::reserve(unsigned int size)
{
	if (buffer && capacity >= size) return 1;
	if (changeBuffer(size)) {
		if (len == 0) buffer[0] = 0;
		return 1;
    223a:	81 e0       	ldi	r24, 0x01	; 1
    223c:	fb cf       	rjmp	.-10     	; 0x2234 <_ZN6String7reserveEj+0x36>

0000223e <_ZN6String6concatEPKcj>:
{
	return concat(s.buffer, s.len);
}

unsigned char String::concat(const char *cstr, unsigned int length)
{
    223e:	ef 92       	push	r14
    2240:	ff 92       	push	r15
    2242:	0f 93       	push	r16
    2244:	1f 93       	push	r17
    2246:	cf 93       	push	r28
    2248:	df 93       	push	r29
	unsigned int newlen = len + length;
    224a:	fc 01       	movw	r30, r24
    224c:	c4 81       	ldd	r28, Z+4	; 0x04
    224e:	d5 81       	ldd	r29, Z+5	; 0x05
    2250:	c4 0f       	add	r28, r20
    2252:	d5 1f       	adc	r29, r21
	if (!cstr) return 0;
    2254:	61 15       	cp	r22, r1
    2256:	71 05       	cpc	r23, r1
    2258:	01 f1       	breq	.+64     	; 0x229a <_ZN6String6concatEPKcj+0x5c>
	if (length == 0) return 1;
    225a:	45 2b       	or	r20, r21
    225c:	41 f4       	brne	.+16     	; 0x226e <_ZN6String6concatEPKcj+0x30>
    225e:	81 e0       	ldi	r24, 0x01	; 1
	if (!reserve(newlen)) return 0;
	strcpy(buffer + len, cstr);
	len = newlen;
	return 1;
}
    2260:	df 91       	pop	r29
    2262:	cf 91       	pop	r28
    2264:	1f 91       	pop	r17
    2266:	0f 91       	pop	r16
    2268:	ff 90       	pop	r15
    226a:	ef 90       	pop	r14
    226c:	08 95       	ret
    226e:	7b 01       	movw	r14, r22
    2270:	8c 01       	movw	r16, r24
unsigned char String::concat(const char *cstr, unsigned int length)
{
	unsigned int newlen = len + length;
	if (!cstr) return 0;
	if (length == 0) return 1;
	if (!reserve(newlen)) return 0;
    2272:	be 01       	movw	r22, r28
    2274:	0e 94 ff 10 	call	0x21fe	; 0x21fe <_ZN6String7reserveEj>
    2278:	88 23       	and	r24, r24
    227a:	91 f3       	breq	.-28     	; 0x2260 <_ZN6String6concatEPKcj+0x22>
	strcpy(buffer + len, cstr);
    227c:	f8 01       	movw	r30, r16
    227e:	20 81       	ld	r18, Z
    2280:	31 81       	ldd	r19, Z+1	; 0x01
    2282:	84 81       	ldd	r24, Z+4	; 0x04
    2284:	95 81       	ldd	r25, Z+5	; 0x05
    2286:	b7 01       	movw	r22, r14
    2288:	82 0f       	add	r24, r18
    228a:	93 1f       	adc	r25, r19
    228c:	0e 94 cd 3e 	call	0x7d9a	; 0x7d9a <strcpy>
	len = newlen;
    2290:	f8 01       	movw	r30, r16
    2292:	d5 83       	std	Z+5, r29	; 0x05
    2294:	c4 83       	std	Z+4, r28	; 0x04
	return 1;
    2296:	81 e0       	ldi	r24, 0x01	; 1
    2298:	e3 cf       	rjmp	.-58     	; 0x2260 <_ZN6String6concatEPKcj+0x22>
}

unsigned char String::concat(const char *cstr, unsigned int length)
{
	unsigned int newlen = len + length;
	if (!cstr) return 0;
    229a:	80 e0       	ldi	r24, 0x00	; 0
    229c:	e1 cf       	rjmp	.-62     	; 0x2260 <_ZN6String6concatEPKcj+0x22>

0000229e <_ZplRK15StringSumHelperPKc>:
	if (!a.concat(rhs.buffer, rhs.len)) a.invalidate();
	return a;
}

StringSumHelper & operator + (const StringSumHelper &lhs, const char *cstr)
{
    229e:	cf 93       	push	r28
    22a0:	df 93       	push	r29
    22a2:	ec 01       	movw	r28, r24
	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
	if (!cstr || !a.concat(cstr, strlen(cstr))) a.invalidate();
    22a4:	61 15       	cp	r22, r1
    22a6:	71 05       	cpc	r23, r1
    22a8:	61 f0       	breq	.+24     	; 0x22c2 <_ZplRK15StringSumHelperPKc+0x24>
    22aa:	fb 01       	movw	r30, r22
    22ac:	01 90       	ld	r0, Z+
    22ae:	00 20       	and	r0, r0
    22b0:	e9 f7       	brne	.-6      	; 0x22ac <_ZplRK15StringSumHelperPKc+0xe>
    22b2:	31 97       	sbiw	r30, 0x01	; 1
    22b4:	af 01       	movw	r20, r30
    22b6:	46 1b       	sub	r20, r22
    22b8:	57 0b       	sbc	r21, r23
    22ba:	0e 94 1f 11 	call	0x223e	; 0x223e <_ZN6String6concatEPKcj>
    22be:	81 11       	cpse	r24, r1
    22c0:	03 c0       	rjmp	.+6      	; 0x22c8 <_ZplRK15StringSumHelperPKc+0x2a>
    22c2:	ce 01       	movw	r24, r28
    22c4:	0e 94 05 0f 	call	0x1e0a	; 0x1e0a <_ZN6String10invalidateEv>
	return a;
}
    22c8:	ce 01       	movw	r24, r28
    22ca:	df 91       	pop	r29
    22cc:	cf 91       	pop	r28
    22ce:	08 95       	ret

000022d0 <_ZplRK15StringSumHelperRK6String>:
/*********************************************/
/*  Concatenate                              */
/*********************************************/

StringSumHelper & operator + (const StringSumHelper &lhs, const String &rhs)
{
    22d0:	cf 93       	push	r28
    22d2:	df 93       	push	r29
    22d4:	ec 01       	movw	r28, r24
	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
	if (!a.concat(rhs.buffer, rhs.len)) a.invalidate();
    22d6:	fb 01       	movw	r30, r22
    22d8:	44 81       	ldd	r20, Z+4	; 0x04
    22da:	55 81       	ldd	r21, Z+5	; 0x05
    22dc:	60 81       	ld	r22, Z
    22de:	71 81       	ldd	r23, Z+1	; 0x01
    22e0:	0e 94 1f 11 	call	0x223e	; 0x223e <_ZN6String6concatEPKcj>
    22e4:	88 23       	and	r24, r24
    22e6:	21 f0       	breq	.+8      	; 0x22f0 <_ZplRK15StringSumHelperRK6String+0x20>
	return a;
}
    22e8:	ce 01       	movw	r24, r28
    22ea:	df 91       	pop	r29
    22ec:	cf 91       	pop	r28
    22ee:	08 95       	ret
/*********************************************/

StringSumHelper & operator + (const StringSumHelper &lhs, const String &rhs)
{
	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
	if (!a.concat(rhs.buffer, rhs.len)) a.invalidate();
    22f0:	ce 01       	movw	r24, r28
    22f2:	0e 94 05 0f 	call	0x1e0a	; 0x1e0a <_ZN6String10invalidateEv>
    22f6:	f8 cf       	rjmp	.-16     	; 0x22e8 <_ZplRK15StringSumHelperRK6String+0x18>

000022f8 <_ZN6String4copyEPKcj>:
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
    22f8:	ef 92       	push	r14
    22fa:	ff 92       	push	r15
    22fc:	0f 93       	push	r16
    22fe:	1f 93       	push	r17
    2300:	cf 93       	push	r28
    2302:	df 93       	push	r29
    2304:	ec 01       	movw	r28, r24
    2306:	7b 01       	movw	r14, r22
    2308:	8a 01       	movw	r16, r20
	if (!reserve(length)) {
    230a:	ba 01       	movw	r22, r20
    230c:	0e 94 ff 10 	call	0x21fe	; 0x21fe <_ZN6String7reserveEj>
    2310:	88 23       	and	r24, r24
    2312:	79 f0       	breq	.+30     	; 0x2332 <_ZN6String4copyEPKcj+0x3a>
		invalidate();
		return *this;
	}
	len = length;
    2314:	1d 83       	std	Y+5, r17	; 0x05
    2316:	0c 83       	std	Y+4, r16	; 0x04
	strcpy(buffer, cstr);
    2318:	b7 01       	movw	r22, r14
    231a:	88 81       	ld	r24, Y
    231c:	99 81       	ldd	r25, Y+1	; 0x01
    231e:	0e 94 cd 3e 	call	0x7d9a	; 0x7d9a <strcpy>
	return *this;
}
    2322:	ce 01       	movw	r24, r28
    2324:	df 91       	pop	r29
    2326:	cf 91       	pop	r28
    2328:	1f 91       	pop	r17
    232a:	0f 91       	pop	r16
    232c:	ff 90       	pop	r15
    232e:	ef 90       	pop	r14
    2330:	08 95       	ret
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
	if (!reserve(length)) {
		invalidate();
    2332:	ce 01       	movw	r24, r28
    2334:	0e 94 05 0f 	call	0x1e0a	; 0x1e0a <_ZN6String10invalidateEv>
    2338:	f4 cf       	rjmp	.-24     	; 0x2322 <_ZN6String4copyEPKcj+0x2a>

0000233a <_ZN6StringaSEPKc>:
	return *this;
}
#endif

String & String::operator = (const char *cstr)
{
    233a:	cf 93       	push	r28
    233c:	df 93       	push	r29
    233e:	ec 01       	movw	r28, r24
	if (cstr) copy(cstr, strlen(cstr));
    2340:	61 15       	cp	r22, r1
    2342:	71 05       	cpc	r23, r1
    2344:	71 f0       	breq	.+28     	; 0x2362 <_ZN6StringaSEPKc+0x28>
    2346:	fb 01       	movw	r30, r22
    2348:	01 90       	ld	r0, Z+
    234a:	00 20       	and	r0, r0
    234c:	e9 f7       	brne	.-6      	; 0x2348 <_ZN6StringaSEPKc+0xe>
    234e:	31 97       	sbiw	r30, 0x01	; 1
    2350:	af 01       	movw	r20, r30
    2352:	46 1b       	sub	r20, r22
    2354:	57 0b       	sbc	r21, r23
    2356:	0e 94 7c 11 	call	0x22f8	; 0x22f8 <_ZN6String4copyEPKcj>
	else invalidate();
	
	return *this;
}
    235a:	ce 01       	movw	r24, r28
    235c:	df 91       	pop	r29
    235e:	cf 91       	pop	r28
    2360:	08 95       	ret
#endif

String & String::operator = (const char *cstr)
{
	if (cstr) copy(cstr, strlen(cstr));
	else invalidate();
    2362:	0e 94 05 0f 	call	0x1e0a	; 0x1e0a <_ZN6String10invalidateEv>
    2366:	f9 cf       	rjmp	.-14     	; 0x235a <_ZN6StringaSEPKc+0x20>

00002368 <_ZN6StringaSERKS_>:
	rhs.len = 0;
}
#endif

String & String::operator = (const String &rhs)
{
    2368:	cf 93       	push	r28
    236a:	df 93       	push	r29
    236c:	ec 01       	movw	r28, r24
    236e:	fb 01       	movw	r30, r22
	if (this == &rhs) return *this;
    2370:	86 17       	cp	r24, r22
    2372:	97 07       	cpc	r25, r23
    2374:	49 f0       	breq	.+18     	; 0x2388 <_ZN6StringaSERKS_+0x20>
	
	if (rhs.buffer) copy(rhs.buffer, rhs.len);
    2376:	60 81       	ld	r22, Z
    2378:	71 81       	ldd	r23, Z+1	; 0x01
    237a:	61 15       	cp	r22, r1
    237c:	71 05       	cpc	r23, r1
    237e:	41 f0       	breq	.+16     	; 0x2390 <_ZN6StringaSERKS_+0x28>
    2380:	44 81       	ldd	r20, Z+4	; 0x04
    2382:	55 81       	ldd	r21, Z+5	; 0x05
    2384:	0e 94 7c 11 	call	0x22f8	; 0x22f8 <_ZN6String4copyEPKcj>
	else invalidate();
	
	return *this;
}
    2388:	ce 01       	movw	r24, r28
    238a:	df 91       	pop	r29
    238c:	cf 91       	pop	r28
    238e:	08 95       	ret
String & String::operator = (const String &rhs)
{
	if (this == &rhs) return *this;
	
	if (rhs.buffer) copy(rhs.buffer, rhs.len);
	else invalidate();
    2390:	0e 94 05 0f 	call	0x1e0a	; 0x1e0a <_ZN6String10invalidateEv>
    2394:	f9 cf       	rjmp	.-14     	; 0x2388 <_ZN6StringaSERKS_+0x20>

00002396 <_ZN6StringC1ERKS_>:
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    2396:	fc 01       	movw	r30, r24
    2398:	11 82       	std	Z+1, r1	; 0x01
    239a:	10 82       	st	Z, r1
	capacity = 0;
    239c:	13 82       	std	Z+3, r1	; 0x03
    239e:	12 82       	std	Z+2, r1	; 0x02
	len = 0;
    23a0:	15 82       	std	Z+5, r1	; 0x05
    23a2:	14 82       	std	Z+4, r1	; 0x04
}

String::String(const String &value)
{
	init();
	*this = value;
    23a4:	0e 94 b4 11 	call	0x2368	; 0x2368 <_ZN6StringaSERKS_>
}
    23a8:	08 95       	ret

000023aa <_ZN3etl15private_variant14operation_typeI6StringLb1ELb1EE12do_operationEiPcPKc>:
    //*******************************************
    // Specialisation for copyable & moveable types.
    template <typename T>
    struct operation_type<T, Copyable, Moveable>
    {
      static void do_operation(int operation, char* pstorage, const char* pvalue)
    23aa:	cf 93       	push	r28
    23ac:	df 93       	push	r29
    23ae:	ea 01       	movw	r28, r20
      {
        switch (operation)
    23b0:	81 30       	cpi	r24, 0x01	; 1
    23b2:	91 05       	cpc	r25, r1
    23b4:	91 f0       	breq	.+36     	; 0x23da <_ZN3etl15private_variant14operation_typeI6StringLb1ELb1EE12do_operationEiPcPKc+0x30>
    23b6:	82 30       	cpi	r24, 0x02	; 2
    23b8:	91 05       	cpc	r25, r1
    23ba:	c9 f0       	breq	.+50     	; 0x23ee <_ZN3etl15private_variant14operation_typeI6StringLb1ELb1EE12do_operationEiPcPKc+0x44>
    23bc:	89 2b       	or	r24, r25
    23be:	19 f0       	breq	.+6      	; 0x23c6 <_ZN3etl15private_variant14operation_typeI6StringLb1ELb1EE12do_operationEiPcPKc+0x1c>
            assert(false);
#endif
            break;
          }
        }
      }
    23c0:	df 91       	pop	r29
    23c2:	cf 91       	pop	r28
    23c4:	08 95       	ret
      {
        switch (operation)
        {
          case Copy:
          {
            ::new (pstorage) T(*reinterpret_cast<const T*>(pvalue));
    23c6:	86 e0       	ldi	r24, 0x06	; 6
    23c8:	90 e0       	ldi	r25, 0x00	; 0
    23ca:	0e 94 1e 02 	call	0x43c	; 0x43c <_ZnwjPv>
    23ce:	00 97       	sbiw	r24, 0x00	; 0
    23d0:	b9 f3       	breq	.-18     	; 0x23c0 <_ZN3etl15private_variant14operation_typeI6StringLb1ELb1EE12do_operationEiPcPKc+0x16>
    23d2:	be 01       	movw	r22, r28
    23d4:	0e 94 cb 11 	call	0x2396	; 0x2396 <_ZN6StringC1ERKS_>
    23d8:	f3 cf       	rjmp	.-26     	; 0x23c0 <_ZN3etl15private_variant14operation_typeI6StringLb1ELb1EE12do_operationEiPcPKc+0x16>
            break;
          }

          case Move:
          {
            ::new (pstorage) T(etl::move(*reinterpret_cast<T*>(const_cast<char*>(pvalue))));
    23da:	86 e0       	ldi	r24, 0x06	; 6
    23dc:	90 e0       	ldi	r25, 0x00	; 0
    23de:	0e 94 1e 02 	call	0x43c	; 0x43c <_ZnwjPv>
    23e2:	00 97       	sbiw	r24, 0x00	; 0
    23e4:	69 f3       	breq	.-38     	; 0x23c0 <_ZN3etl15private_variant14operation_typeI6StringLb1ELb1EE12do_operationEiPcPKc+0x16>
    23e6:	be 01       	movw	r22, r28
    23e8:	0e 94 db 10 	call	0x21b6	; 0x21b6 <_ZN6StringC1EOS_>
    23ec:	e9 cf       	rjmp	.-46     	; 0x23c0 <_ZN3etl15private_variant14operation_typeI6StringLb1ELb1EE12do_operationEiPcPKc+0x16>
            break;
          }

          case Destroy:
          {
            reinterpret_cast<const T*>(pstorage)->~T();
    23ee:	cb 01       	movw	r24, r22
    23f0:	0e 94 17 0f 	call	0x1e2e	; 0x1e2e <_ZN6StringD1Ev>
    23f4:	e5 cf       	rjmp	.-54     	; 0x23c0 <_ZN3etl15private_variant14operation_typeI6StringLb1ELb1EE12do_operationEiPcPKc+0x16>

000023f6 <_ZN6StringC1EPKc>:

/*********************************************/
/*  Constructors                             */
/*********************************************/

String::String(const char *cstr)
    23f6:	fc 01       	movw	r30, r24
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    23f8:	11 82       	std	Z+1, r1	; 0x01
    23fa:	10 82       	st	Z, r1
	capacity = 0;
    23fc:	13 82       	std	Z+3, r1	; 0x03
    23fe:	12 82       	std	Z+2, r1	; 0x02
	len = 0;
    2400:	15 82       	std	Z+5, r1	; 0x05
    2402:	14 82       	std	Z+4, r1	; 0x04
/*********************************************/

String::String(const char *cstr)
{
	init();
	if (cstr) copy(cstr, strlen(cstr));
    2404:	61 15       	cp	r22, r1
    2406:	71 05       	cpc	r23, r1
    2408:	51 f0       	breq	.+20     	; 0x241e <_ZN6StringC1EPKc+0x28>
    240a:	fb 01       	movw	r30, r22
    240c:	01 90       	ld	r0, Z+
    240e:	00 20       	and	r0, r0
    2410:	e9 f7       	brne	.-6      	; 0x240c <_ZN6StringC1EPKc+0x16>
    2412:	31 97       	sbiw	r30, 0x01	; 1
    2414:	af 01       	movw	r20, r30
    2416:	46 1b       	sub	r20, r22
    2418:	57 0b       	sbc	r21, r23
    241a:	0e 94 7c 11 	call	0x22f8	; 0x22f8 <_ZN6String4copyEPKcj>
}
    241e:	08 95       	ret

00002420 <_ZN13PhysicalLayer8readDataER6Stringj>:
int16_t PhysicalLayer::finishTransmit() {
  return(RADIOLIB_ERR_UNSUPPORTED);
}

#if defined(RADIOLIB_BUILD_ARDUINO)
int16_t PhysicalLayer::readData(String& str, size_t len) {
    2420:	af 92       	push	r10
    2422:	bf 92       	push	r11
    2424:	cf 92       	push	r12
    2426:	df 92       	push	r13
    2428:	ef 92       	push	r14
    242a:	ff 92       	push	r15
    242c:	0f 93       	push	r16
    242e:	1f 93       	push	r17
    2430:	cf 93       	push	r28
    2432:	df 93       	push	r29
    2434:	00 d0       	rcall	.+0      	; 0x2436 <_ZN13PhysicalLayer8readDataER6Stringj+0x16>
    2436:	00 d0       	rcall	.+0      	; 0x2438 <_ZN13PhysicalLayer8readDataER6Stringj+0x18>
    2438:	00 d0       	rcall	.+0      	; 0x243a <_ZN13PhysicalLayer8readDataER6Stringj+0x1a>
    243a:	cd b7       	in	r28, 0x3d	; 61
    243c:	de b7       	in	r29, 0x3e	; 62
    243e:	6c 01       	movw	r12, r24
    2440:	5b 01       	movw	r10, r22
    2442:	7a 01       	movw	r14, r20
  int16_t state = RADIOLIB_ERR_NONE;

  // read the number of actually received bytes
  size_t length = getPacketLength();
    2444:	dc 01       	movw	r26, r24
    2446:	ed 91       	ld	r30, X+
    2448:	fc 91       	ld	r31, X
    244a:	04 a4       	ldd	r0, Z+44	; 0x2c
    244c:	f5 a5       	ldd	r31, Z+45	; 0x2d
    244e:	e0 2d       	mov	r30, r0
    2450:	61 e0       	ldi	r22, 0x01	; 1
    2452:	09 95       	icall
    2454:	8c 01       	movw	r16, r24

  if((len < length) && (len != 0)) {
    2456:	e8 16       	cp	r14, r24
    2458:	f9 06       	cpc	r15, r25
    245a:	20 f4       	brcc	.+8      	; 0x2464 <_ZN13PhysicalLayer8readDataER6Stringj+0x44>
    245c:	e1 14       	cp	r14, r1
    245e:	f1 04       	cpc	r15, r1
    2460:	09 f0       	breq	.+2      	; 0x2464 <_ZN13PhysicalLayer8readDataER6Stringj+0x44>
    // user requested less bytes than were received, this is allowed (but frowned upon)
    // requests for more data than were received will only return the number of actually received bytes (unlike PhysicalLayer::receive())
    length = len;
    2462:	87 01       	movw	r16, r14

  // build a temporary buffer
  #if defined(RADIOLIB_STATIC_ONLY)
    uint8_t data[RADIOLIB_STATIC_ARRAY_SIZE + 1];
  #else
    uint8_t* data = new uint8_t[length + 1];
    2464:	c8 01       	movw	r24, r16
    2466:	01 96       	adiw	r24, 0x01	; 1
    2468:	0e 94 1f 0f 	call	0x1e3e	; 0x1e3e <_Znaj>
    246c:	7c 01       	movw	r14, r24
    if(!data) {
    246e:	00 97       	sbiw	r24, 0x00	; 0
    2470:	e1 f1       	breq	.+120    	; 0x24ea <_ZN13PhysicalLayer8readDataER6Stringj+0xca>
      return(RADIOLIB_ERR_MEMORY_ALLOCATION_FAILED);
    }
  #endif

  // read the received data
  state = readData(data, length);
    2472:	d6 01       	movw	r26, r12
    2474:	ed 91       	ld	r30, X+
    2476:	fc 91       	ld	r31, X
    2478:	02 88       	ldd	r0, Z+18	; 0x12
    247a:	f3 89       	ldd	r31, Z+19	; 0x13
    247c:	e0 2d       	mov	r30, r0
    247e:	a8 01       	movw	r20, r16
    2480:	bc 01       	movw	r22, r24
    2482:	c6 01       	movw	r24, r12
    2484:	09 95       	icall
    2486:	6c 01       	movw	r12, r24

  // any of the following leads to at least some data being available
  // let's leave the decision of whether to keep it or not up to the user
  if((state == RADIOLIB_ERR_NONE) || (state == RADIOLIB_ERR_CRC_MISMATCH) || (state == RADIOLIB_ERR_LORA_HEADER_DAMAGED)) {
    2488:	00 97       	sbiw	r24, 0x00	; 0
    248a:	39 f0       	breq	.+14     	; 0x249a <_ZN13PhysicalLayer8readDataER6Stringj+0x7a>
    248c:	07 96       	adiw	r24, 0x07	; 7
    248e:	29 f0       	breq	.+10     	; 0x249a <_ZN13PhysicalLayer8readDataER6Stringj+0x7a>
    2490:	88 ee       	ldi	r24, 0xE8	; 232
    2492:	c8 16       	cp	r12, r24
    2494:	8f ef       	ldi	r24, 0xFF	; 255
    2496:	d8 06       	cpc	r13, r24
    2498:	99 f4       	brne	.+38     	; 0x24c0 <_ZN13PhysicalLayer8readDataER6Stringj+0xa0>
    // add null terminator
    data[length] = 0;
    249a:	f7 01       	movw	r30, r14
    249c:	e0 0f       	add	r30, r16
    249e:	f1 1f       	adc	r31, r17
    24a0:	10 82       	st	Z, r1

    // initialize Arduino String class
    str = String((char*)data);
    24a2:	b7 01       	movw	r22, r14
    24a4:	ce 01       	movw	r24, r28
    24a6:	01 96       	adiw	r24, 0x01	; 1
    24a8:	0e 94 fb 11 	call	0x23f6	; 0x23f6 <_ZN6StringC1EPKc>
    24ac:	be 01       	movw	r22, r28
    24ae:	6f 5f       	subi	r22, 0xFF	; 255
    24b0:	7f 4f       	sbci	r23, 0xFF	; 255
    24b2:	c5 01       	movw	r24, r10
    24b4:	0e 94 cf 10 	call	0x219e	; 0x219e <_ZN6StringaSEOS_>
    24b8:	ce 01       	movw	r24, r28
    24ba:	01 96       	adiw	r24, 0x01	; 1
    24bc:	0e 94 17 0f 	call	0x1e2e	; 0x1e2e <_ZN6StringD1Ev>
  }

  // deallocate temporary buffer
  #if !defined(RADIOLIB_STATIC_ONLY)
    delete[] data;
    24c0:	c7 01       	movw	r24, r14
    24c2:	0e 94 02 0f 	call	0x1e04	; 0x1e04 <_ZdaPv>
  #endif

  return(state);
}
    24c6:	c6 01       	movw	r24, r12
    24c8:	26 96       	adiw	r28, 0x06	; 6
    24ca:	0f b6       	in	r0, 0x3f	; 63
    24cc:	f8 94       	cli
    24ce:	de bf       	out	0x3e, r29	; 62
    24d0:	0f be       	out	0x3f, r0	; 63
    24d2:	cd bf       	out	0x3d, r28	; 61
    24d4:	df 91       	pop	r29
    24d6:	cf 91       	pop	r28
    24d8:	1f 91       	pop	r17
    24da:	0f 91       	pop	r16
    24dc:	ff 90       	pop	r15
    24de:	ef 90       	pop	r14
    24e0:	df 90       	pop	r13
    24e2:	cf 90       	pop	r12
    24e4:	bf 90       	pop	r11
    24e6:	af 90       	pop	r10
    24e8:	08 95       	ret
  #if defined(RADIOLIB_STATIC_ONLY)
    uint8_t data[RADIOLIB_STATIC_ARRAY_SIZE + 1];
  #else
    uint8_t* data = new uint8_t[length + 1];
    if(!data) {
      return(RADIOLIB_ERR_MEMORY_ALLOCATION_FAILED);
    24ea:	0f 2e       	mov	r0, r31
    24ec:	fd ef       	ldi	r31, 0xFD	; 253
    24ee:	cf 2e       	mov	r12, r31
    24f0:	dd 24       	eor	r13, r13
    24f2:	da 94       	dec	r13
    24f4:	f0 2d       	mov	r31, r0
    24f6:	e7 cf       	rjmp	.-50     	; 0x24c6 <_ZN13PhysicalLayer8readDataER6Stringj+0xa6>

000024f8 <_ZN3gel5Radio8readDataEv>:

    return radio.getPacketLength();
}

expected<String, Error> Radio::readData()
{
    24f8:	ef 92       	push	r14
    24fa:	ff 92       	push	r15
    24fc:	0f 93       	push	r16
    24fe:	1f 93       	push	r17
    2500:	cf 93       	push	r28
    2502:	df 93       	push	r29
    2504:	cd b7       	in	r28, 0x3d	; 61
    2506:	de b7       	in	r29, 0x3e	; 62
    2508:	2c 97       	sbiw	r28, 0x0c	; 12
    250a:	0f b6       	in	r0, 0x3f	; 63
    250c:	f8 94       	cli
    250e:	de bf       	out	0x3e, r29	; 62
    2510:	0f be       	out	0x3f, r0	; 63
    2512:	cd bf       	out	0x3d, r28	; 61
    2514:	8c 01       	movw	r16, r24
    2516:	7b 01       	movw	r14, r22
    String str;
    2518:	62 ea       	ldi	r22, 0xA2	; 162
    251a:	72 e0       	ldi	r23, 0x02	; 2
    251c:	ce 01       	movw	r24, r28
    251e:	07 96       	adiw	r24, 0x07	; 7
    2520:	0e 94 fb 11 	call	0x23f6	; 0x23f6 <_ZN6StringC1EPKc>
    int err = radio.readData(str);
    2524:	50 e0       	ldi	r21, 0x00	; 0
    2526:	40 e0       	ldi	r20, 0x00	; 0
    2528:	be 01       	movw	r22, r28
    252a:	69 5f       	subi	r22, 0xF9	; 249
    252c:	7f 4f       	sbci	r23, 0xFF	; 255
    252e:	c7 01       	movw	r24, r14
    2530:	c4 96       	adiw	r24, 0x34	; 52
    2532:	0e 94 10 12 	call	0x2420	; 0x2420 <_ZN13PhysicalLayer8readDataER6Stringj>
    dataReceived = false;
    2536:	f7 01       	movw	r30, r14
    2538:	e5 59       	subi	r30, 0x95	; 149
    253a:	fe 4f       	sbci	r31, 0xFE	; 254
    253c:	10 82       	st	Z, r1
    
    if (err != RADIOLIB_ERR_NONE)
    253e:	89 2b       	or	r24, r25
    2540:	41 f5       	brne	.+80     	; 0x2592 <_ZN3gel5Radio8readDataEv+0x9a>
    /// Construct from arguments.
    //***************************************************************************
#include "diagnostic_uninitialized_push.h"
    template <size_t Index, typename... TArgs>
    ETL_CONSTEXPR14 explicit variant(etl::in_place_index_t<Index>, TArgs&&... args)
      : type_id(Index)
    2542:	81 e0       	ldi	r24, 0x01	; 1
    2544:	90 e0       	ldi	r25, 0x00	; 0
    2546:	f8 01       	movw	r30, r16
    2548:	91 87       	std	Z+9, r25	; 0x09
    254a:	80 87       	std	Z+8, r24	; 0x08
    template <typename T, typename... TArgs>
    static void construct_in_place_args(char* pstorage, TArgs&&... args)
    {
      using type = etl::remove_cvref_t<T>;

      ::new (pstorage) type(etl::forward<TArgs>(args)...);
    254c:	b8 01       	movw	r22, r16
    254e:	86 e0       	ldi	r24, 0x06	; 6
    2550:	90 e0       	ldi	r25, 0x00	; 0
    2552:	0e 94 1e 02 	call	0x43c	; 0x43c <_ZnwjPv>
    2556:	00 97       	sbiw	r24, 0x00	; 0
    2558:	29 f0       	breq	.+10     	; 0x2564 <_ZN3gel5Radio8readDataEv+0x6c>
    255a:	be 01       	movw	r22, r28
    255c:	69 5f       	subi	r22, 0xF9	; 249
    255e:	7f 4f       	sbci	r23, 0xFF	; 255
    2560:	0e 94 db 10 	call	0x21b6	; 0x21b6 <_ZN6StringC1EOS_>
      using type = typename private_variant::parameter_pack<TTypes...>:: template type_from_index_t<Index>;
      static_assert(etl::is_one_of<type, TTypes...> ::value, "Unsupported type");

      construct_in_place_args<type>(data, etl::forward<TArgs>(args)...);

      operation = operation_type<type, etl::is_copy_constructible<type>::value, etl::is_move_constructible<type>::value>::do_operation;
    2564:	85 ed       	ldi	r24, 0xD5	; 213
    2566:	91 e1       	ldi	r25, 0x11	; 17
    2568:	f8 01       	movw	r30, r16
    256a:	97 83       	std	Z+7, r25	; 0x07
    256c:	86 83       	std	Z+6, r24	; 0x06
    return radio.getPacketLength();
}

expected<String, Error> Radio::readData()
{
    String str;
    256e:	ce 01       	movw	r24, r28
    2570:	07 96       	adiw	r24, 0x07	; 7
    2572:	0e 94 17 0f 	call	0x1e2e	; 0x1e2e <_ZN6StringD1Ev>
    
    if (err != RADIOLIB_ERR_NONE)
        return expected<String, Error>{unexpected<Error>{Error::Internal}};

    return str;
}
    2576:	c8 01       	movw	r24, r16
    2578:	2c 96       	adiw	r28, 0x0c	; 12
    257a:	0f b6       	in	r0, 0x3f	; 63
    257c:	f8 94       	cli
    257e:	de bf       	out	0x3e, r29	; 62
    2580:	0f be       	out	0x3f, r0	; 63
    2582:	cd bf       	out	0x3d, r28	; 61
    2584:	df 91       	pop	r29
    2586:	cf 91       	pop	r28
    2588:	1f 91       	pop	r17
    258a:	0f 91       	pop	r16
    258c:	ff 90       	pop	r15
    258e:	ef 90       	pop	r14
    2590:	08 95       	ret
    2592:	87 e0       	ldi	r24, 0x07	; 7
    2594:	90 e0       	ldi	r25, 0x00	; 0
    2596:	9c 83       	std	Y+4, r25	; 0x04
    2598:	8b 83       	std	Y+3, r24	; 0x03
    259a:	1e 82       	std	Y+6, r1	; 0x06
    259c:	1d 82       	std	Y+5, r1	; 0x05
    /// Construct from arguments.
    //***************************************************************************
#include "diagnostic_uninitialized_push.h"
    template <size_t Index, typename... TArgs>
    ETL_CONSTEXPR14 explicit variant(etl::in_place_index_t<Index>, TArgs&&... args)
      : type_id(Index)
    259e:	82 e0       	ldi	r24, 0x02	; 2
    25a0:	90 e0       	ldi	r25, 0x00	; 0
    25a2:	f8 01       	movw	r30, r16
    25a4:	91 87       	std	Z+9, r25	; 0x09
    25a6:	80 87       	std	Z+8, r24	; 0x08
    template <typename T, typename... TArgs>
    static void construct_in_place_args(char* pstorage, TArgs&&... args)
    {
      using type = etl::remove_cvref_t<T>;

      ::new (pstorage) type(etl::forward<TArgs>(args)...);
    25a8:	b8 01       	movw	r22, r16
    25aa:	86 e0       	ldi	r24, 0x06	; 6
    25ac:	90 e0       	ldi	r25, 0x00	; 0
    25ae:	0e 94 1e 02 	call	0x43c	; 0x43c <_ZnwjPv>
    25b2:	fc 01       	movw	r30, r24
    25b4:	89 2b       	or	r24, r25
    25b6:	61 f0       	breq	.+24     	; 0x25d0 <_ZN3gel5Radio8readDataEv+0xd8>
    25b8:	8c e8       	ldi	r24, 0x8C	; 140
    25ba:	92 e0       	ldi	r25, 0x02	; 2
    25bc:	91 83       	std	Z+1, r25	; 0x01
    25be:	80 83       	st	Z, r24
    25c0:	87 e0       	ldi	r24, 0x07	; 7
    25c2:	90 e0       	ldi	r25, 0x00	; 0
    25c4:	93 83       	std	Z+3, r25	; 0x03
    25c6:	82 83       	std	Z+2, r24	; 0x02
    25c8:	90 e0       	ldi	r25, 0x00	; 0
    25ca:	80 e0       	ldi	r24, 0x00	; 0
    25cc:	95 83       	std	Z+5, r25	; 0x05
    25ce:	84 83       	std	Z+4, r24	; 0x04
      using type = typename private_variant::parameter_pack<TTypes...>:: template type_from_index_t<Index>;
      static_assert(etl::is_one_of<type, TTypes...> ::value, "Unsupported type");

      construct_in_place_args<type>(data, etl::forward<TArgs>(args)...);

      operation = operation_type<type, etl::is_copy_constructible<type>::value, etl::is_move_constructible<type>::value>::do_operation;
    25d0:	8a eb       	ldi	r24, 0xBA	; 186
    25d2:	96 e0       	ldi	r25, 0x06	; 6
    25d4:	f8 01       	movw	r30, r16
    25d6:	97 83       	std	Z+7, r25	; 0x07
    25d8:	86 83       	std	Z+6, r24	; 0x06
    25da:	c9 cf       	rjmp	.-110    	; 0x256e <_ZN3gel5Radio8readDataEv+0x76>

000025dc <_Z19telecommandCallbackN3etl4spanIhLj65535EEES1_>:

    return gel::Error::None;
}

gel::Error telecommandCallback(gel::span<uint8_t> command, gel::span<uint8_t> response)
{
    25dc:	ef 92       	push	r14
    25de:	ff 92       	push	r15
    25e0:	0f 93       	push	r16
    25e2:	1f 93       	push	r17
    25e4:	cf 93       	push	r28
    25e6:	df 93       	push	r29
    25e8:	cd b7       	in	r28, 0x3d	; 61
    25ea:	de b7       	in	r29, 0x3e	; 62
    25ec:	62 97       	sbiw	r28, 0x12	; 18
    25ee:	0f b6       	in	r0, 0x3f	; 63
    25f0:	f8 94       	cli
    25f2:	de bf       	out	0x3e, r29	; 62
    25f4:	0f be       	out	0x3f, r0	; 63
    25f6:	cd bf       	out	0x3d, r28	; 61
    25f8:	8c 01       	movw	r16, r24
    25fa:	7a 01       	movw	r14, r20
    //*************************************************************************
    /// Returns a pointer to the first element of the internal storage.
    //*************************************************************************
    ETL_NODISCARD ETL_CONSTEXPR pointer data() const ETL_NOEXCEPT
    {
      return pbegin;
    25fc:	fb 01       	movw	r30, r22
    25fe:	60 81       	ld	r22, Z
    2600:	71 81       	ldd	r23, Z+1	; 0x01
    String msg = "Responding to " + String((const char*)command.data());
    2602:	ce 01       	movw	r24, r28
    2604:	07 96       	adiw	r24, 0x07	; 7
    2606:	0e 94 fb 11 	call	0x23f6	; 0x23f6 <_ZN6StringC1EPKc>

class StringSumHelper : public String
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
    260a:	62 eb       	ldi	r22, 0xB2	; 178
    260c:	72 e0       	ldi	r23, 0x02	; 2
    260e:	ce 01       	movw	r24, r28
    2610:	01 96       	adiw	r24, 0x01	; 1
    2612:	0e 94 fb 11 	call	0x23f6	; 0x23f6 <_ZN6StringC1EPKc>
    2616:	be 01       	movw	r22, r28
    2618:	69 5f       	subi	r22, 0xF9	; 249
    261a:	7f 4f       	sbci	r23, 0xFF	; 255
    261c:	ce 01       	movw	r24, r28
    261e:	01 96       	adiw	r24, 0x01	; 1
    2620:	0e 94 68 11 	call	0x22d0	; 0x22d0 <_ZplRK15StringSumHelperRK6String>
    2624:	bc 01       	movw	r22, r24
    2626:	ce 01       	movw	r24, r28
    2628:	0d 96       	adiw	r24, 0x0d	; 13
    262a:	0e 94 cb 11 	call	0x2396	; 0x2396 <_ZN6StringC1ERKS_>
       #if __cplusplus >= 201103L || defined(__GXX_EXPERIMENTAL_CXX0X__)
	void move(String &rhs);
	#endif
};

class StringSumHelper : public String
    262e:	ce 01       	movw	r24, r28
    2630:	01 96       	adiw	r24, 0x01	; 1
    2632:	0e 94 17 0f 	call	0x1e2e	; 0x1e2e <_ZN6StringD1Ev>
    2636:	ce 01       	movw	r24, r28
    2638:	07 96       	adiw	r24, 0x07	; 7
    263a:	0e 94 17 0f 	call	0x1e2e	; 0x1e2e <_ZN6StringD1Ev>
	char operator [] (unsigned int index) const;
	char& operator [] (unsigned int index);
	void getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index=0) const;
	void toCharArray(char *buf, unsigned int bufsize, unsigned int index=0) const
		{ getBytes((unsigned char *)buf, bufsize, index); }
	const char* c_str() const { return buffer; }
    263e:	6d 85       	ldd	r22, Y+13	; 0x0d
    2640:	7e 85       	ldd	r23, Y+14	; 0x0e
    strcpy((char*)response.data(), msg.c_str());   
    2642:	f7 01       	movw	r30, r14
    2644:	80 81       	ld	r24, Z
    2646:	91 81       	ldd	r25, Z+1	; 0x01
    2648:	0e 94 cd 3e 	call	0x7d9a	; 0x7d9a <strcpy>
        CapacityFull,
        NotImplemented,
    };

    Error() = default;
    Error(Code other) : code(other) {}
    264c:	8c e8       	ldi	r24, 0x8C	; 140
    264e:	92 e0       	ldi	r25, 0x02	; 2
    2650:	f8 01       	movw	r30, r16
    2652:	91 83       	std	Z+1, r25	; 0x01
    2654:	80 83       	st	Z, r24
    2656:	13 82       	std	Z+3, r1	; 0x03
    2658:	12 82       	std	Z+2, r1	; 0x02
    265a:	15 82       	std	Z+5, r1	; 0x05
    265c:	14 82       	std	Z+4, r1	; 0x04
    return gel::Error::None;
}

gel::Error telecommandCallback(gel::span<uint8_t> command, gel::span<uint8_t> response)
{
    String msg = "Responding to " + String((const char*)command.data());
    265e:	ce 01       	movw	r24, r28
    2660:	0d 96       	adiw	r24, 0x0d	; 13
    2662:	0e 94 17 0f 	call	0x1e2e	; 0x1e2e <_ZN6StringD1Ev>
    strcpy((char*)response.data(), msg.c_str());   

    return gel::Error::None;
}
    2666:	c8 01       	movw	r24, r16
    2668:	62 96       	adiw	r28, 0x12	; 18
    266a:	0f b6       	in	r0, 0x3f	; 63
    266c:	f8 94       	cli
    266e:	de bf       	out	0x3e, r29	; 62
    2670:	0f be       	out	0x3f, r0	; 63
    2672:	cd bf       	out	0x3d, r28	; 61
    2674:	df 91       	pop	r29
    2676:	cf 91       	pop	r28
    2678:	1f 91       	pop	r17
    267a:	0f 91       	pop	r16
    267c:	ff 90       	pop	r15
    267e:	ef 90       	pop	r14
    2680:	08 95       	ret

00002682 <_ZN6StringC1Ejh>:
	char buf[2 + 8 * sizeof(int)];
	itoa(value, buf, base);
	*this = buf;
}

String::String(unsigned int value, unsigned char base)
    2682:	0f 93       	push	r16
    2684:	1f 93       	push	r17
    2686:	cf 93       	push	r28
    2688:	df 93       	push	r29
    268a:	cd b7       	in	r28, 0x3d	; 61
    268c:	de b7       	in	r29, 0x3e	; 62
    268e:	61 97       	sbiw	r28, 0x11	; 17
    2690:	0f b6       	in	r0, 0x3f	; 63
    2692:	f8 94       	cli
    2694:	de bf       	out	0x3e, r29	; 62
    2696:	0f be       	out	0x3f, r0	; 63
    2698:	cd bf       	out	0x3d, r28	; 61
    269a:	8c 01       	movw	r16, r24
    269c:	cb 01       	movw	r24, r22
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    269e:	f8 01       	movw	r30, r16
    26a0:	11 82       	std	Z+1, r1	; 0x01
    26a2:	10 82       	st	Z, r1
	capacity = 0;
    26a4:	13 82       	std	Z+3, r1	; 0x03
    26a6:	12 82       	std	Z+2, r1	; 0x02
	len = 0;
    26a8:	15 82       	std	Z+5, r1	; 0x05
    26aa:	14 82       	std	Z+4, r1	; 0x04

String::String(unsigned int value, unsigned char base)
{
	init();
	char buf[1 + 8 * sizeof(unsigned int)];
	utoa(value, buf, base);
    26ac:	50 e0       	ldi	r21, 0x00	; 0
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    26ae:	be 01       	movw	r22, r28
    26b0:	6f 5f       	subi	r22, 0xFF	; 255
    26b2:	7f 4f       	sbci	r23, 0xFF	; 255
    26b4:	0e 94 3c 39 	call	0x7278	; 0x7278 <utoa>
	*this = buf;
    26b8:	be 01       	movw	r22, r28
    26ba:	6f 5f       	subi	r22, 0xFF	; 255
    26bc:	7f 4f       	sbci	r23, 0xFF	; 255
    26be:	c8 01       	movw	r24, r16
    26c0:	0e 94 9d 11 	call	0x233a	; 0x233a <_ZN6StringaSEPKc>
}
    26c4:	61 96       	adiw	r28, 0x11	; 17
    26c6:	0f b6       	in	r0, 0x3f	; 63
    26c8:	f8 94       	cli
    26ca:	de bf       	out	0x3e, r29	; 62
    26cc:	0f be       	out	0x3f, r0	; 63
    26ce:	cd bf       	out	0x3d, r28	; 61
    26d0:	df 91       	pop	r29
    26d2:	cf 91       	pop	r28
    26d4:	1f 91       	pop	r17
    26d6:	0f 91       	pop	r16
    26d8:	08 95       	ret

000026da <_Z17telemetryCallbackN3etl4spanIhLj65535EEE>:
gel::Link link{};
// gel::Gps gps{};
// SoftwareSerial gpsSerial(7, 6);

gel::Error telemetryCallback(gel::span<uint8_t> payload)
{
    26da:	ef 92       	push	r14
    26dc:	ff 92       	push	r15
    26de:	0f 93       	push	r16
    26e0:	1f 93       	push	r17
    26e2:	cf 93       	push	r28
    26e4:	df 93       	push	r29
    26e6:	cd b7       	in	r28, 0x3d	; 61
    26e8:	de b7       	in	r29, 0x3e	; 62
    26ea:	62 97       	sbiw	r28, 0x12	; 18
    26ec:	0f b6       	in	r0, 0x3f	; 63
    26ee:	f8 94       	cli
    26f0:	de bf       	out	0x3e, r29	; 62
    26f2:	0f be       	out	0x3f, r0	; 63
    26f4:	cd bf       	out	0x3d, r28	; 61
    26f6:	8c 01       	movw	r16, r24
    26f8:	7b 01       	movw	r14, r22
    static size_t streamMsg = 0;
    
    String msg = "Dummy telemetry number #" + String(streamMsg) + "\n";
    26fa:	60 91 40 03 	lds	r22, 0x0340	; 0x800340 <__data_end>
    26fe:	70 91 41 03 	lds	r23, 0x0341	; 0x800341 <__data_end+0x1>
    2702:	4a e0       	ldi	r20, 0x0A	; 10
    2704:	ce 01       	movw	r24, r28
    2706:	07 96       	adiw	r24, 0x07	; 7
    2708:	0e 94 41 13 	call	0x2682	; 0x2682 <_ZN6StringC1Ejh>

class StringSumHelper : public String
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
    270c:	61 ec       	ldi	r22, 0xC1	; 193
    270e:	72 e0       	ldi	r23, 0x02	; 2
    2710:	ce 01       	movw	r24, r28
    2712:	01 96       	adiw	r24, 0x01	; 1
    2714:	0e 94 fb 11 	call	0x23f6	; 0x23f6 <_ZN6StringC1EPKc>
    2718:	be 01       	movw	r22, r28
    271a:	69 5f       	subi	r22, 0xF9	; 249
    271c:	7f 4f       	sbci	r23, 0xFF	; 255
    271e:	ce 01       	movw	r24, r28
    2720:	01 96       	adiw	r24, 0x01	; 1
    2722:	0e 94 68 11 	call	0x22d0	; 0x22d0 <_ZplRK15StringSumHelperRK6String>
    2726:	61 ea       	ldi	r22, 0xA1	; 161
    2728:	72 e0       	ldi	r23, 0x02	; 2
    272a:	0e 94 4f 11 	call	0x229e	; 0x229e <_ZplRK15StringSumHelperPKc>
    272e:	bc 01       	movw	r22, r24
    2730:	ce 01       	movw	r24, r28
    2732:	0d 96       	adiw	r24, 0x0d	; 13
    2734:	0e 94 cb 11 	call	0x2396	; 0x2396 <_ZN6StringC1ERKS_>
       #if __cplusplus >= 201103L || defined(__GXX_EXPERIMENTAL_CXX0X__)
	void move(String &rhs);
	#endif
};

class StringSumHelper : public String
    2738:	ce 01       	movw	r24, r28
    273a:	01 96       	adiw	r24, 0x01	; 1
    273c:	0e 94 17 0f 	call	0x1e2e	; 0x1e2e <_ZN6StringD1Ev>
    2740:	ce 01       	movw	r24, r28
    2742:	07 96       	adiw	r24, 0x07	; 7
    2744:	0e 94 17 0f 	call	0x1e2e	; 0x1e2e <_ZN6StringD1Ev>
	char operator [] (unsigned int index) const;
	char& operator [] (unsigned int index);
	void getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index=0) const;
	void toCharArray(char *buf, unsigned int bufsize, unsigned int index=0) const
		{ getBytes((unsigned char *)buf, bufsize, index); }
	const char* c_str() const { return buffer; }
    2748:	6d 85       	ldd	r22, Y+13	; 0x0d
    274a:	7e 85       	ldd	r23, Y+14	; 0x0e
    strcpy((char*)payload.data(), msg.c_str());
    274c:	f7 01       	movw	r30, r14
    274e:	80 81       	ld	r24, Z
    2750:	91 81       	ldd	r25, Z+1	; 0x01
    2752:	0e 94 cd 3e 	call	0x7d9a	; 0x7d9a <strcpy>

    streamMsg++;
    2756:	80 91 40 03 	lds	r24, 0x0340	; 0x800340 <__data_end>
    275a:	90 91 41 03 	lds	r25, 0x0341	; 0x800341 <__data_end+0x1>
    275e:	01 96       	adiw	r24, 0x01	; 1
    2760:	90 93 41 03 	sts	0x0341, r25	; 0x800341 <__data_end+0x1>
    2764:	80 93 40 03 	sts	0x0340, r24	; 0x800340 <__data_end>
    2768:	8c e8       	ldi	r24, 0x8C	; 140
    276a:	92 e0       	ldi	r25, 0x02	; 2
    276c:	f8 01       	movw	r30, r16
    276e:	91 83       	std	Z+1, r25	; 0x01
    2770:	80 83       	st	Z, r24
    2772:	13 82       	std	Z+3, r1	; 0x03
    2774:	12 82       	std	Z+2, r1	; 0x02
    2776:	15 82       	std	Z+5, r1	; 0x05
    2778:	14 82       	std	Z+4, r1	; 0x04

gel::Error telemetryCallback(gel::span<uint8_t> payload)
{
    static size_t streamMsg = 0;
    
    String msg = "Dummy telemetry number #" + String(streamMsg) + "\n";
    277a:	ce 01       	movw	r24, r28
    277c:	0d 96       	adiw	r24, 0x0d	; 13
    277e:	0e 94 17 0f 	call	0x1e2e	; 0x1e2e <_ZN6StringD1Ev>
    strcpy((char*)payload.data(), msg.c_str());

    streamMsg++;

    return gel::Error::None;
}
    2782:	c8 01       	movw	r24, r16
    2784:	62 96       	adiw	r28, 0x12	; 18
    2786:	0f b6       	in	r0, 0x3f	; 63
    2788:	f8 94       	cli
    278a:	de bf       	out	0x3e, r29	; 62
    278c:	0f be       	out	0x3f, r0	; 63
    278e:	cd bf       	out	0x3d, r28	; 61
    2790:	df 91       	pop	r29
    2792:	cf 91       	pop	r28
    2794:	1f 91       	pop	r17
    2796:	0f 91       	pop	r16
    2798:	ff 90       	pop	r15
    279a:	ef 90       	pop	r14
    279c:	08 95       	ret

0000279e <_ZN10ArduinoHal22writePersistentStorageEmPhj>:
      EEPROM.end();
    #endif
  #endif
}

void ArduinoHal::writePersistentStorage(uint32_t addr, uint8_t* buff, size_t len) {
    279e:	8f 92       	push	r8
    27a0:	9f 92       	push	r9
    27a2:	af 92       	push	r10
    27a4:	bf 92       	push	r11
    27a6:	ef 92       	push	r14
    27a8:	ff 92       	push	r15
    27aa:	0f 93       	push	r16
    27ac:	1f 93       	push	r17
    27ae:	cf 93       	push	r28
    27b0:	df 93       	push	r29
    27b2:	4a 01       	movw	r8, r20
    27b4:	79 01       	movw	r14, r18
  #if !defined(RADIOLIB_EEPROM_UNSUPPORTED)
    #if defined(RADIOLIB_ESP32)
      EEPROM.begin(RADIOLIB_HAL_PERSISTENT_STORAGE_SIZE);
    #endif
    for(size_t i = 0; i < len; i++) {
    27b6:	d0 e0       	ldi	r29, 0x00	; 0
    27b8:	c0 e0       	ldi	r28, 0x00	; 0
    27ba:	c0 17       	cp	r28, r16
    27bc:	d1 07       	cpc	r29, r17
    27be:	58 f4       	brcc	.+22     	; 0x27d6 <_ZN10ArduinoHal22writePersistentStorageEmPhj+0x38>
      EEPROM.write(addr + i, buff[i]);
    27c0:	f7 01       	movw	r30, r14
    27c2:	ec 0f       	add	r30, r28
    27c4:	fd 1f       	adc	r31, r29
    27c6:	60 81       	ld	r22, Z
    27c8:	ce 01       	movw	r24, r28
    27ca:	88 0d       	add	r24, r8
    27cc:	99 1d       	adc	r25, r9
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    operator uint8_t() const             { return **this; }
    
    //Assignment/write members.
    EERef &operator=( const EERef &ref ) { return *this = *ref; }
    EERef &operator=( uint8_t in )       { return eeprom_write_byte( (uint8_t*) index, in ), *this;  }
    27ce:	0e 94 9d 3a 	call	0x753a	; 0x753a <eeprom_write_byte>
void ArduinoHal::writePersistentStorage(uint32_t addr, uint8_t* buff, size_t len) {
  #if !defined(RADIOLIB_EEPROM_UNSUPPORTED)
    #if defined(RADIOLIB_ESP32)
      EEPROM.begin(RADIOLIB_HAL_PERSISTENT_STORAGE_SIZE);
    #endif
    for(size_t i = 0; i < len; i++) {
    27d2:	21 96       	adiw	r28, 0x01	; 1
    27d4:	f2 cf       	rjmp	.-28     	; 0x27ba <_ZN10ArduinoHal22writePersistentStorageEmPhj+0x1c>
    #if defined(RADIOLIB_ESP32)
      EEPROM.commit();
      EEPROM.end();
    #endif
  #endif
}
    27d6:	df 91       	pop	r29
    27d8:	cf 91       	pop	r28
    27da:	1f 91       	pop	r17
    27dc:	0f 91       	pop	r16
    27de:	ff 90       	pop	r15
    27e0:	ef 90       	pop	r14
    27e2:	bf 90       	pop	r11
    27e4:	af 90       	pop	r10
    27e6:	9f 90       	pop	r9
    27e8:	8f 90       	pop	r8
    27ea:	08 95       	ret

000027ec <_ZN10ArduinoHal21readPersistentStorageEmPhj>:

void inline ArduinoHal::spiEnd() {
  spi->end();
}

void ArduinoHal::readPersistentStorage(uint32_t addr, uint8_t* buff, size_t len) {
    27ec:	8f 92       	push	r8
    27ee:	9f 92       	push	r9
    27f0:	af 92       	push	r10
    27f2:	bf 92       	push	r11
    27f4:	cf 92       	push	r12
    27f6:	df 92       	push	r13
    27f8:	ef 92       	push	r14
    27fa:	ff 92       	push	r15
    27fc:	0f 93       	push	r16
    27fe:	1f 93       	push	r17
    2800:	cf 93       	push	r28
    2802:	df 93       	push	r29
    2804:	4a 01       	movw	r8, r20
    2806:	69 01       	movw	r12, r18
  #if !defined(RADIOLIB_EEPROM_UNSUPPORTED)
    #if defined(RADIOLIB_ESP32)
      EEPROM.begin(RADIOLIB_HAL_PERSISTENT_STORAGE_SIZE);
    #endif
    for(size_t i = 0; i < len; i++) {
    2808:	d0 e0       	ldi	r29, 0x00	; 0
    280a:	c0 e0       	ldi	r28, 0x00	; 0
    280c:	c0 17       	cp	r28, r16
    280e:	d1 07       	cpc	r29, r17
    2810:	60 f4       	brcc	.+24     	; 0x282a <_ZN10ArduinoHal21readPersistentStorageEmPhj+0x3e>
      buff[i] = EEPROM.read(addr + i);
    2812:	ce 01       	movw	r24, r28
    2814:	88 0d       	add	r24, r8
    2816:	99 1d       	adc	r25, r9
    2818:	76 01       	movw	r14, r12
    281a:	ec 0e       	add	r14, r28
    281c:	fd 1e       	adc	r15, r29

    EERef( const int index )
        : index( index )                 {}
    
    //Access/read members.
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    281e:	0e 94 95 3a 	call	0x752a	; 0x752a <eeprom_read_byte>
    2822:	f7 01       	movw	r30, r14
    2824:	80 83       	st	Z, r24
void ArduinoHal::readPersistentStorage(uint32_t addr, uint8_t* buff, size_t len) {
  #if !defined(RADIOLIB_EEPROM_UNSUPPORTED)
    #if defined(RADIOLIB_ESP32)
      EEPROM.begin(RADIOLIB_HAL_PERSISTENT_STORAGE_SIZE);
    #endif
    for(size_t i = 0; i < len; i++) {
    2826:	21 96       	adiw	r28, 0x01	; 1
    2828:	f1 cf       	rjmp	.-30     	; 0x280c <_ZN10ArduinoHal21readPersistentStorageEmPhj+0x20>
    }
    #if defined(RADIOLIB_ESP32)
      EEPROM.end();
    #endif
  #endif
}
    282a:	df 91       	pop	r29
    282c:	cf 91       	pop	r28
    282e:	1f 91       	pop	r17
    2830:	0f 91       	pop	r16
    2832:	ff 90       	pop	r15
    2834:	ef 90       	pop	r14
    2836:	df 90       	pop	r13
    2838:	cf 90       	pop	r12
    283a:	bf 90       	pop	r11
    283c:	af 90       	pop	r10
    283e:	9f 90       	pop	r9
    2840:	8f 90       	pop	r8
    2842:	08 95       	ret

00002844 <_ZN6Module17SPItransferStreamEPhhbS0_S0_jbm>:
  #endif

  return(state);
}

int16_t Module::SPItransferStream(uint8_t* cmd, uint8_t cmdLen, bool write, uint8_t* dataOut, uint8_t* dataIn, size_t numBytes, bool waitForGpio, uint32_t timeout) {
    2844:	2f 92       	push	r2
    2846:	3f 92       	push	r3
    2848:	4f 92       	push	r4
    284a:	5f 92       	push	r5
    284c:	6f 92       	push	r6
    284e:	7f 92       	push	r7
    2850:	8f 92       	push	r8
    2852:	9f 92       	push	r9
    2854:	af 92       	push	r10
    2856:	bf 92       	push	r11
    2858:	cf 92       	push	r12
    285a:	df 92       	push	r13
    285c:	ef 92       	push	r14
    285e:	ff 92       	push	r15
    2860:	0f 93       	push	r16
    2862:	1f 93       	push	r17
    2864:	cf 93       	push	r28
    2866:	df 93       	push	r29
    2868:	cd b7       	in	r28, 0x3d	; 61
    286a:	de b7       	in	r29, 0x3e	; 62
    286c:	2b 97       	sbiw	r28, 0x0b	; 11
    286e:	0f b6       	in	r0, 0x3f	; 63
    2870:	f8 94       	cli
    2872:	de bf       	out	0x3e, r29	; 62
    2874:	0f be       	out	0x3f, r0	; 63
    2876:	cd bf       	out	0x3d, r28	; 61
    2878:	4c 01       	movw	r8, r24
    287a:	3b 01       	movw	r6, r22
    287c:	b4 2e       	mov	r11, r20
    287e:	29 87       	std	Y+9, r18	; 0x09
    2880:	fb 86       	std	Y+11, r15	; 0x0b
    2882:	ea 86       	std	Y+10, r14	; 0x0a
    2884:	d8 86       	std	Y+8, r13	; 0x08
    2886:	cf 82       	std	Y+7, r12	; 0x07
    2888:	c8 a0       	ldd	r12, Y+32	; 0x20
    288a:	d9 a0       	ldd	r13, Y+33	; 0x21
    288c:	ea a0       	ldd	r14, Y+34	; 0x22
    288e:	fb a0       	ldd	r15, Y+35	; 0x23
  // prepare the buffers
  size_t buffLen = cmdLen + numBytes;
    2890:	24 2e       	mov	r2, r20
    2892:	31 2c       	mov	r3, r1
    2894:	8f 81       	ldd	r24, Y+7	; 0x07
    2896:	98 85       	ldd	r25, Y+8	; 0x08
    2898:	82 0d       	add	r24, r2
    289a:	93 1d       	adc	r25, r3
    289c:	9a 83       	std	Y+2, r25	; 0x02
    289e:	89 83       	std	Y+1, r24	; 0x01
  if(!write) {
    28a0:	21 11       	cpse	r18, r1
    28a2:	03 c0       	rjmp	.+6      	; 0x28aa <_ZN6Module17SPItransferStreamEPhhbS0_S0_jbm+0x66>
    buffLen++;
    28a4:	01 96       	adiw	r24, 0x01	; 1
    28a6:	9a 83       	std	Y+2, r25	; 0x02
    28a8:	89 83       	std	Y+1, r24	; 0x01
  }
  #if defined(RADIOLIB_STATIC_ONLY)
    uint8_t buffOut[RADIOLIB_STATIC_ARRAY_SIZE];
    uint8_t buffIn[RADIOLIB_STATIC_ARRAY_SIZE];
  #else
    uint8_t* buffOut = new uint8_t[buffLen];
    28aa:	89 81       	ldd	r24, Y+1	; 0x01
    28ac:	9a 81       	ldd	r25, Y+2	; 0x02
    28ae:	0e 94 1f 0f 	call	0x1e3e	; 0x1e3e <_Znaj>
    28b2:	9c 83       	std	Y+4, r25	; 0x04
    28b4:	8b 83       	std	Y+3, r24	; 0x03
    uint8_t* buffIn = new uint8_t[buffLen];
    28b6:	89 81       	ldd	r24, Y+1	; 0x01
    28b8:	9a 81       	ldd	r25, Y+2	; 0x02
    28ba:	0e 94 1f 0f 	call	0x1e3e	; 0x1e3e <_Znaj>
    28be:	9e 83       	std	Y+6, r25	; 0x06
    28c0:	8d 83       	std	Y+5, r24	; 0x05
  #endif
  uint8_t* buffOutPtr = buffOut;
    28c2:	eb 81       	ldd	r30, Y+3	; 0x03
    28c4:	fc 81       	ldd	r31, Y+4	; 0x04

  // copy the command
  for(uint8_t n = 0; n < cmdLen; n++) {
    28c6:	90 e0       	ldi	r25, 0x00	; 0
    28c8:	9b 15       	cp	r25, r11
    28ca:	40 f4       	brcc	.+16     	; 0x28dc <_ZN6Module17SPItransferStreamEPhhbS0_S0_jbm+0x98>
    *(buffOutPtr++) = cmd[n];
    28cc:	d3 01       	movw	r26, r6
    28ce:	a9 0f       	add	r26, r25
    28d0:	b1 1d       	adc	r27, r1
    28d2:	8c 91       	ld	r24, X
    28d4:	80 83       	st	Z, r24
    uint8_t* buffIn = new uint8_t[buffLen];
  #endif
  uint8_t* buffOutPtr = buffOut;

  // copy the command
  for(uint8_t n = 0; n < cmdLen; n++) {
    28d6:	9f 5f       	subi	r25, 0xFF	; 255
    *(buffOutPtr++) = cmd[n];
    28d8:	31 96       	adiw	r30, 0x01	; 1
    28da:	f6 cf       	rjmp	.-20     	; 0x28c8 <_ZN6Module17SPItransferStreamEPhhbS0_S0_jbm+0x84>
  }

  // copy the data
  if(write) {
    28dc:	99 85       	ldd	r25, Y+9	; 0x09
    28de:	99 23       	and	r25, r25
    28e0:	09 f4       	brne	.+2      	; 0x28e4 <_ZN6Module17SPItransferStreamEPhhbS0_S0_jbm+0xa0>
    28e2:	61 c0       	rjmp	.+194    	; 0x29a6 <_ZN6Module17SPItransferStreamEPhhbS0_S0_jbm+0x162>
    memcpy(buffOutPtr, dataOut, numBytes);
    28e4:	4f 81       	ldd	r20, Y+7	; 0x07
    28e6:	58 85       	ldd	r21, Y+8	; 0x08
    28e8:	b8 01       	movw	r22, r16
    28ea:	cf 01       	movw	r24, r30
    28ec:	0e 94 bd 3e 	call	0x7d7a	; 0x7d7a <memcpy>
  } else {
    memset(buffOutPtr, this->SPInopCommand, numBytes + 1);
  }

  // ensure GPIO is low
  if(this->gpioPin == RADIOLIB_NC) {
    28f0:	f4 01       	movw	r30, r8
    28f2:	80 8d       	ldd	r24, Z+24	; 0x18
    28f4:	91 8d       	ldd	r25, Z+25	; 0x19
    28f6:	a2 8d       	ldd	r26, Z+26	; 0x1a
    28f8:	b3 8d       	ldd	r27, Z+27	; 0x1b
    28fa:	8f 3f       	cpi	r24, 0xFF	; 255
    28fc:	9f 4f       	sbci	r25, 0xFF	; 255
    28fe:	af 4f       	sbci	r26, 0xFF	; 255
    2900:	bf 4f       	sbci	r27, 0xFF	; 255
    2902:	09 f4       	brne	.+2      	; 0x2906 <_ZN6Module17SPItransferStreamEPhhbS0_S0_jbm+0xc2>
    2904:	5c c0       	rjmp	.+184    	; 0x29be <_ZN6Module17SPItransferStreamEPhhbS0_S0_jbm+0x17a>
    this->hal->delay(1);
  } else {
    uint32_t start = this->hal->millis();
    2906:	f4 01       	movw	r30, r8
    2908:	80 81       	ld	r24, Z
    290a:	91 81       	ldd	r25, Z+1	; 0x01
    290c:	dc 01       	movw	r26, r24
    290e:	ed 91       	ld	r30, X+
    2910:	fc 91       	ld	r31, X
    2912:	06 84       	ldd	r0, Z+14	; 0x0e
    2914:	f7 85       	ldd	r31, Z+15	; 0x0f
    2916:	e0 2d       	mov	r30, r0
    2918:	09 95       	icall
    291a:	2b 01       	movw	r4, r22
    291c:	3c 01       	movw	r6, r24
    while(this->hal->digitalRead(this->gpioPin)) {
    291e:	f4 01       	movw	r30, r8
    2920:	80 81       	ld	r24, Z
    2922:	91 81       	ldd	r25, Z+1	; 0x01
    2924:	dc 01       	movw	r26, r24
    2926:	ed 91       	ld	r30, X+
    2928:	fc 91       	ld	r31, X
    292a:	04 80       	ldd	r0, Z+4	; 0x04
    292c:	f5 81       	ldd	r31, Z+5	; 0x05
    292e:	e0 2d       	mov	r30, r0
    2930:	d4 01       	movw	r26, r8
    2932:	58 96       	adiw	r26, 0x18	; 24
    2934:	4d 91       	ld	r20, X+
    2936:	5d 91       	ld	r21, X+
    2938:	6d 91       	ld	r22, X+
    293a:	7c 91       	ld	r23, X
    293c:	5b 97       	sbiw	r26, 0x1b	; 27
    293e:	09 95       	icall
    2940:	67 2b       	or	r22, r23
    2942:	68 2b       	or	r22, r24
    2944:	69 2b       	or	r22, r25
    2946:	09 f4       	brne	.+2      	; 0x294a <_ZN6Module17SPItransferStreamEPhhbS0_S0_jbm+0x106>
    2948:	48 c0       	rjmp	.+144    	; 0x29da <_ZN6Module17SPItransferStreamEPhhbS0_S0_jbm+0x196>
      this->hal->yield();
    294a:	f4 01       	movw	r30, r8
    294c:	80 81       	ld	r24, Z
    294e:	91 81       	ldd	r25, Z+1	; 0x01
    2950:	dc 01       	movw	r26, r24
    2952:	ed 91       	ld	r30, X+
    2954:	fc 91       	ld	r31, X
    2956:	06 a0       	ldd	r0, Z+38	; 0x26
    2958:	f7 a1       	ldd	r31, Z+39	; 0x27
    295a:	e0 2d       	mov	r30, r0
    295c:	09 95       	icall
      if(this->hal->millis() - start >= timeout) {
    295e:	f4 01       	movw	r30, r8
    2960:	80 81       	ld	r24, Z
    2962:	91 81       	ldd	r25, Z+1	; 0x01
    2964:	dc 01       	movw	r26, r24
    2966:	ed 91       	ld	r30, X+
    2968:	fc 91       	ld	r31, X
    296a:	06 84       	ldd	r0, Z+14	; 0x0e
    296c:	f7 85       	ldd	r31, Z+15	; 0x0f
    296e:	e0 2d       	mov	r30, r0
    2970:	09 95       	icall
    2972:	64 19       	sub	r22, r4
    2974:	75 09       	sbc	r23, r5
    2976:	86 09       	sbc	r24, r6
    2978:	97 09       	sbc	r25, r7
    297a:	6c 15       	cp	r22, r12
    297c:	7d 05       	cpc	r23, r13
    297e:	8e 05       	cpc	r24, r14
    2980:	9f 05       	cpc	r25, r15
    2982:	68 f2       	brcs	.-102    	; 0x291e <_ZN6Module17SPItransferStreamEPhhbS0_S0_jbm+0xda>
        RADIOLIB_DEBUG_PRINTLN("GPIO pre-transfer timeout, is it connected?");
        #if !defined(RADIOLIB_STATIC_ONLY)
          delete[] buffOut;
    2984:	eb 81       	ldd	r30, Y+3	; 0x03
    2986:	fc 81       	ldd	r31, Y+4	; 0x04
    2988:	30 97       	sbiw	r30, 0x00	; 0
    298a:	19 f0       	breq	.+6      	; 0x2992 <_ZN6Module17SPItransferStreamEPhhbS0_S0_jbm+0x14e>
    298c:	cf 01       	movw	r24, r30
    298e:	0e 94 02 0f 	call	0x1e04	; 0x1e04 <_ZdaPv>
          delete[] buffIn;
    2992:	8d 81       	ldd	r24, Y+5	; 0x05
    2994:	9e 81       	ldd	r25, Y+6	; 0x06
    2996:	00 97       	sbiw	r24, 0x00	; 0
    2998:	09 f4       	brne	.+2      	; 0x299c <_ZN6Module17SPItransferStreamEPhhbS0_S0_jbm+0x158>
    299a:	3b c1       	rjmp	.+630    	; 0x2c12 <_ZN6Module17SPItransferStreamEPhhbS0_S0_jbm+0x3ce>
    299c:	0e 94 02 0f 	call	0x1e04	; 0x1e04 <_ZdaPv>
        #endif
        return(RADIOLIB_ERR_SPI_CMD_TIMEOUT);
    29a0:	0f e3       	ldi	r16, 0x3F	; 63
    29a2:	1d ef       	ldi	r17, 0xFD	; 253
    29a4:	08 c1       	rjmp	.+528    	; 0x2bb6 <_ZN6Module17SPItransferStreamEPhhbS0_S0_jbm+0x372>

  // copy the data
  if(write) {
    memcpy(buffOutPtr, dataOut, numBytes);
  } else {
    memset(buffOutPtr, this->SPInopCommand, numBytes + 1);
    29a6:	d4 01       	movw	r26, r8
    29a8:	14 96       	adiw	r26, 0x04	; 4
    29aa:	6c 91       	ld	r22, X
    29ac:	70 e0       	ldi	r23, 0x00	; 0
    29ae:	4f 81       	ldd	r20, Y+7	; 0x07
    29b0:	58 85       	ldd	r21, Y+8	; 0x08
    29b2:	4f 5f       	subi	r20, 0xFF	; 255
    29b4:	5f 4f       	sbci	r21, 0xFF	; 255
    29b6:	cf 01       	movw	r24, r30
    29b8:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <memset>
    29bc:	99 cf       	rjmp	.-206    	; 0x28f0 <_ZN6Module17SPItransferStreamEPhhbS0_S0_jbm+0xac>
  }

  // ensure GPIO is low
  if(this->gpioPin == RADIOLIB_NC) {
    this->hal->delay(1);
    29be:	d4 01       	movw	r26, r8
    29c0:	8d 91       	ld	r24, X+
    29c2:	9c 91       	ld	r25, X
    29c4:	dc 01       	movw	r26, r24
    29c6:	ed 91       	ld	r30, X+
    29c8:	fc 91       	ld	r31, X
    29ca:	02 84       	ldd	r0, Z+10	; 0x0a
    29cc:	f3 85       	ldd	r31, Z+11	; 0x0b
    29ce:	e0 2d       	mov	r30, r0
    29d0:	41 e0       	ldi	r20, 0x01	; 1
    29d2:	50 e0       	ldi	r21, 0x00	; 0
    29d4:	60 e0       	ldi	r22, 0x00	; 0
    29d6:	70 e0       	ldi	r23, 0x00	; 0
    29d8:	09 95       	icall
      }
    }
  }

  // do the transfer
  this->hal->spiBeginTransaction();
    29da:	d4 01       	movw	r26, r8
    29dc:	8d 91       	ld	r24, X+
    29de:	9c 91       	ld	r25, X
    29e0:	dc 01       	movw	r26, r24
    29e2:	ed 91       	ld	r30, X+
    29e4:	fc 91       	ld	r31, X
    29e6:	06 88       	ldd	r0, Z+22	; 0x16
    29e8:	f7 89       	ldd	r31, Z+23	; 0x17
    29ea:	e0 2d       	mov	r30, r0
    29ec:	09 95       	icall
  this->hal->digitalWrite(this->csPin, this->hal->GpioLevelLow);
    29ee:	f4 01       	movw	r30, r8
    29f0:	80 81       	ld	r24, Z
    29f2:	91 81       	ldd	r25, Z+1	; 0x01
    29f4:	dc 01       	movw	r26, r24
    29f6:	ed 91       	ld	r30, X+
    29f8:	fc 91       	ld	r31, X
    29fa:	11 97       	sbiw	r26, 0x01	; 1
    29fc:	02 80       	ldd	r0, Z+2	; 0x02
    29fe:	f3 81       	ldd	r31, Z+3	; 0x03
    2a00:	e0 2d       	mov	r30, r0
    2a02:	1a 96       	adiw	r26, 0x0a	; 10
    2a04:	0d 91       	ld	r16, X+
    2a06:	1d 91       	ld	r17, X+
    2a08:	2d 91       	ld	r18, X+
    2a0a:	3c 91       	ld	r19, X
    2a0c:	1d 97       	sbiw	r26, 0x0d	; 13
    2a0e:	d4 01       	movw	r26, r8
    2a10:	1c 96       	adiw	r26, 0x0c	; 12
    2a12:	4d 91       	ld	r20, X+
    2a14:	5d 91       	ld	r21, X+
    2a16:	6d 91       	ld	r22, X+
    2a18:	7c 91       	ld	r23, X
    2a1a:	1f 97       	sbiw	r26, 0x0f	; 15
    2a1c:	09 95       	icall
  this->hal->spiTransfer(buffOut, buffLen, buffIn);
    2a1e:	f4 01       	movw	r30, r8
    2a20:	80 81       	ld	r24, Z
    2a22:	91 81       	ldd	r25, Z+1	; 0x01
    2a24:	dc 01       	movw	r26, r24
    2a26:	ed 91       	ld	r30, X+
    2a28:	fc 91       	ld	r31, X
    2a2a:	00 8c       	ldd	r0, Z+24	; 0x18
    2a2c:	f1 8d       	ldd	r31, Z+25	; 0x19
    2a2e:	e0 2d       	mov	r30, r0
    2a30:	2d 81       	ldd	r18, Y+5	; 0x05
    2a32:	3e 81       	ldd	r19, Y+6	; 0x06
    2a34:	49 81       	ldd	r20, Y+1	; 0x01
    2a36:	5a 81       	ldd	r21, Y+2	; 0x02
    2a38:	6b 81       	ldd	r22, Y+3	; 0x03
    2a3a:	7c 81       	ldd	r23, Y+4	; 0x04
    2a3c:	09 95       	icall
  this->hal->digitalWrite(this->csPin, this->hal->GpioLevelHigh);
    2a3e:	f4 01       	movw	r30, r8
    2a40:	80 81       	ld	r24, Z
    2a42:	91 81       	ldd	r25, Z+1	; 0x01
    2a44:	dc 01       	movw	r26, r24
    2a46:	ed 91       	ld	r30, X+
    2a48:	fc 91       	ld	r31, X
    2a4a:	11 97       	sbiw	r26, 0x01	; 1
    2a4c:	02 80       	ldd	r0, Z+2	; 0x02
    2a4e:	f3 81       	ldd	r31, Z+3	; 0x03
    2a50:	e0 2d       	mov	r30, r0
    2a52:	1e 96       	adiw	r26, 0x0e	; 14
    2a54:	0d 91       	ld	r16, X+
    2a56:	1d 91       	ld	r17, X+
    2a58:	2d 91       	ld	r18, X+
    2a5a:	3c 91       	ld	r19, X
    2a5c:	51 97       	sbiw	r26, 0x11	; 17
    2a5e:	d4 01       	movw	r26, r8
    2a60:	1c 96       	adiw	r26, 0x0c	; 12
    2a62:	4d 91       	ld	r20, X+
    2a64:	5d 91       	ld	r21, X+
    2a66:	6d 91       	ld	r22, X+
    2a68:	7c 91       	ld	r23, X
    2a6a:	1f 97       	sbiw	r26, 0x0f	; 15
    2a6c:	09 95       	icall
  this->hal->spiEndTransaction();
    2a6e:	f4 01       	movw	r30, r8
    2a70:	80 81       	ld	r24, Z
    2a72:	91 81       	ldd	r25, Z+1	; 0x01
    2a74:	dc 01       	movw	r26, r24
    2a76:	ed 91       	ld	r30, X+
    2a78:	fc 91       	ld	r31, X
    2a7a:	02 8c       	ldd	r0, Z+26	; 0x1a
    2a7c:	f3 8d       	ldd	r31, Z+27	; 0x1b
    2a7e:	e0 2d       	mov	r30, r0
    2a80:	09 95       	icall

  // wait for GPIO to go high and then low
  if(waitForGpio) {
    2a82:	aa 20       	and	r10, r10
    2a84:	09 f4       	brne	.+2      	; 0x2a88 <_ZN6Module17SPItransferStreamEPhhbS0_S0_jbm+0x244>
    2a86:	76 c0       	rjmp	.+236    	; 0x2b74 <_ZN6Module17SPItransferStreamEPhhbS0_S0_jbm+0x330>
    if(this->gpioPin == RADIOLIB_NC) {
    2a88:	f4 01       	movw	r30, r8
    2a8a:	80 8d       	ldd	r24, Z+24	; 0x18
    2a8c:	91 8d       	ldd	r25, Z+25	; 0x19
    2a8e:	a2 8d       	ldd	r26, Z+26	; 0x1a
    2a90:	b3 8d       	ldd	r27, Z+27	; 0x1b
    2a92:	8f 3f       	cpi	r24, 0xFF	; 255
    2a94:	9f 4f       	sbci	r25, 0xFF	; 255
    2a96:	af 4f       	sbci	r26, 0xFF	; 255
    2a98:	bf 4f       	sbci	r27, 0xFF	; 255
    2a9a:	09 f4       	brne	.+2      	; 0x2a9e <_ZN6Module17SPItransferStreamEPhhbS0_S0_jbm+0x25a>
    2a9c:	5d c0       	rjmp	.+186    	; 0x2b58 <_ZN6Module17SPItransferStreamEPhhbS0_S0_jbm+0x314>
      this->hal->delay(1);
    } else {
      this->hal->delayMicroseconds(1);
    2a9e:	f4 01       	movw	r30, r8
    2aa0:	80 81       	ld	r24, Z
    2aa2:	91 81       	ldd	r25, Z+1	; 0x01
    2aa4:	dc 01       	movw	r26, r24
    2aa6:	ed 91       	ld	r30, X+
    2aa8:	fc 91       	ld	r31, X
    2aaa:	04 84       	ldd	r0, Z+12	; 0x0c
    2aac:	f5 85       	ldd	r31, Z+13	; 0x0d
    2aae:	e0 2d       	mov	r30, r0
    2ab0:	41 e0       	ldi	r20, 0x01	; 1
    2ab2:	50 e0       	ldi	r21, 0x00	; 0
    2ab4:	60 e0       	ldi	r22, 0x00	; 0
    2ab6:	70 e0       	ldi	r23, 0x00	; 0
    2ab8:	09 95       	icall
      uint32_t start = this->hal->millis();
    2aba:	f4 01       	movw	r30, r8
    2abc:	80 81       	ld	r24, Z
    2abe:	91 81       	ldd	r25, Z+1	; 0x01
    2ac0:	dc 01       	movw	r26, r24
    2ac2:	ed 91       	ld	r30, X+
    2ac4:	fc 91       	ld	r31, X
    2ac6:	06 84       	ldd	r0, Z+14	; 0x0e
    2ac8:	f7 85       	ldd	r31, Z+15	; 0x0f
    2aca:	e0 2d       	mov	r30, r0
    2acc:	09 95       	icall
    2ace:	2b 01       	movw	r4, r22
    2ad0:	3c 01       	movw	r6, r24
      while(this->hal->digitalRead(this->gpioPin)) {
    2ad2:	f4 01       	movw	r30, r8
    2ad4:	80 81       	ld	r24, Z
    2ad6:	91 81       	ldd	r25, Z+1	; 0x01
    2ad8:	dc 01       	movw	r26, r24
    2ada:	ed 91       	ld	r30, X+
    2adc:	fc 91       	ld	r31, X
    2ade:	04 80       	ldd	r0, Z+4	; 0x04
    2ae0:	f5 81       	ldd	r31, Z+5	; 0x05
    2ae2:	e0 2d       	mov	r30, r0
    2ae4:	d4 01       	movw	r26, r8
    2ae6:	58 96       	adiw	r26, 0x18	; 24
    2ae8:	4d 91       	ld	r20, X+
    2aea:	5d 91       	ld	r21, X+
    2aec:	6d 91       	ld	r22, X+
    2aee:	7c 91       	ld	r23, X
    2af0:	5b 97       	sbiw	r26, 0x1b	; 27
    2af2:	09 95       	icall
    2af4:	67 2b       	or	r22, r23
    2af6:	68 2b       	or	r22, r24
    2af8:	69 2b       	or	r22, r25
    2afa:	e1 f1       	breq	.+120    	; 0x2b74 <_ZN6Module17SPItransferStreamEPhhbS0_S0_jbm+0x330>
        this->hal->yield();
    2afc:	f4 01       	movw	r30, r8
    2afe:	80 81       	ld	r24, Z
    2b00:	91 81       	ldd	r25, Z+1	; 0x01
    2b02:	dc 01       	movw	r26, r24
    2b04:	ed 91       	ld	r30, X+
    2b06:	fc 91       	ld	r31, X
    2b08:	06 a0       	ldd	r0, Z+38	; 0x26
    2b0a:	f7 a1       	ldd	r31, Z+39	; 0x27
    2b0c:	e0 2d       	mov	r30, r0
    2b0e:	09 95       	icall
        if(this->hal->millis() - start >= timeout) {
    2b10:	f4 01       	movw	r30, r8
    2b12:	80 81       	ld	r24, Z
    2b14:	91 81       	ldd	r25, Z+1	; 0x01
    2b16:	dc 01       	movw	r26, r24
    2b18:	ed 91       	ld	r30, X+
    2b1a:	fc 91       	ld	r31, X
    2b1c:	06 84       	ldd	r0, Z+14	; 0x0e
    2b1e:	f7 85       	ldd	r31, Z+15	; 0x0f
    2b20:	e0 2d       	mov	r30, r0
    2b22:	09 95       	icall
    2b24:	64 19       	sub	r22, r4
    2b26:	75 09       	sbc	r23, r5
    2b28:	86 09       	sbc	r24, r6
    2b2a:	97 09       	sbc	r25, r7
    2b2c:	6c 15       	cp	r22, r12
    2b2e:	7d 05       	cpc	r23, r13
    2b30:	8e 05       	cpc	r24, r14
    2b32:	9f 05       	cpc	r25, r15
    2b34:	70 f2       	brcs	.-100    	; 0x2ad2 <_ZN6Module17SPItransferStreamEPhhbS0_S0_jbm+0x28e>
          RADIOLIB_DEBUG_PRINTLN("GPIO post-transfer timeout, is it connected?");
          #if !defined(RADIOLIB_STATIC_ONLY)
            delete[] buffOut;
    2b36:	eb 81       	ldd	r30, Y+3	; 0x03
    2b38:	fc 81       	ldd	r31, Y+4	; 0x04
    2b3a:	30 97       	sbiw	r30, 0x00	; 0
    2b3c:	19 f0       	breq	.+6      	; 0x2b44 <_ZN6Module17SPItransferStreamEPhhbS0_S0_jbm+0x300>
    2b3e:	cf 01       	movw	r24, r30
    2b40:	0e 94 02 0f 	call	0x1e04	; 0x1e04 <_ZdaPv>
            delete[] buffIn;
    2b44:	8d 81       	ldd	r24, Y+5	; 0x05
    2b46:	9e 81       	ldd	r25, Y+6	; 0x06
    2b48:	00 97       	sbiw	r24, 0x00	; 0
    2b4a:	09 f4       	brne	.+2      	; 0x2b4e <_ZN6Module17SPItransferStreamEPhhbS0_S0_jbm+0x30a>
    2b4c:	65 c0       	rjmp	.+202    	; 0x2c18 <_ZN6Module17SPItransferStreamEPhhbS0_S0_jbm+0x3d4>
    2b4e:	0e 94 02 0f 	call	0x1e04	; 0x1e04 <_ZdaPv>
          #endif
          return(RADIOLIB_ERR_SPI_CMD_TIMEOUT);
    2b52:	0f e3       	ldi	r16, 0x3F	; 63
    2b54:	1d ef       	ldi	r17, 0xFD	; 253
    2b56:	2f c0       	rjmp	.+94     	; 0x2bb6 <_ZN6Module17SPItransferStreamEPhhbS0_S0_jbm+0x372>
  this->hal->spiEndTransaction();

  // wait for GPIO to go high and then low
  if(waitForGpio) {
    if(this->gpioPin == RADIOLIB_NC) {
      this->hal->delay(1);
    2b58:	d4 01       	movw	r26, r8
    2b5a:	8d 91       	ld	r24, X+
    2b5c:	9c 91       	ld	r25, X
    2b5e:	dc 01       	movw	r26, r24
    2b60:	ed 91       	ld	r30, X+
    2b62:	fc 91       	ld	r31, X
    2b64:	02 84       	ldd	r0, Z+10	; 0x0a
    2b66:	f3 85       	ldd	r31, Z+11	; 0x0b
    2b68:	e0 2d       	mov	r30, r0
    2b6a:	41 e0       	ldi	r20, 0x01	; 1
    2b6c:	50 e0       	ldi	r21, 0x00	; 0
    2b6e:	60 e0       	ldi	r22, 0x00	; 0
    2b70:	70 e0       	ldi	r23, 0x00	; 0
    2b72:	09 95       	icall
    }
  }

  // parse status
  int16_t state = RADIOLIB_ERR_NONE;
  if((this->SPIparseStatusCb != nullptr) && (numBytes > 0)) {
    2b74:	d4 01       	movw	r26, r8
    2b76:	1a 96       	adiw	r26, 0x0a	; 10
    2b78:	ed 91       	ld	r30, X+
    2b7a:	fc 91       	ld	r31, X
    2b7c:	30 97       	sbiw	r30, 0x00	; 0
    2b7e:	a9 f1       	breq	.+106    	; 0x2bea <_ZN6Module17SPItransferStreamEPhhbS0_S0_jbm+0x3a6>
    2b80:	8f 81       	ldd	r24, Y+7	; 0x07
    2b82:	98 85       	ldd	r25, Y+8	; 0x08
    2b84:	89 2b       	or	r24, r25
    2b86:	a1 f1       	breq	.+104    	; 0x2bf0 <_ZN6Module17SPItransferStreamEPhhbS0_S0_jbm+0x3ac>
    state = this->SPIparseStatusCb(buffIn[cmdLen]);
    2b88:	ad 81       	ldd	r26, Y+5	; 0x05
    2b8a:	be 81       	ldd	r27, Y+6	; 0x06
    2b8c:	a2 0d       	add	r26, r2
    2b8e:	b3 1d       	adc	r27, r3
    2b90:	8c 91       	ld	r24, X
    2b92:	09 95       	icall
    2b94:	8c 01       	movw	r16, r24
  }
  
  // copy the data
  if(!write) {
    2b96:	99 85       	ldd	r25, Y+9	; 0x09
    2b98:	99 23       	and	r25, r25
    2b9a:	69 f1       	breq	.+90     	; 0x2bf6 <_ZN6Module17SPItransferStreamEPhhbS0_S0_jbm+0x3b2>
    }
    RADIOLIB_VERBOSE_PRINTLN();
  #endif

  #if !defined(RADIOLIB_STATIC_ONLY)
    delete[] buffOut;
    2b9c:	eb 81       	ldd	r30, Y+3	; 0x03
    2b9e:	fc 81       	ldd	r31, Y+4	; 0x04
    2ba0:	30 97       	sbiw	r30, 0x00	; 0
    2ba2:	19 f0       	breq	.+6      	; 0x2baa <_ZN6Module17SPItransferStreamEPhhbS0_S0_jbm+0x366>
    2ba4:	cf 01       	movw	r24, r30
    2ba6:	0e 94 02 0f 	call	0x1e04	; 0x1e04 <_ZdaPv>
    delete[] buffIn;
    2baa:	8d 81       	ldd	r24, Y+5	; 0x05
    2bac:	9e 81       	ldd	r25, Y+6	; 0x06
    2bae:	00 97       	sbiw	r24, 0x00	; 0
    2bb0:	11 f0       	breq	.+4      	; 0x2bb6 <_ZN6Module17SPItransferStreamEPhhbS0_S0_jbm+0x372>
    2bb2:	0e 94 02 0f 	call	0x1e04	; 0x1e04 <_ZdaPv>
  #endif

  return(state);
}
    2bb6:	c8 01       	movw	r24, r16
    2bb8:	2b 96       	adiw	r28, 0x0b	; 11
    2bba:	0f b6       	in	r0, 0x3f	; 63
    2bbc:	f8 94       	cli
    2bbe:	de bf       	out	0x3e, r29	; 62
    2bc0:	0f be       	out	0x3f, r0	; 63
    2bc2:	cd bf       	out	0x3d, r28	; 61
    2bc4:	df 91       	pop	r29
    2bc6:	cf 91       	pop	r28
    2bc8:	1f 91       	pop	r17
    2bca:	0f 91       	pop	r16
    2bcc:	ff 90       	pop	r15
    2bce:	ef 90       	pop	r14
    2bd0:	df 90       	pop	r13
    2bd2:	cf 90       	pop	r12
    2bd4:	bf 90       	pop	r11
    2bd6:	af 90       	pop	r10
    2bd8:	9f 90       	pop	r9
    2bda:	8f 90       	pop	r8
    2bdc:	7f 90       	pop	r7
    2bde:	6f 90       	pop	r6
    2be0:	5f 90       	pop	r5
    2be2:	4f 90       	pop	r4
    2be4:	3f 90       	pop	r3
    2be6:	2f 90       	pop	r2
    2be8:	08 95       	ret
      }
    }
  }

  // parse status
  int16_t state = RADIOLIB_ERR_NONE;
    2bea:	10 e0       	ldi	r17, 0x00	; 0
    2bec:	00 e0       	ldi	r16, 0x00	; 0
    2bee:	d3 cf       	rjmp	.-90     	; 0x2b96 <_ZN6Module17SPItransferStreamEPhhbS0_S0_jbm+0x352>
    2bf0:	10 e0       	ldi	r17, 0x00	; 0
    2bf2:	00 e0       	ldi	r16, 0x00	; 0
    2bf4:	d0 cf       	rjmp	.-96     	; 0x2b96 <_ZN6Module17SPItransferStreamEPhhbS0_S0_jbm+0x352>
  }
  
  // copy the data
  if(!write) {
    // skip the first byte for read-type commands (status-only)
    memcpy(dataIn, &buffIn[cmdLen + 1], numBytes);
    2bf6:	b1 01       	movw	r22, r2
    2bf8:	6f 5f       	subi	r22, 0xFF	; 255
    2bfa:	7f 4f       	sbci	r23, 0xFF	; 255
    2bfc:	ad 81       	ldd	r26, Y+5	; 0x05
    2bfe:	be 81       	ldd	r27, Y+6	; 0x06
    2c00:	6a 0f       	add	r22, r26
    2c02:	7b 1f       	adc	r23, r27
    2c04:	4f 81       	ldd	r20, Y+7	; 0x07
    2c06:	58 85       	ldd	r21, Y+8	; 0x08
    2c08:	8a 85       	ldd	r24, Y+10	; 0x0a
    2c0a:	9b 85       	ldd	r25, Y+11	; 0x0b
    2c0c:	0e 94 bd 3e 	call	0x7d7a	; 0x7d7a <memcpy>
    2c10:	c5 cf       	rjmp	.-118    	; 0x2b9c <_ZN6Module17SPItransferStreamEPhhbS0_S0_jbm+0x358>
        RADIOLIB_DEBUG_PRINTLN("GPIO pre-transfer timeout, is it connected?");
        #if !defined(RADIOLIB_STATIC_ONLY)
          delete[] buffOut;
          delete[] buffIn;
        #endif
        return(RADIOLIB_ERR_SPI_CMD_TIMEOUT);
    2c12:	0f e3       	ldi	r16, 0x3F	; 63
    2c14:	1d ef       	ldi	r17, 0xFD	; 253
    2c16:	cf cf       	rjmp	.-98     	; 0x2bb6 <_ZN6Module17SPItransferStreamEPhhbS0_S0_jbm+0x372>
          RADIOLIB_DEBUG_PRINTLN("GPIO post-transfer timeout, is it connected?");
          #if !defined(RADIOLIB_STATIC_ONLY)
            delete[] buffOut;
            delete[] buffIn;
          #endif
          return(RADIOLIB_ERR_SPI_CMD_TIMEOUT);
    2c18:	0f e3       	ldi	r16, 0x3F	; 63
    2c1a:	1d ef       	ldi	r17, 0xFD	; 253
    2c1c:	cc cf       	rjmp	.-104    	; 0x2bb6 <_ZN6Module17SPItransferStreamEPhhbS0_S0_jbm+0x372>

00002c1e <_ZN6Module11SPItransferEhjPhS0_j>:
    uint8_t cmd[] = { SPIwriteCommand, (uint8_t)((reg >> 8) & 0xFF), (uint8_t)(reg & 0xFF) };
    SPItransferStream(cmd, 3, true, &data, NULL, 1, true, RADIOLIB_MODULE_SPI_TIMEOUT);
  }
}

void Module::SPItransfer(uint8_t cmd, uint16_t reg, uint8_t* dataOut, uint8_t* dataIn, size_t numBytes) {
    2c1e:	3f 92       	push	r3
    2c20:	4f 92       	push	r4
    2c22:	5f 92       	push	r5
    2c24:	6f 92       	push	r6
    2c26:	7f 92       	push	r7
    2c28:	8f 92       	push	r8
    2c2a:	9f 92       	push	r9
    2c2c:	af 92       	push	r10
    2c2e:	bf 92       	push	r11
    2c30:	cf 92       	push	r12
    2c32:	df 92       	push	r13
    2c34:	ef 92       	push	r14
    2c36:	ff 92       	push	r15
    2c38:	0f 93       	push	r16
    2c3a:	1f 93       	push	r17
    2c3c:	cf 93       	push	r28
    2c3e:	df 93       	push	r29
    2c40:	00 d0       	rcall	.+0      	; 0x2c42 <_ZN6Module11SPItransferEhjPhS0_j+0x24>
    2c42:	00 d0       	rcall	.+0      	; 0x2c44 <_ZN6Module11SPItransferEhjPhS0_j+0x26>
    2c44:	cd b7       	in	r28, 0x3d	; 61
    2c46:	de b7       	in	r29, 0x3e	; 62
    2c48:	9c 83       	std	Y+4, r25	; 0x04
    2c4a:	8b 83       	std	Y+3, r24	; 0x03
    2c4c:	96 2e       	mov	r9, r22
    2c4e:	84 2e       	mov	r8, r20
    2c50:	35 2e       	mov	r3, r21
    2c52:	29 01       	movw	r4, r18
    2c54:	1a 83       	std	Y+2, r17	; 0x02
    2c56:	09 83       	std	Y+1, r16	; 0x01
  // prepare the buffers
  size_t buffLen = this->SPIaddrWidth/8 + numBytes;
    2c58:	dc 01       	movw	r26, r24
    2c5a:	16 96       	adiw	r26, 0x06	; 6
    2c5c:	cc 90       	ld	r12, X
    2c5e:	c6 94       	lsr	r12
    2c60:	c6 94       	lsr	r12
    2c62:	c6 94       	lsr	r12
    2c64:	ce 0c       	add	r12, r14
    2c66:	df 2c       	mov	r13, r15
    2c68:	d1 1c       	adc	r13, r1
  #if defined(RADIOLIB_STATIC_ONLY)
    uint8_t buffOut[RADIOLIB_STATIC_ARRAY_SIZE];
    uint8_t buffIn[RADIOLIB_STATIC_ARRAY_SIZE];
  #else
    uint8_t* buffOut = new uint8_t[buffLen];
    2c6a:	c6 01       	movw	r24, r12
    2c6c:	0e 94 1f 0f 	call	0x1e3e	; 0x1e3e <_Znaj>
    2c70:	5c 01       	movw	r10, r24
    uint8_t* buffIn = new uint8_t[buffLen];
    2c72:	c6 01       	movw	r24, r12
    2c74:	0e 94 1f 0f 	call	0x1e3e	; 0x1e3e <_Znaj>
    2c78:	3c 01       	movw	r6, r24
  #endif
  uint8_t* buffOutPtr = buffOut;

  // copy the command
  if(this->SPIaddrWidth <= 8) {
    2c7a:	eb 81       	ldd	r30, Y+3	; 0x03
    2c7c:	fc 81       	ldd	r31, Y+4	; 0x04
    2c7e:	86 81       	ldd	r24, Z+6	; 0x06
    2c80:	89 30       	cpi	r24, 0x09	; 9
    2c82:	08 f0       	brcs	.+2      	; 0x2c86 <_ZN6Module11SPItransferEhjPhS0_j+0x68>
    2c84:	92 c0       	rjmp	.+292    	; 0x2daa <_ZN6Module11SPItransferEhjPhS0_j+0x18c>
    *(buffOutPtr++) = reg | cmd;
    2c86:	c5 01       	movw	r24, r10
    2c88:	01 96       	adiw	r24, 0x01	; 1
    2c8a:	89 28       	or	r8, r9
    2c8c:	d5 01       	movw	r26, r10
    2c8e:	8c 92       	st	X, r8
    *(buffOutPtr++) = (reg >> 8) | cmd;
    *(buffOutPtr++) = reg & 0xFF;
  }

  // copy the data
  if(cmd == SPIwriteCommand) {
    2c90:	ab 81       	ldd	r26, Y+3	; 0x03
    2c92:	bc 81       	ldd	r27, Y+4	; 0x04
    2c94:	13 96       	adiw	r26, 0x03	; 3
    2c96:	2c 91       	ld	r18, X
    2c98:	29 15       	cp	r18, r9
    2c9a:	09 f4       	brne	.+2      	; 0x2c9e <_ZN6Module11SPItransferEhjPhS0_j+0x80>
    2c9c:	8d c0       	rjmp	.+282    	; 0x2db8 <_ZN6Module11SPItransferEhjPhS0_j+0x19a>
    memcpy(buffOutPtr, dataOut, numBytes);
  } else {
    memset(buffOutPtr, this->SPInopCommand, numBytes);
    2c9e:	eb 81       	ldd	r30, Y+3	; 0x03
    2ca0:	fc 81       	ldd	r31, Y+4	; 0x04
    2ca2:	64 81       	ldd	r22, Z+4	; 0x04
    2ca4:	70 e0       	ldi	r23, 0x00	; 0
    2ca6:	a7 01       	movw	r20, r14
    2ca8:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <memset>
  }

  // do the transfer
  this->hal->spiBeginTransaction();
    2cac:	ab 81       	ldd	r26, Y+3	; 0x03
    2cae:	bc 81       	ldd	r27, Y+4	; 0x04
    2cb0:	8d 91       	ld	r24, X+
    2cb2:	9c 91       	ld	r25, X
    2cb4:	dc 01       	movw	r26, r24
    2cb6:	ed 91       	ld	r30, X+
    2cb8:	fc 91       	ld	r31, X
    2cba:	06 88       	ldd	r0, Z+22	; 0x16
    2cbc:	f7 89       	ldd	r31, Z+23	; 0x17
    2cbe:	e0 2d       	mov	r30, r0
    2cc0:	09 95       	icall
  this->hal->digitalWrite(this->csPin, this->hal->GpioLevelLow);
    2cc2:	eb 81       	ldd	r30, Y+3	; 0x03
    2cc4:	fc 81       	ldd	r31, Y+4	; 0x04
    2cc6:	80 81       	ld	r24, Z
    2cc8:	91 81       	ldd	r25, Z+1	; 0x01
    2cca:	dc 01       	movw	r26, r24
    2ccc:	ed 91       	ld	r30, X+
    2cce:	fc 91       	ld	r31, X
    2cd0:	11 97       	sbiw	r26, 0x01	; 1
    2cd2:	02 80       	ldd	r0, Z+2	; 0x02
    2cd4:	f3 81       	ldd	r31, Z+3	; 0x03
    2cd6:	e0 2d       	mov	r30, r0
    2cd8:	1a 96       	adiw	r26, 0x0a	; 10
    2cda:	0d 91       	ld	r16, X+
    2cdc:	1d 91       	ld	r17, X+
    2cde:	2d 91       	ld	r18, X+
    2ce0:	3c 91       	ld	r19, X
    2ce2:	1d 97       	sbiw	r26, 0x0d	; 13
    2ce4:	ab 81       	ldd	r26, Y+3	; 0x03
    2ce6:	bc 81       	ldd	r27, Y+4	; 0x04
    2ce8:	1c 96       	adiw	r26, 0x0c	; 12
    2cea:	4d 91       	ld	r20, X+
    2cec:	5d 91       	ld	r21, X+
    2cee:	6d 91       	ld	r22, X+
    2cf0:	7c 91       	ld	r23, X
    2cf2:	1f 97       	sbiw	r26, 0x0f	; 15
    2cf4:	09 95       	icall
  this->hal->spiTransfer(buffOut, buffLen, buffIn);
    2cf6:	eb 81       	ldd	r30, Y+3	; 0x03
    2cf8:	fc 81       	ldd	r31, Y+4	; 0x04
    2cfa:	80 81       	ld	r24, Z
    2cfc:	91 81       	ldd	r25, Z+1	; 0x01
    2cfe:	dc 01       	movw	r26, r24
    2d00:	ed 91       	ld	r30, X+
    2d02:	fc 91       	ld	r31, X
    2d04:	00 8c       	ldd	r0, Z+24	; 0x18
    2d06:	f1 8d       	ldd	r31, Z+25	; 0x19
    2d08:	e0 2d       	mov	r30, r0
    2d0a:	93 01       	movw	r18, r6
    2d0c:	a6 01       	movw	r20, r12
    2d0e:	b5 01       	movw	r22, r10
    2d10:	09 95       	icall
  this->hal->digitalWrite(this->csPin, this->hal->GpioLevelHigh);
    2d12:	eb 81       	ldd	r30, Y+3	; 0x03
    2d14:	fc 81       	ldd	r31, Y+4	; 0x04
    2d16:	80 81       	ld	r24, Z
    2d18:	91 81       	ldd	r25, Z+1	; 0x01
    2d1a:	dc 01       	movw	r26, r24
    2d1c:	ed 91       	ld	r30, X+
    2d1e:	fc 91       	ld	r31, X
    2d20:	11 97       	sbiw	r26, 0x01	; 1
    2d22:	02 80       	ldd	r0, Z+2	; 0x02
    2d24:	f3 81       	ldd	r31, Z+3	; 0x03
    2d26:	e0 2d       	mov	r30, r0
    2d28:	1e 96       	adiw	r26, 0x0e	; 14
    2d2a:	0d 91       	ld	r16, X+
    2d2c:	1d 91       	ld	r17, X+
    2d2e:	2d 91       	ld	r18, X+
    2d30:	3c 91       	ld	r19, X
    2d32:	51 97       	sbiw	r26, 0x11	; 17
    2d34:	ab 81       	ldd	r26, Y+3	; 0x03
    2d36:	bc 81       	ldd	r27, Y+4	; 0x04
    2d38:	1c 96       	adiw	r26, 0x0c	; 12
    2d3a:	4d 91       	ld	r20, X+
    2d3c:	5d 91       	ld	r21, X+
    2d3e:	6d 91       	ld	r22, X+
    2d40:	7c 91       	ld	r23, X
    2d42:	1f 97       	sbiw	r26, 0x0f	; 15
    2d44:	09 95       	icall
  this->hal->spiEndTransaction();
    2d46:	eb 81       	ldd	r30, Y+3	; 0x03
    2d48:	fc 81       	ldd	r31, Y+4	; 0x04
    2d4a:	80 81       	ld	r24, Z
    2d4c:	91 81       	ldd	r25, Z+1	; 0x01
    2d4e:	dc 01       	movw	r26, r24
    2d50:	ed 91       	ld	r30, X+
    2d52:	fc 91       	ld	r31, X
    2d54:	02 8c       	ldd	r0, Z+26	; 0x1a
    2d56:	f3 8d       	ldd	r31, Z+27	; 0x1b
    2d58:	e0 2d       	mov	r30, r0
    2d5a:	09 95       	icall
  
  // copy the data
  if(cmd == SPIreadCommand) {
    2d5c:	eb 81       	ldd	r30, Y+3	; 0x03
    2d5e:	fc 81       	ldd	r31, Y+4	; 0x04
    2d60:	82 81       	ldd	r24, Z+2	; 0x02
    2d62:	89 15       	cp	r24, r9
    2d64:	71 f1       	breq	.+92     	; 0x2dc2 <_ZN6Module11SPItransferEhjPhS0_j+0x1a4>
    }
    RADIOLIB_VERBOSE_PRINTLN();
  #endif

  #if !defined(RADIOLIB_STATIC_ONLY)
    delete[] buffOut;
    2d66:	a1 14       	cp	r10, r1
    2d68:	b1 04       	cpc	r11, r1
    2d6a:	19 f0       	breq	.+6      	; 0x2d72 <_ZN6Module11SPItransferEhjPhS0_j+0x154>
    2d6c:	c5 01       	movw	r24, r10
    2d6e:	0e 94 02 0f 	call	0x1e04	; 0x1e04 <_ZdaPv>
    delete[] buffIn;
    2d72:	61 14       	cp	r6, r1
    2d74:	71 04       	cpc	r7, r1
    2d76:	19 f0       	breq	.+6      	; 0x2d7e <_ZN6Module11SPItransferEhjPhS0_j+0x160>
    2d78:	c3 01       	movw	r24, r6
    2d7a:	0e 94 02 0f 	call	0x1e04	; 0x1e04 <_ZdaPv>
  #endif
}
    2d7e:	0f 90       	pop	r0
    2d80:	0f 90       	pop	r0
    2d82:	0f 90       	pop	r0
    2d84:	0f 90       	pop	r0
    2d86:	df 91       	pop	r29
    2d88:	cf 91       	pop	r28
    2d8a:	1f 91       	pop	r17
    2d8c:	0f 91       	pop	r16
    2d8e:	ff 90       	pop	r15
    2d90:	ef 90       	pop	r14
    2d92:	df 90       	pop	r13
    2d94:	cf 90       	pop	r12
    2d96:	bf 90       	pop	r11
    2d98:	af 90       	pop	r10
    2d9a:	9f 90       	pop	r9
    2d9c:	8f 90       	pop	r8
    2d9e:	7f 90       	pop	r7
    2da0:	6f 90       	pop	r6
    2da2:	5f 90       	pop	r5
    2da4:	4f 90       	pop	r4
    2da6:	3f 90       	pop	r3
    2da8:	08 95       	ret

  // copy the command
  if(this->SPIaddrWidth <= 8) {
    *(buffOutPtr++) = reg | cmd;
  } else {
    *(buffOutPtr++) = (reg >> 8) | cmd;
    2daa:	39 28       	or	r3, r9
    2dac:	f5 01       	movw	r30, r10
    2dae:	30 82       	st	Z, r3
    *(buffOutPtr++) = reg & 0xFF;
    2db0:	c5 01       	movw	r24, r10
    2db2:	02 96       	adiw	r24, 0x02	; 2
    2db4:	81 82       	std	Z+1, r8	; 0x01
    2db6:	6c cf       	rjmp	.-296    	; 0x2c90 <_ZN6Module11SPItransferEhjPhS0_j+0x72>
  }

  // copy the data
  if(cmd == SPIwriteCommand) {
    memcpy(buffOutPtr, dataOut, numBytes);
    2db8:	a7 01       	movw	r20, r14
    2dba:	b2 01       	movw	r22, r4
    2dbc:	0e 94 bd 3e 	call	0x7d7a	; 0x7d7a <memcpy>
    2dc0:	75 cf       	rjmp	.-278    	; 0x2cac <_ZN6Module11SPItransferEhjPhS0_j+0x8e>
  this->hal->digitalWrite(this->csPin, this->hal->GpioLevelHigh);
  this->hal->spiEndTransaction();
  
  // copy the data
  if(cmd == SPIreadCommand) {
    memcpy(dataIn, &buffIn[this->SPIaddrWidth/8], numBytes);
    2dc2:	66 81       	ldd	r22, Z+6	; 0x06
    2dc4:	66 95       	lsr	r22
    2dc6:	66 95       	lsr	r22
    2dc8:	66 95       	lsr	r22
    2dca:	66 0d       	add	r22, r6
    2dcc:	77 2d       	mov	r23, r7
    2dce:	71 1d       	adc	r23, r1
    2dd0:	a7 01       	movw	r20, r14
    2dd2:	89 81       	ldd	r24, Y+1	; 0x01
    2dd4:	9a 81       	ldd	r25, Y+2	; 0x02
    2dd6:	0e 94 bd 3e 	call	0x7d7a	; 0x7d7a <memcpy>
    2dda:	c5 cf       	rjmp	.-118    	; 0x2d66 <_ZN6Module11SPItransferEhjPhS0_j+0x148>

00002ddc <_ZN6Module16SPIwriteRegisterEjh>:
    uint8_t cmd[] = { SPIwriteCommand, (uint8_t)((reg >> 8) & 0xFF), (uint8_t)(reg & 0xFF) };
    SPItransferStream(cmd, 3, true, data, NULL, numBytes, true, RADIOLIB_MODULE_SPI_TIMEOUT);
  }
}

void Module::SPIwriteRegister(uint16_t reg, uint8_t data) {
    2ddc:	af 92       	push	r10
    2dde:	cf 92       	push	r12
    2de0:	df 92       	push	r13
    2de2:	ef 92       	push	r14
    2de4:	ff 92       	push	r15
    2de6:	0f 93       	push	r16
    2de8:	1f 93       	push	r17
    2dea:	cf 93       	push	r28
    2dec:	df 93       	push	r29
    2dee:	00 d0       	rcall	.+0      	; 0x2df0 <_ZN6Module16SPIwriteRegisterEjh+0x14>
    2df0:	00 d0       	rcall	.+0      	; 0x2df2 <_ZN6Module16SPIwriteRegisterEjh+0x16>
    2df2:	cd b7       	in	r28, 0x3d	; 61
    2df4:	de b7       	in	r29, 0x3e	; 62
    2df6:	4c 83       	std	Y+4, r20	; 0x04
  if(!SPIstreamType) {
    2df8:	fc 01       	movw	r30, r24
    2dfa:	27 81       	ldd	r18, Z+7	; 0x07
    2dfc:	22 23       	and	r18, r18
    2dfe:	69 f1       	breq	.+90     	; 0x2e5a <_ZN6Module16SPIwriteRegisterEjh+0x7e>
    SPItransfer(SPIwriteCommand, reg, &data, NULL, 1);
  } else {
    uint8_t cmd[] = { SPIwriteCommand, (uint8_t)((reg >> 8) & 0xFF), (uint8_t)(reg & 0xFF) };
    2e00:	23 81       	ldd	r18, Z+3	; 0x03
    2e02:	29 83       	std	Y+1, r18	; 0x01
    2e04:	7a 83       	std	Y+2, r23	; 0x02
    2e06:	6b 83       	std	Y+3, r22	; 0x03
    SPItransferStream(cmd, 3, true, &data, NULL, 1, true, RADIOLIB_MODULE_SPI_TIMEOUT);
    2e08:	1f 92       	push	r1
    2e0a:	1f 92       	push	r1
    2e0c:	23 e0       	ldi	r18, 0x03	; 3
    2e0e:	2f 93       	push	r18
    2e10:	28 ee       	ldi	r18, 0xE8	; 232
    2e12:	2f 93       	push	r18
    2e14:	aa 24       	eor	r10, r10
    2e16:	a3 94       	inc	r10
    2e18:	cc 24       	eor	r12, r12
    2e1a:	c3 94       	inc	r12
    2e1c:	d1 2c       	mov	r13, r1
    2e1e:	f1 2c       	mov	r15, r1
    2e20:	e1 2c       	mov	r14, r1
    2e22:	8e 01       	movw	r16, r28
    2e24:	0c 5f       	subi	r16, 0xFC	; 252
    2e26:	1f 4f       	sbci	r17, 0xFF	; 255
    2e28:	21 e0       	ldi	r18, 0x01	; 1
    2e2a:	43 e0       	ldi	r20, 0x03	; 3
    2e2c:	be 01       	movw	r22, r28
    2e2e:	6f 5f       	subi	r22, 0xFF	; 255
    2e30:	7f 4f       	sbci	r23, 0xFF	; 255
    2e32:	0e 94 22 14 	call	0x2844	; 0x2844 <_ZN6Module17SPItransferStreamEPhhbS0_S0_jbm>
    2e36:	0f 90       	pop	r0
    2e38:	0f 90       	pop	r0
    2e3a:	0f 90       	pop	r0
    2e3c:	0f 90       	pop	r0
  }
}
    2e3e:	0f 90       	pop	r0
    2e40:	0f 90       	pop	r0
    2e42:	0f 90       	pop	r0
    2e44:	0f 90       	pop	r0
    2e46:	df 91       	pop	r29
    2e48:	cf 91       	pop	r28
    2e4a:	1f 91       	pop	r17
    2e4c:	0f 91       	pop	r16
    2e4e:	ff 90       	pop	r15
    2e50:	ef 90       	pop	r14
    2e52:	df 90       	pop	r13
    2e54:	cf 90       	pop	r12
    2e56:	af 90       	pop	r10
    2e58:	08 95       	ret
  }
}

void Module::SPIwriteRegister(uint16_t reg, uint8_t data) {
  if(!SPIstreamType) {
    SPItransfer(SPIwriteCommand, reg, &data, NULL, 1);
    2e5a:	ee 24       	eor	r14, r14
    2e5c:	e3 94       	inc	r14
    2e5e:	f1 2c       	mov	r15, r1
    2e60:	10 e0       	ldi	r17, 0x00	; 0
    2e62:	00 e0       	ldi	r16, 0x00	; 0
    2e64:	9e 01       	movw	r18, r28
    2e66:	2c 5f       	subi	r18, 0xFC	; 252
    2e68:	3f 4f       	sbci	r19, 0xFF	; 255
    2e6a:	46 2f       	mov	r20, r22
    2e6c:	57 2f       	mov	r21, r23
    2e6e:	63 81       	ldd	r22, Z+3	; 0x03
    2e70:	0e 94 0f 16 	call	0x2c1e	; 0x2c1e <_ZN6Module11SPItransferEhjPhS0_j>
    2e74:	e4 cf       	rjmp	.-56     	; 0x2e3e <_ZN6Module16SPIwriteRegisterEjh+0x62>

00002e76 <_ZN6Module21SPIwriteRegisterBurstEjPhj>:
    SPItransferStream(cmd, 3, false, NULL, &resp, 1, true, RADIOLIB_MODULE_SPI_TIMEOUT);
  }
  return(resp);
}

void Module::SPIwriteRegisterBurst(uint16_t reg, uint8_t* data, size_t numBytes) {
    2e76:	af 92       	push	r10
    2e78:	cf 92       	push	r12
    2e7a:	df 92       	push	r13
    2e7c:	ef 92       	push	r14
    2e7e:	ff 92       	push	r15
    2e80:	0f 93       	push	r16
    2e82:	1f 93       	push	r17
    2e84:	cf 93       	push	r28
    2e86:	df 93       	push	r29
    2e88:	00 d0       	rcall	.+0      	; 0x2e8a <_ZN6Module21SPIwriteRegisterBurstEjPhj+0x14>
    2e8a:	1f 92       	push	r1
    2e8c:	cd b7       	in	r28, 0x3d	; 61
    2e8e:	de b7       	in	r29, 0x3e	; 62
  if(!SPIstreamType) {
    2e90:	dc 01       	movw	r26, r24
    2e92:	17 96       	adiw	r26, 0x07	; 7
    2e94:	ec 91       	ld	r30, X
    2e96:	17 97       	sbiw	r26, 0x07	; 7
    2e98:	ee 23       	and	r30, r30
    2e9a:	49 f1       	breq	.+82     	; 0x2eee <_ZN6Module21SPIwriteRegisterBurstEjPhj+0x78>
    SPItransfer(SPIwriteCommand, reg, data, NULL, numBytes);
  } else {
    uint8_t cmd[] = { SPIwriteCommand, (uint8_t)((reg >> 8) & 0xFF), (uint8_t)(reg & 0xFF) };
    2e9c:	13 96       	adiw	r26, 0x03	; 3
    2e9e:	ec 91       	ld	r30, X
    2ea0:	e9 83       	std	Y+1, r30	; 0x01
    2ea2:	7a 83       	std	Y+2, r23	; 0x02
    2ea4:	6b 83       	std	Y+3, r22	; 0x03
    SPItransferStream(cmd, 3, true, data, NULL, numBytes, true, RADIOLIB_MODULE_SPI_TIMEOUT);
    2ea6:	1f 92       	push	r1
    2ea8:	1f 92       	push	r1
    2eaa:	63 e0       	ldi	r22, 0x03	; 3
    2eac:	6f 93       	push	r22
    2eae:	68 ee       	ldi	r22, 0xE8	; 232
    2eb0:	6f 93       	push	r22
    2eb2:	aa 24       	eor	r10, r10
    2eb4:	a3 94       	inc	r10
    2eb6:	69 01       	movw	r12, r18
    2eb8:	f1 2c       	mov	r15, r1
    2eba:	e1 2c       	mov	r14, r1
    2ebc:	8a 01       	movw	r16, r20
    2ebe:	21 e0       	ldi	r18, 0x01	; 1
    2ec0:	43 e0       	ldi	r20, 0x03	; 3
    2ec2:	be 01       	movw	r22, r28
    2ec4:	6f 5f       	subi	r22, 0xFF	; 255
    2ec6:	7f 4f       	sbci	r23, 0xFF	; 255
    2ec8:	0e 94 22 14 	call	0x2844	; 0x2844 <_ZN6Module17SPItransferStreamEPhhbS0_S0_jbm>
    2ecc:	0f 90       	pop	r0
    2ece:	0f 90       	pop	r0
    2ed0:	0f 90       	pop	r0
    2ed2:	0f 90       	pop	r0
  }
}
    2ed4:	0f 90       	pop	r0
    2ed6:	0f 90       	pop	r0
    2ed8:	0f 90       	pop	r0
    2eda:	df 91       	pop	r29
    2edc:	cf 91       	pop	r28
    2ede:	1f 91       	pop	r17
    2ee0:	0f 91       	pop	r16
    2ee2:	ff 90       	pop	r15
    2ee4:	ef 90       	pop	r14
    2ee6:	df 90       	pop	r13
    2ee8:	cf 90       	pop	r12
    2eea:	af 90       	pop	r10
    2eec:	08 95       	ret
  return(resp);
}

void Module::SPIwriteRegisterBurst(uint16_t reg, uint8_t* data, size_t numBytes) {
  if(!SPIstreamType) {
    SPItransfer(SPIwriteCommand, reg, data, NULL, numBytes);
    2eee:	79 01       	movw	r14, r18
    2ef0:	10 e0       	ldi	r17, 0x00	; 0
    2ef2:	00 e0       	ldi	r16, 0x00	; 0
    2ef4:	9a 01       	movw	r18, r20
    2ef6:	46 2f       	mov	r20, r22
    2ef8:	57 2f       	mov	r21, r23
    2efa:	13 96       	adiw	r26, 0x03	; 3
    2efc:	6c 91       	ld	r22, X
    2efe:	0e 94 0f 16 	call	0x2c1e	; 0x2c1e <_ZN6Module11SPItransferEhjPhS0_j>
    2f02:	e8 cf       	rjmp	.-48     	; 0x2ed4 <_ZN6Module21SPIwriteRegisterBurstEjPhj+0x5e>

00002f04 <_ZN6Module15SPIreadRegisterEj>:
    uint8_t cmd[] = { SPIreadCommand, (uint8_t)((reg >> 8) & 0xFF), (uint8_t)(reg & 0xFF) };
    SPItransferStream(cmd, 3, false, NULL, inBytes, numBytes, true, RADIOLIB_MODULE_SPI_TIMEOUT);
  }
}

uint8_t Module::SPIreadRegister(uint16_t reg) {
    2f04:	af 92       	push	r10
    2f06:	cf 92       	push	r12
    2f08:	df 92       	push	r13
    2f0a:	ef 92       	push	r14
    2f0c:	ff 92       	push	r15
    2f0e:	0f 93       	push	r16
    2f10:	1f 93       	push	r17
    2f12:	cf 93       	push	r28
    2f14:	df 93       	push	r29
    2f16:	00 d0       	rcall	.+0      	; 0x2f18 <_ZN6Module15SPIreadRegisterEj+0x14>
    2f18:	00 d0       	rcall	.+0      	; 0x2f1a <_ZN6Module15SPIreadRegisterEj+0x16>
    2f1a:	cd b7       	in	r28, 0x3d	; 61
    2f1c:	de b7       	in	r29, 0x3e	; 62
  uint8_t resp = 0;
    2f1e:	19 82       	std	Y+1, r1	; 0x01
  if(!SPIstreamType) {
    2f20:	fc 01       	movw	r30, r24
    2f22:	27 81       	ldd	r18, Z+7	; 0x07
    2f24:	22 23       	and	r18, r18
    2f26:	79 f1       	breq	.+94     	; 0x2f86 <_ZN6Module15SPIreadRegisterEj+0x82>
    SPItransfer(SPIreadCommand, reg, NULL, &resp, 1);
  } else {
    uint8_t cmd[] = { SPIreadCommand, (uint8_t)((reg >> 8) & 0xFF), (uint8_t)(reg & 0xFF) };
    2f28:	22 81       	ldd	r18, Z+2	; 0x02
    2f2a:	2a 83       	std	Y+2, r18	; 0x02
    2f2c:	7b 83       	std	Y+3, r23	; 0x03
    2f2e:	6c 83       	std	Y+4, r22	; 0x04
    SPItransferStream(cmd, 3, false, NULL, &resp, 1, true, RADIOLIB_MODULE_SPI_TIMEOUT);
    2f30:	1f 92       	push	r1
    2f32:	1f 92       	push	r1
    2f34:	23 e0       	ldi	r18, 0x03	; 3
    2f36:	2f 93       	push	r18
    2f38:	28 ee       	ldi	r18, 0xE8	; 232
    2f3a:	2f 93       	push	r18
    2f3c:	aa 24       	eor	r10, r10
    2f3e:	a3 94       	inc	r10
    2f40:	cc 24       	eor	r12, r12
    2f42:	c3 94       	inc	r12
    2f44:	d1 2c       	mov	r13, r1
    2f46:	9e 01       	movw	r18, r28
    2f48:	2f 5f       	subi	r18, 0xFF	; 255
    2f4a:	3f 4f       	sbci	r19, 0xFF	; 255
    2f4c:	79 01       	movw	r14, r18
    2f4e:	10 e0       	ldi	r17, 0x00	; 0
    2f50:	00 e0       	ldi	r16, 0x00	; 0
    2f52:	20 e0       	ldi	r18, 0x00	; 0
    2f54:	43 e0       	ldi	r20, 0x03	; 3
    2f56:	be 01       	movw	r22, r28
    2f58:	6e 5f       	subi	r22, 0xFE	; 254
    2f5a:	7f 4f       	sbci	r23, 0xFF	; 255
    2f5c:	0e 94 22 14 	call	0x2844	; 0x2844 <_ZN6Module17SPItransferStreamEPhhbS0_S0_jbm>
    2f60:	0f 90       	pop	r0
    2f62:	0f 90       	pop	r0
    2f64:	0f 90       	pop	r0
    2f66:	0f 90       	pop	r0
  }
  return(resp);
}
    2f68:	89 81       	ldd	r24, Y+1	; 0x01
    2f6a:	0f 90       	pop	r0
    2f6c:	0f 90       	pop	r0
    2f6e:	0f 90       	pop	r0
    2f70:	0f 90       	pop	r0
    2f72:	df 91       	pop	r29
    2f74:	cf 91       	pop	r28
    2f76:	1f 91       	pop	r17
    2f78:	0f 91       	pop	r16
    2f7a:	ff 90       	pop	r15
    2f7c:	ef 90       	pop	r14
    2f7e:	df 90       	pop	r13
    2f80:	cf 90       	pop	r12
    2f82:	af 90       	pop	r10
    2f84:	08 95       	ret
}

uint8_t Module::SPIreadRegister(uint16_t reg) {
  uint8_t resp = 0;
  if(!SPIstreamType) {
    SPItransfer(SPIreadCommand, reg, NULL, &resp, 1);
    2f86:	ee 24       	eor	r14, r14
    2f88:	e3 94       	inc	r14
    2f8a:	f1 2c       	mov	r15, r1
    2f8c:	8e 01       	movw	r16, r28
    2f8e:	0f 5f       	subi	r16, 0xFF	; 255
    2f90:	1f 4f       	sbci	r17, 0xFF	; 255
    2f92:	30 e0       	ldi	r19, 0x00	; 0
    2f94:	20 e0       	ldi	r18, 0x00	; 0
    2f96:	46 2f       	mov	r20, r22
    2f98:	57 2f       	mov	r21, r23
    2f9a:	62 81       	ldd	r22, Z+2	; 0x02
    2f9c:	0e 94 0f 16 	call	0x2c1e	; 0x2c1e <_ZN6Module11SPItransferEhjPhS0_j>
    2fa0:	e3 cf       	rjmp	.-58     	; 0x2f68 <_ZN6Module15SPIreadRegisterEj+0x64>

00002fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>:
  uint8_t rawValue = SPIreadRegister(reg);
  uint8_t maskedValue = rawValue & ((0b11111111 << lsb) & (0b11111111 >> (7 - msb)));
  return(maskedValue);
}

int16_t Module::SPIsetRegValue(uint16_t reg, uint8_t value, uint8_t msb, uint8_t lsb, uint8_t checkInterval, uint8_t checkMask) {
    2fa2:	2f 92       	push	r2
    2fa4:	3f 92       	push	r3
    2fa6:	4f 92       	push	r4
    2fa8:	5f 92       	push	r5
    2faa:	6f 92       	push	r6
    2fac:	7f 92       	push	r7
    2fae:	8f 92       	push	r8
    2fb0:	9f 92       	push	r9
    2fb2:	af 92       	push	r10
    2fb4:	bf 92       	push	r11
    2fb6:	cf 92       	push	r12
    2fb8:	ef 92       	push	r14
    2fba:	0f 93       	push	r16
    2fbc:	1f 93       	push	r17
    2fbe:	cf 93       	push	r28
    2fc0:	df 93       	push	r29
  if((msb > 7) || (lsb > 7) || (lsb > msb)) {
    2fc2:	28 30       	cpi	r18, 0x08	; 8
    2fc4:	08 f0       	brcs	.+2      	; 0x2fc8 <_ZN6Module14SPIsetRegValueEjhhhhh+0x26>
    2fc6:	62 c0       	rjmp	.+196    	; 0x308c <_ZN6Module14SPIsetRegValueEjhhhhh+0xea>
    2fc8:	08 30       	cpi	r16, 0x08	; 8
    2fca:	08 f0       	brcs	.+2      	; 0x2fce <_ZN6Module14SPIsetRegValueEjhhhhh+0x2c>
    2fcc:	62 c0       	rjmp	.+196    	; 0x3092 <_ZN6Module14SPIsetRegValueEjhhhhh+0xf0>
    2fce:	20 17       	cp	r18, r16
    2fd0:	08 f4       	brcc	.+2      	; 0x2fd4 <_ZN6Module14SPIsetRegValueEjhhhhh+0x32>
    2fd2:	62 c0       	rjmp	.+196    	; 0x3098 <_ZN6Module14SPIsetRegValueEjhhhhh+0xf6>
    2fd4:	72 2e       	mov	r7, r18
    2fd6:	64 2e       	mov	r6, r20
    2fd8:	1b 01       	movw	r2, r22
    2fda:	ec 01       	movw	r28, r24
    return(RADIOLIB_ERR_INVALID_BIT_RANGE);
  }

  uint8_t currentValue = SPIreadRegister(reg);
    2fdc:	0e 94 82 17 	call	0x2f04	; 0x2f04 <_ZN6Module15SPIreadRegisterEj>
  uint8_t mask = ~((0b11111111 << (msb + 1)) | (0b11111111 >> (8 - lsb)));
    2fe0:	27 2d       	mov	r18, r7
    2fe2:	30 e0       	ldi	r19, 0x00	; 0
    2fe4:	2f 5f       	subi	r18, 0xFF	; 255
    2fe6:	3f 4f       	sbci	r19, 0xFF	; 255
    2fe8:	6f ef       	ldi	r22, 0xFF	; 255
    2fea:	70 e0       	ldi	r23, 0x00	; 0
    2fec:	ab 01       	movw	r20, r22
    2fee:	02 c0       	rjmp	.+4      	; 0x2ff4 <_ZN6Module14SPIsetRegValueEjhhhhh+0x52>
    2ff0:	44 0f       	add	r20, r20
    2ff2:	55 1f       	adc	r21, r21
    2ff4:	2a 95       	dec	r18
    2ff6:	e2 f7       	brpl	.-8      	; 0x2ff0 <_ZN6Module14SPIsetRegValueEjhhhhh+0x4e>
    2ff8:	9a 01       	movw	r18, r20
    2ffa:	48 e0       	ldi	r20, 0x08	; 8
    2ffc:	50 e0       	ldi	r21, 0x00	; 0
    2ffe:	40 1b       	sub	r20, r16
    3000:	51 09       	sbc	r21, r1
    3002:	02 c0       	rjmp	.+4      	; 0x3008 <_ZN6Module14SPIsetRegValueEjhhhhh+0x66>
    3004:	75 95       	asr	r23
    3006:	67 95       	ror	r22
    3008:	4a 95       	dec	r20
    300a:	e2 f7       	brpl	.-8      	; 0x3004 <_ZN6Module14SPIsetRegValueEjhhhhh+0x62>
    300c:	26 2b       	or	r18, r22
    300e:	20 95       	com	r18
  uint8_t newValue = (currentValue & ~mask) | (value & mask);
    3010:	12 2f       	mov	r17, r18
    3012:	10 95       	com	r17
    3014:	18 23       	and	r17, r24
    3016:	26 21       	and	r18, r6
    3018:	12 2b       	or	r17, r18
  SPIwriteRegister(reg, newValue);
    301a:	41 2f       	mov	r20, r17
    301c:	b1 01       	movw	r22, r2
    301e:	ce 01       	movw	r24, r28
    3020:	0e 94 ee 16 	call	0x2ddc	; 0x2ddc <_ZN6Module16SPIwriteRegisterEjh>

  #if defined(RADIOLIB_SPI_PARANOID)
    // check register value each millisecond until check interval is reached
    // some registers need a bit of time to process the change (e.g. SX127X_REG_OP_MODE)
    uint32_t start = this->hal->micros();
    3024:	88 81       	ld	r24, Y
    3026:	99 81       	ldd	r25, Y+1	; 0x01
    3028:	dc 01       	movw	r26, r24
    302a:	ed 91       	ld	r30, X+
    302c:	fc 91       	ld	r31, X
    302e:	00 88       	ldd	r0, Z+16	; 0x10
    3030:	f1 89       	ldd	r31, Z+17	; 0x11
    3032:	e0 2d       	mov	r30, r0
    3034:	09 95       	icall
    3036:	2b 01       	movw	r4, r22
    3038:	3c 01       	movw	r6, r24
    uint8_t readValue = 0x00;
    while(this->hal->micros() - start < (checkInterval * 1000)) {
    303a:	88 81       	ld	r24, Y
    303c:	99 81       	ldd	r25, Y+1	; 0x01
    303e:	dc 01       	movw	r26, r24
    3040:	ed 91       	ld	r30, X+
    3042:	fc 91       	ld	r31, X
    3044:	00 88       	ldd	r0, Z+16	; 0x10
    3046:	f1 89       	ldd	r31, Z+17	; 0x11
    3048:	e0 2d       	mov	r30, r0
    304a:	09 95       	icall
    304c:	4b 01       	movw	r8, r22
    304e:	5c 01       	movw	r10, r24
    3050:	84 18       	sub	r8, r4
    3052:	95 08       	sbc	r9, r5
    3054:	a6 08       	sbc	r10, r6
    3056:	b7 08       	sbc	r11, r7
    3058:	88 ee       	ldi	r24, 0xE8	; 232
    305a:	93 e0       	ldi	r25, 0x03	; 3
    305c:	e8 9e       	mul	r14, r24
    305e:	a0 01       	movw	r20, r0
    3060:	e9 9e       	mul	r14, r25
    3062:	50 0d       	add	r21, r0
    3064:	11 24       	eor	r1, r1
    3066:	05 2e       	mov	r0, r21
    3068:	00 0c       	add	r0, r0
    306a:	66 0b       	sbc	r22, r22
    306c:	77 0b       	sbc	r23, r23
    306e:	84 16       	cp	r8, r20
    3070:	95 06       	cpc	r9, r21
    3072:	a6 06       	cpc	r10, r22
    3074:	b7 06       	cpc	r11, r23
    3076:	98 f4       	brcc	.+38     	; 0x309e <_ZN6Module14SPIsetRegValueEjhhhhh+0xfc>
      readValue = SPIreadRegister(reg);
    3078:	b1 01       	movw	r22, r2
    307a:	ce 01       	movw	r24, r28
    307c:	0e 94 82 17 	call	0x2f04	; 0x2f04 <_ZN6Module15SPIreadRegisterEj>
      if((readValue & checkMask) == (newValue & checkMask)) {
    3080:	81 27       	eor	r24, r17
    3082:	8c 21       	and	r24, r12
    3084:	d1 f6       	brne	.-76     	; 0x303a <_ZN6Module14SPIsetRegValueEjhhhhh+0x98>
        // check passed, we can stop the loop
        return(RADIOLIB_ERR_NONE);
    3086:	90 e0       	ldi	r25, 0x00	; 0
    3088:	80 e0       	ldi	r24, 0x00	; 0
    308a:	0b c0       	rjmp	.+22     	; 0x30a2 <_ZN6Module14SPIsetRegValueEjhhhhh+0x100>
  return(maskedValue);
}

int16_t Module::SPIsetRegValue(uint16_t reg, uint8_t value, uint8_t msb, uint8_t lsb, uint8_t checkInterval, uint8_t checkMask) {
  if((msb > 7) || (lsb > 7) || (lsb > msb)) {
    return(RADIOLIB_ERR_INVALID_BIT_RANGE);
    308c:	85 ef       	ldi	r24, 0xF5	; 245
    308e:	9f ef       	ldi	r25, 0xFF	; 255
    3090:	08 c0       	rjmp	.+16     	; 0x30a2 <_ZN6Module14SPIsetRegValueEjhhhhh+0x100>
    3092:	85 ef       	ldi	r24, 0xF5	; 245
    3094:	9f ef       	ldi	r25, 0xFF	; 255
    3096:	05 c0       	rjmp	.+10     	; 0x30a2 <_ZN6Module14SPIsetRegValueEjhhhhh+0x100>
    3098:	85 ef       	ldi	r24, 0xF5	; 245
    309a:	9f ef       	ldi	r25, 0xFF	; 255
    309c:	02 c0       	rjmp	.+4      	; 0x30a2 <_ZN6Module14SPIsetRegValueEjhhhhh+0x100>
    RADIOLIB_DEBUG_PRINTLN("current:\t0x%X", currentValue);
    RADIOLIB_DEBUG_PRINTLN("mask:\t\t0x%X", mask);
    RADIOLIB_DEBUG_PRINTLN("new:\t\t0x%X", newValue);
    RADIOLIB_DEBUG_PRINTLN("read:\t\t0x%X", readValue);

    return(RADIOLIB_ERR_SPI_WRITE_FAILED);
    309e:	80 ef       	ldi	r24, 0xF0	; 240
    30a0:	9f ef       	ldi	r25, 0xFF	; 255
  #else
    return(RADIOLIB_ERR_NONE);
  #endif
}
    30a2:	df 91       	pop	r29
    30a4:	cf 91       	pop	r28
    30a6:	1f 91       	pop	r17
    30a8:	0f 91       	pop	r16
    30aa:	ef 90       	pop	r14
    30ac:	cf 90       	pop	r12
    30ae:	bf 90       	pop	r11
    30b0:	af 90       	pop	r10
    30b2:	9f 90       	pop	r9
    30b4:	8f 90       	pop	r8
    30b6:	7f 90       	pop	r7
    30b8:	6f 90       	pop	r6
    30ba:	5f 90       	pop	r5
    30bc:	4f 90       	pop	r4
    30be:	3f 90       	pop	r3
    30c0:	2f 90       	pop	r2
    30c2:	08 95       	ret

000030c4 <_ZN6SX127x13setDIOMappingEmm>:
  } else if(modem == RADIOLIB_SX127X_FSK_OOK) {
    return; //These are not the interrupts you are looking for
  }
}

int16_t SX127x::setDIOMapping(uint32_t pin, uint32_t value) {
    30c4:	cf 92       	push	r12
    30c6:	ef 92       	push	r14
    30c8:	0f 93       	push	r16
  if (pin > 5)
    30ca:	46 30       	cpi	r20, 0x06	; 6
    30cc:	51 05       	cpc	r21, r1
    30ce:	61 05       	cpc	r22, r1
    30d0:	71 05       	cpc	r23, r1
    30d2:	d8 f5       	brcc	.+118    	; 0x314a <_ZN6SX127x13setDIOMappingEmm+0x86>
    30d4:	30 2f       	mov	r19, r16
    return RADIOLIB_ERR_INVALID_DIO_PIN;

  if (pin < 4)
    30d6:	44 30       	cpi	r20, 0x04	; 4
    30d8:	51 05       	cpc	r21, r1
    30da:	61 05       	cpc	r22, r1
    30dc:	71 05       	cpc	r23, r1
    30de:	e0 f0       	brcs	.+56     	; 0x3118 <_ZN6SX127x13setDIOMappingEmm+0x54>
    return(this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_DIO_MAPPING_1, value, 7 - 2 * pin, 6 - 2 * pin));
  else
    return(this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_DIO_MAPPING_2, value, 15 - 2 * pin, 14 - 2 * pin));
    30e0:	fc 01       	movw	r30, r24
    30e2:	e7 5e       	subi	r30, 0xE7	; 231
    30e4:	fe 4f       	sbci	r31, 0xFE	; 254
    30e6:	84 2f       	mov	r24, r20
    30e8:	81 95       	neg	r24
    30ea:	08 2f       	mov	r16, r24
    30ec:	00 0f       	add	r16, r16
    30ee:	02 5f       	subi	r16, 0xF2	; 242
    30f0:	94 2f       	mov	r25, r20
    30f2:	99 0f       	add	r25, r25
    30f4:	2f e0       	ldi	r18, 0x0F	; 15
    30f6:	29 1b       	sub	r18, r25
    30f8:	cc 24       	eor	r12, r12
    30fa:	ca 94       	dec	r12
    30fc:	68 94       	set
    30fe:	ee 24       	eor	r14, r14
    3100:	e1 f8       	bld	r14, 1
    3102:	43 2f       	mov	r20, r19
    3104:	61 e4       	ldi	r22, 0x41	; 65
    3106:	70 e0       	ldi	r23, 0x00	; 0
    3108:	80 81       	ld	r24, Z
    310a:	91 81       	ldd	r25, Z+1	; 0x01
    310c:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
}
    3110:	0f 91       	pop	r16
    3112:	ef 90       	pop	r14
    3114:	cf 90       	pop	r12
    3116:	08 95       	ret
int16_t SX127x::setDIOMapping(uint32_t pin, uint32_t value) {
  if (pin > 5)
    return RADIOLIB_ERR_INVALID_DIO_PIN;

  if (pin < 4)
    return(this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_DIO_MAPPING_1, value, 7 - 2 * pin, 6 - 2 * pin));
    3118:	fc 01       	movw	r30, r24
    311a:	e7 5e       	subi	r30, 0xE7	; 231
    311c:	fe 4f       	sbci	r31, 0xFE	; 254
    311e:	94 2f       	mov	r25, r20
    3120:	91 95       	neg	r25
    3122:	09 2f       	mov	r16, r25
    3124:	00 0f       	add	r16, r16
    3126:	0a 5f       	subi	r16, 0xFA	; 250
    3128:	94 2f       	mov	r25, r20
    312a:	99 0f       	add	r25, r25
    312c:	27 e0       	ldi	r18, 0x07	; 7
    312e:	29 1b       	sub	r18, r25
    3130:	cc 24       	eor	r12, r12
    3132:	ca 94       	dec	r12
    3134:	68 94       	set
    3136:	ee 24       	eor	r14, r14
    3138:	e1 f8       	bld	r14, 1
    313a:	43 2f       	mov	r20, r19
    313c:	60 e4       	ldi	r22, 0x40	; 64
    313e:	70 e0       	ldi	r23, 0x00	; 0
    3140:	80 81       	ld	r24, Z
    3142:	91 81       	ldd	r25, Z+1	; 0x01
    3144:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    3148:	e3 cf       	rjmp	.-58     	; 0x3110 <_ZN6SX127x13setDIOMappingEmm+0x4c>
  }
}

int16_t SX127x::setDIOMapping(uint32_t pin, uint32_t value) {
  if (pin > 5)
    return RADIOLIB_ERR_INVALID_DIO_PIN;
    314a:	86 ee       	ldi	r24, 0xE6	; 230
    314c:	9f ef       	ldi	r25, 0xFF	; 255
    314e:	e0 cf       	rjmp	.-64     	; 0x3110 <_ZN6SX127x13setDIOMappingEmm+0x4c>

00003150 <_ZN6SX127x6configEv>:
  this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_OP_MODE, previousOpMode);

  return(temp);
}

int16_t SX127x::config() {
    3150:	cf 92       	push	r12
    3152:	ef 92       	push	r14
    3154:	0f 93       	push	r16
  // turn off frequency hopping
  int16_t state = this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_HOP_PERIOD, RADIOLIB_SX127X_HOP_PERIOD_OFF);
    3156:	87 5e       	subi	r24, 0xE7	; 231
    3158:	9e 4f       	sbci	r25, 0xFE	; 254
    315a:	cc 24       	eor	r12, r12
    315c:	ca 94       	dec	r12
    315e:	68 94       	set
    3160:	ee 24       	eor	r14, r14
    3162:	e1 f8       	bld	r14, 1
    3164:	00 e0       	ldi	r16, 0x00	; 0
    3166:	27 e0       	ldi	r18, 0x07	; 7
    3168:	40 e0       	ldi	r20, 0x00	; 0
    316a:	64 e2       	ldi	r22, 0x24	; 36
    316c:	70 e0       	ldi	r23, 0x00	; 0
    316e:	fc 01       	movw	r30, r24
    3170:	80 81       	ld	r24, Z
    3172:	91 81       	ldd	r25, Z+1	; 0x01
    3174:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
  return(state);
}
    3178:	0f 91       	pop	r16
    317a:	ef 90       	pop	r14
    317c:	cf 90       	pop	r12
    317e:	08 95       	ret

00003180 <_ZN6Module14SPIgetRegValueEjhh>:
void Module::term() {
  // stop hardware interfaces (if they were initialized by the library)
  this->hal->term();
}

int16_t Module::SPIgetRegValue(uint16_t reg, uint8_t msb, uint8_t lsb) {
    3180:	cf 93       	push	r28
    3182:	df 93       	push	r29
  if((msb > 7) || (lsb > 7) || (lsb > msb)) {
    3184:	48 30       	cpi	r20, 0x08	; 8
    3186:	f8 f4       	brcc	.+62     	; 0x31c6 <_ZN6Module14SPIgetRegValueEjhh+0x46>
    3188:	28 30       	cpi	r18, 0x08	; 8
    318a:	00 f5       	brcc	.+64     	; 0x31cc <_ZN6Module14SPIgetRegValueEjhh+0x4c>
    318c:	42 17       	cp	r20, r18
    318e:	08 f1       	brcs	.+66     	; 0x31d2 <_ZN6Module14SPIgetRegValueEjhh+0x52>
    3190:	d2 2f       	mov	r29, r18
    3192:	c4 2f       	mov	r28, r20
    return(RADIOLIB_ERR_INVALID_BIT_RANGE);
  }

  uint8_t rawValue = SPIreadRegister(reg);
    3194:	0e 94 82 17 	call	0x2f04	; 0x2f04 <_ZN6Module15SPIreadRegisterEj>
  uint8_t maskedValue = rawValue & ((0b11111111 << lsb) & (0b11111111 >> (7 - msb)));
    3198:	4f ef       	ldi	r20, 0xFF	; 255
    319a:	50 e0       	ldi	r21, 0x00	; 0
    319c:	9a 01       	movw	r18, r20
    319e:	02 c0       	rjmp	.+4      	; 0x31a4 <_ZN6Module14SPIgetRegValueEjhh+0x24>
    31a0:	22 0f       	add	r18, r18
    31a2:	33 1f       	adc	r19, r19
    31a4:	da 95       	dec	r29
    31a6:	e2 f7       	brpl	.-8      	; 0x31a0 <_ZN6Module14SPIgetRegValueEjhh+0x20>
    31a8:	67 e0       	ldi	r22, 0x07	; 7
    31aa:	70 e0       	ldi	r23, 0x00	; 0
    31ac:	6c 1b       	sub	r22, r28
    31ae:	71 09       	sbc	r23, r1
    31b0:	02 c0       	rjmp	.+4      	; 0x31b6 <_ZN6Module14SPIgetRegValueEjhh+0x36>
    31b2:	55 95       	asr	r21
    31b4:	47 95       	ror	r20
    31b6:	6a 95       	dec	r22
    31b8:	e2 f7       	brpl	.-8      	; 0x31b2 <_ZN6Module14SPIgetRegValueEjhh+0x32>
    31ba:	24 23       	and	r18, r20
    31bc:	82 23       	and	r24, r18
  return(maskedValue);
    31be:	90 e0       	ldi	r25, 0x00	; 0
}
    31c0:	df 91       	pop	r29
    31c2:	cf 91       	pop	r28
    31c4:	08 95       	ret
  this->hal->term();
}

int16_t Module::SPIgetRegValue(uint16_t reg, uint8_t msb, uint8_t lsb) {
  if((msb > 7) || (lsb > 7) || (lsb > msb)) {
    return(RADIOLIB_ERR_INVALID_BIT_RANGE);
    31c6:	85 ef       	ldi	r24, 0xF5	; 245
    31c8:	9f ef       	ldi	r25, 0xFF	; 255
    31ca:	fa cf       	rjmp	.-12     	; 0x31c0 <_ZN6Module14SPIgetRegValueEjhh+0x40>
    31cc:	85 ef       	ldi	r24, 0xF5	; 245
    31ce:	9f ef       	ldi	r25, 0xFF	; 255
    31d0:	f7 cf       	rjmp	.-18     	; 0x31c0 <_ZN6Module14SPIgetRegValueEjhh+0x40>
    31d2:	85 ef       	ldi	r24, 0xF5	; 245
    31d4:	9f ef       	ldi	r25, 0xFF	; 255
    31d6:	f4 cf       	rjmp	.-24     	; 0x31c0 <_ZN6Module14SPIgetRegValueEjhh+0x40>

000031d8 <_ZN6SX127x14getActiveModemEv>:
  }
  return(this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_OP_MODE, mode, 2, 0, 5, checkMask));
}

int16_t SX127x::getActiveModem() {
  return(this->mod->SPIgetRegValue(RADIOLIB_SX127X_REG_OP_MODE, 7, 7));
    31d8:	87 5e       	subi	r24, 0xE7	; 231
    31da:	9e 4f       	sbci	r25, 0xFE	; 254
    31dc:	27 e0       	ldi	r18, 0x07	; 7
    31de:	47 e0       	ldi	r20, 0x07	; 7
    31e0:	61 e0       	ldi	r22, 0x01	; 1
    31e2:	70 e0       	ldi	r23, 0x00	; 0
    31e4:	fc 01       	movw	r30, r24
    31e6:	80 81       	ld	r24, Z
    31e8:	91 81       	ldd	r25, Z+1	; 0x01
    31ea:	0e 94 c0 18 	call	0x3180	; 0x3180 <_ZN6Module14SPIgetRegValueEjhh>
}
    31ee:	08 95       	ret

000031f0 <_ZN6SX127x8invertIQEb>:
    this->mod->SPIreadRegister(RADIOLIB_SX127X_REG_FIFO);
    count--;
  }
}

int16_t SX127x::invertIQ(bool enable) {
    31f0:	af 92       	push	r10
    31f2:	bf 92       	push	r11
    31f4:	cf 92       	push	r12
    31f6:	ef 92       	push	r14
    31f8:	0f 93       	push	r16
    31fa:	cf 93       	push	r28
    31fc:	df 93       	push	r29
    31fe:	ec 01       	movw	r28, r24
    3200:	b6 2e       	mov	r11, r22
  // check active modem
  if(getActiveModem() != RADIOLIB_SX127X_LORA) {
    3202:	0e 94 ec 18 	call	0x31d8	; 0x31d8 <_ZN6SX127x14getActiveModemEv>
    3206:	80 38       	cpi	r24, 0x80	; 128
    3208:	91 05       	cpc	r25, r1
    320a:	09 f0       	breq	.+2      	; 0x320e <_ZN6SX127x8invertIQEb+0x1e>
    320c:	57 c0       	rjmp	.+174    	; 0x32bc <_ZN6SX127x8invertIQEb+0xcc>
  }

  // Tx path inversion is swapped, because it seems that setting it according to the datsheet
  // will actually lead to the wrong inversion. See https://github.com/jgromes/RadioLib/issues/778
  int16_t state;
  if(enable) {
    320e:	b1 10       	cpse	r11, r1
    3210:	2e c0       	rjmp	.+92     	; 0x326e <_ZN6SX127x8invertIQEb+0x7e>
    state = this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_INVERT_IQ, RADIOLIB_SX127X_INVERT_IQ_RXPATH_ON, 6, 6);
    state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_INVERT_IQ, RADIOLIB_SX127X_INVERT_IQ_TXPATH_OFF, 0, 0);
    state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_INVERT_IQ2, RADIOLIB_SX127X_IQ2_ENABLE);
  } else {
    state = this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_INVERT_IQ, RADIOLIB_SX127X_INVERT_IQ_RXPATH_OFF, 6, 6);
    3212:	c7 5e       	subi	r28, 0xE7	; 231
    3214:	de 4f       	sbci	r29, 0xFE	; 254
    3216:	cc 24       	eor	r12, r12
    3218:	ca 94       	dec	r12
    321a:	68 94       	set
    321c:	ee 24       	eor	r14, r14
    321e:	e1 f8       	bld	r14, 1
    3220:	06 e0       	ldi	r16, 0x06	; 6
    3222:	26 e0       	ldi	r18, 0x06	; 6
    3224:	40 e0       	ldi	r20, 0x00	; 0
    3226:	63 e3       	ldi	r22, 0x33	; 51
    3228:	70 e0       	ldi	r23, 0x00	; 0
    322a:	88 81       	ld	r24, Y
    322c:	99 81       	ldd	r25, Y+1	; 0x01
    322e:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    3232:	5c 01       	movw	r10, r24
    state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_INVERT_IQ, RADIOLIB_SX127X_INVERT_IQ_TXPATH_ON, 0, 0);
    3234:	00 e0       	ldi	r16, 0x00	; 0
    3236:	20 e0       	ldi	r18, 0x00	; 0
    3238:	41 e0       	ldi	r20, 0x01	; 1
    323a:	63 e3       	ldi	r22, 0x33	; 51
    323c:	70 e0       	ldi	r23, 0x00	; 0
    323e:	88 81       	ld	r24, Y
    3240:	99 81       	ldd	r25, Y+1	; 0x01
    3242:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    3246:	a8 2a       	or	r10, r24
    3248:	b9 2a       	or	r11, r25
    state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_INVERT_IQ2, RADIOLIB_SX127X_IQ2_DISABLE);
    324a:	27 e0       	ldi	r18, 0x07	; 7
    324c:	4d e1       	ldi	r20, 0x1D	; 29
    324e:	6b e3       	ldi	r22, 0x3B	; 59
    3250:	70 e0       	ldi	r23, 0x00	; 0
    3252:	88 81       	ld	r24, Y
    3254:	99 81       	ldd	r25, Y+1	; 0x01
    3256:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    325a:	8a 29       	or	r24, r10
    325c:	9b 29       	or	r25, r11
  }

  return(state);
}
    325e:	df 91       	pop	r29
    3260:	cf 91       	pop	r28
    3262:	0f 91       	pop	r16
    3264:	ef 90       	pop	r14
    3266:	cf 90       	pop	r12
    3268:	bf 90       	pop	r11
    326a:	af 90       	pop	r10
    326c:	08 95       	ret

  // Tx path inversion is swapped, because it seems that setting it according to the datsheet
  // will actually lead to the wrong inversion. See https://github.com/jgromes/RadioLib/issues/778
  int16_t state;
  if(enable) {
    state = this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_INVERT_IQ, RADIOLIB_SX127X_INVERT_IQ_RXPATH_ON, 6, 6);
    326e:	c7 5e       	subi	r28, 0xE7	; 231
    3270:	de 4f       	sbci	r29, 0xFE	; 254
    3272:	cc 24       	eor	r12, r12
    3274:	ca 94       	dec	r12
    3276:	68 94       	set
    3278:	ee 24       	eor	r14, r14
    327a:	e1 f8       	bld	r14, 1
    327c:	06 e0       	ldi	r16, 0x06	; 6
    327e:	26 e0       	ldi	r18, 0x06	; 6
    3280:	40 e4       	ldi	r20, 0x40	; 64
    3282:	63 e3       	ldi	r22, 0x33	; 51
    3284:	70 e0       	ldi	r23, 0x00	; 0
    3286:	88 81       	ld	r24, Y
    3288:	99 81       	ldd	r25, Y+1	; 0x01
    328a:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    328e:	5c 01       	movw	r10, r24
    state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_INVERT_IQ, RADIOLIB_SX127X_INVERT_IQ_TXPATH_OFF, 0, 0);
    3290:	00 e0       	ldi	r16, 0x00	; 0
    3292:	20 e0       	ldi	r18, 0x00	; 0
    3294:	40 e0       	ldi	r20, 0x00	; 0
    3296:	63 e3       	ldi	r22, 0x33	; 51
    3298:	70 e0       	ldi	r23, 0x00	; 0
    329a:	88 81       	ld	r24, Y
    329c:	99 81       	ldd	r25, Y+1	; 0x01
    329e:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    32a2:	a8 2a       	or	r10, r24
    32a4:	b9 2a       	or	r11, r25
    state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_INVERT_IQ2, RADIOLIB_SX127X_IQ2_ENABLE);
    32a6:	27 e0       	ldi	r18, 0x07	; 7
    32a8:	49 e1       	ldi	r20, 0x19	; 25
    32aa:	6b e3       	ldi	r22, 0x3B	; 59
    32ac:	70 e0       	ldi	r23, 0x00	; 0
    32ae:	88 81       	ld	r24, Y
    32b0:	99 81       	ldd	r25, Y+1	; 0x01
    32b2:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    32b6:	8a 29       	or	r24, r10
    32b8:	9b 29       	or	r25, r11
    32ba:	d1 cf       	rjmp	.-94     	; 0x325e <_ZN6SX127x8invertIQEb+0x6e>
}

int16_t SX127x::invertIQ(bool enable) {
  // check active modem
  if(getActiveModem() != RADIOLIB_SX127X_LORA) {
    return(RADIOLIB_ERR_WRONG_MODEM);
    32bc:	8c ee       	ldi	r24, 0xEC	; 236
    32be:	9f ef       	ldi	r25, 0xFF	; 255
    32c0:	ce cf       	rjmp	.-100    	; 0x325e <_ZN6SX127x8invertIQEb+0x6e>

000032c2 <_ZN6SX127x13clearIRQFlagsEv>:
  // set mode to STANDBY
  state |= setMode(RADIOLIB_SX127X_STANDBY);
  return(state);
}

void SX127x::clearIRQFlags() {
    32c2:	cf 93       	push	r28
    32c4:	df 93       	push	r29
    32c6:	ec 01       	movw	r28, r24
  int16_t modem = getActiveModem();
    32c8:	0e 94 ec 18 	call	0x31d8	; 0x31d8 <_ZN6SX127x14getActiveModemEv>
  if(modem == RADIOLIB_SX127X_LORA) {
    32cc:	80 38       	cpi	r24, 0x80	; 128
    32ce:	91 05       	cpc	r25, r1
    32d0:	29 f0       	breq	.+10     	; 0x32dc <_ZN6SX127x13clearIRQFlagsEv+0x1a>
    this->mod->SPIwriteRegister(RADIOLIB_SX127X_REG_IRQ_FLAGS, 0b11111111);
  } else if(modem == RADIOLIB_SX127X_FSK_OOK) {
    32d2:	89 2b       	or	r24, r25
    32d4:	69 f0       	breq	.+26     	; 0x32f0 <_ZN6SX127x13clearIRQFlagsEv+0x2e>
    this->mod->SPIwriteRegister(RADIOLIB_SX127X_REG_IRQ_FLAGS_1, 0b11111111);
    this->mod->SPIwriteRegister(RADIOLIB_SX127X_REG_IRQ_FLAGS_2, 0b11111111);
  }
}
    32d6:	df 91       	pop	r29
    32d8:	cf 91       	pop	r28
    32da:	08 95       	ret
}

void SX127x::clearIRQFlags() {
  int16_t modem = getActiveModem();
  if(modem == RADIOLIB_SX127X_LORA) {
    this->mod->SPIwriteRegister(RADIOLIB_SX127X_REG_IRQ_FLAGS, 0b11111111);
    32dc:	c7 5e       	subi	r28, 0xE7	; 231
    32de:	de 4f       	sbci	r29, 0xFE	; 254
    32e0:	4f ef       	ldi	r20, 0xFF	; 255
    32e2:	62 e1       	ldi	r22, 0x12	; 18
    32e4:	70 e0       	ldi	r23, 0x00	; 0
    32e6:	88 81       	ld	r24, Y
    32e8:	99 81       	ldd	r25, Y+1	; 0x01
    32ea:	0e 94 ee 16 	call	0x2ddc	; 0x2ddc <_ZN6Module16SPIwriteRegisterEjh>
    32ee:	f3 cf       	rjmp	.-26     	; 0x32d6 <_ZN6SX127x13clearIRQFlagsEv+0x14>
  } else if(modem == RADIOLIB_SX127X_FSK_OOK) {
    this->mod->SPIwriteRegister(RADIOLIB_SX127X_REG_IRQ_FLAGS_1, 0b11111111);
    32f0:	c7 5e       	subi	r28, 0xE7	; 231
    32f2:	de 4f       	sbci	r29, 0xFE	; 254
    32f4:	4f ef       	ldi	r20, 0xFF	; 255
    32f6:	6e e3       	ldi	r22, 0x3E	; 62
    32f8:	70 e0       	ldi	r23, 0x00	; 0
    32fa:	88 81       	ld	r24, Y
    32fc:	99 81       	ldd	r25, Y+1	; 0x01
    32fe:	0e 94 ee 16 	call	0x2ddc	; 0x2ddc <_ZN6Module16SPIwriteRegisterEjh>
    this->mod->SPIwriteRegister(RADIOLIB_SX127X_REG_IRQ_FLAGS_2, 0b11111111);
    3302:	4f ef       	ldi	r20, 0xFF	; 255
    3304:	6f e3       	ldi	r22, 0x3F	; 63
    3306:	70 e0       	ldi	r23, 0x00	; 0
    3308:	88 81       	ld	r24, Y
    330a:	99 81       	ldd	r25, Y+1	; 0x01
    330c:	0e 94 ee 16 	call	0x2ddc	; 0x2ddc <_ZN6Module16SPIwriteRegisterEjh>
    3310:	e2 cf       	rjmp	.-60     	; 0x32d6 <_ZN6SX127x13clearIRQFlagsEv+0x14>

00003312 <_ZN6SX127x14finishTransmitEv>:
  RADIOLIB_ASSERT(state);

  return(RADIOLIB_ERR_NONE);
}

int16_t SX127x::finishTransmit() {
    3312:	cf 93       	push	r28
    3314:	df 93       	push	r29
    3316:	ec 01       	movw	r28, r24
  // wait for at least 1 bit at the lowest possible bit rate before clearing IRQ flags
  // not doing this and clearing RADIOLIB_SX127X_FLAG_FIFO_OVERRUN will dump the FIFO,
  // which can lead to mangling of the last bit (#808)
  mod->hal->delayMicroseconds(1000000/1200);
    3318:	fc 01       	movw	r30, r24
    331a:	e7 5e       	subi	r30, 0xE7	; 231
    331c:	fe 4f       	sbci	r31, 0xFE	; 254
    331e:	01 90       	ld	r0, Z+
    3320:	f0 81       	ld	r31, Z
    3322:	e0 2d       	mov	r30, r0
    3324:	80 81       	ld	r24, Z
    3326:	91 81       	ldd	r25, Z+1	; 0x01
    3328:	dc 01       	movw	r26, r24
    332a:	ed 91       	ld	r30, X+
    332c:	fc 91       	ld	r31, X
    332e:	04 84       	ldd	r0, Z+12	; 0x0c
    3330:	f5 85       	ldd	r31, Z+13	; 0x0d
    3332:	e0 2d       	mov	r30, r0
    3334:	41 e4       	ldi	r20, 0x41	; 65
    3336:	53 e0       	ldi	r21, 0x03	; 3
    3338:	60 e0       	ldi	r22, 0x00	; 0
    333a:	70 e0       	ldi	r23, 0x00	; 0
    333c:	09 95       	icall

  // clear interrupt flags
  clearIRQFlags();
    333e:	ce 01       	movw	r24, r28
    3340:	0e 94 61 19 	call	0x32c2	; 0x32c2 <_ZN6SX127x13clearIRQFlagsEv>

  // set mode to standby to disable transmitter/RF switch
  return(standby());
    3344:	e8 81       	ld	r30, Y
    3346:	f9 81       	ldd	r31, Y+1	; 0x01
    3348:	04 80       	ldd	r0, Z+4	; 0x04
    334a:	f5 81       	ldd	r31, Z+5	; 0x05
    334c:	e0 2d       	mov	r30, r0
    334e:	ce 01       	movw	r24, r28
    3350:	09 95       	icall
}
    3352:	df 91       	pop	r29
    3354:	cf 91       	pop	r28
    3356:	08 95       	ret

00003358 <_ZN6SX127x7setModeEh>:
  }

  return(flagFound);
}

int16_t SX127x::setMode(uint8_t mode) {
    3358:	cf 92       	push	r12
    335a:	ef 92       	push	r14
    335c:	0f 93       	push	r16
    335e:	1f 93       	push	r17
    3360:	cf 93       	push	r28
    3362:	df 93       	push	r29
    3364:	ec 01       	movw	r28, r24
    3366:	16 2f       	mov	r17, r22
  uint8_t checkMask = 0xFF;
  if((getActiveModem() == RADIOLIB_SX127X_FSK_OOK) && (mode == RADIOLIB_SX127X_RX)) {
    3368:	0e 94 ec 18 	call	0x31d8	; 0x31d8 <_ZN6SX127x14getActiveModemEv>
    336c:	89 2b       	or	r24, r25
    336e:	29 f4       	brne	.+10     	; 0x337a <_ZN6SX127x7setModeEh+0x22>
    3370:	15 30       	cpi	r17, 0x05	; 5
    3372:	d9 f0       	breq	.+54     	; 0x33aa <_ZN6SX127x7setModeEh+0x52>

  return(flagFound);
}

int16_t SX127x::setMode(uint8_t mode) {
  uint8_t checkMask = 0xFF;
    3374:	cc 24       	eor	r12, r12
    3376:	ca 94       	dec	r12
    3378:	02 c0       	rjmp	.+4      	; 0x337e <_ZN6SX127x7setModeEh+0x26>
    337a:	cc 24       	eor	r12, r12
    337c:	ca 94       	dec	r12
  if((getActiveModem() == RADIOLIB_SX127X_FSK_OOK) && (mode == RADIOLIB_SX127X_RX)) {
    // disable checking of RX bit in FSK RX mode, as it sometimes seem to fail (#276)
    checkMask = 0xFE;
  }
  return(this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_OP_MODE, mode, 2, 0, 5, checkMask));
    337e:	c7 5e       	subi	r28, 0xE7	; 231
    3380:	de 4f       	sbci	r29, 0xFE	; 254
    3382:	0f 2e       	mov	r0, r31
    3384:	f5 e0       	ldi	r31, 0x05	; 5
    3386:	ef 2e       	mov	r14, r31
    3388:	f0 2d       	mov	r31, r0
    338a:	00 e0       	ldi	r16, 0x00	; 0
    338c:	22 e0       	ldi	r18, 0x02	; 2
    338e:	41 2f       	mov	r20, r17
    3390:	61 e0       	ldi	r22, 0x01	; 1
    3392:	70 e0       	ldi	r23, 0x00	; 0
    3394:	88 81       	ld	r24, Y
    3396:	99 81       	ldd	r25, Y+1	; 0x01
    3398:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
}
    339c:	df 91       	pop	r29
    339e:	cf 91       	pop	r28
    33a0:	1f 91       	pop	r17
    33a2:	0f 91       	pop	r16
    33a4:	ef 90       	pop	r14
    33a6:	cf 90       	pop	r12
    33a8:	08 95       	ret

int16_t SX127x::setMode(uint8_t mode) {
  uint8_t checkMask = 0xFF;
  if((getActiveModem() == RADIOLIB_SX127X_FSK_OOK) && (mode == RADIOLIB_SX127X_RX)) {
    // disable checking of RX bit in FSK RX mode, as it sometimes seem to fail (#276)
    checkMask = 0xFE;
    33aa:	0f 2e       	mov	r0, r31
    33ac:	fe ef       	ldi	r31, 0xFE	; 254
    33ae:	cf 2e       	mov	r12, r31
    33b0:	f0 2d       	mov	r31, r0
    33b2:	e5 cf       	rjmp	.-54     	; 0x337e <_ZN6SX127x7setModeEh+0x26>

000033b4 <_ZN6SX127x14setActiveModemEh>:

int16_t SX127x::getActiveModem() {
  return(this->mod->SPIgetRegValue(RADIOLIB_SX127X_REG_OP_MODE, 7, 7));
}

int16_t SX127x::setActiveModem(uint8_t modem) {
    33b4:	af 92       	push	r10
    33b6:	bf 92       	push	r11
    33b8:	cf 92       	push	r12
    33ba:	ef 92       	push	r14
    33bc:	0f 93       	push	r16
    33be:	1f 93       	push	r17
    33c0:	cf 93       	push	r28
    33c2:	df 93       	push	r29
    33c4:	5c 01       	movw	r10, r24
    33c6:	16 2f       	mov	r17, r22
  // set mode to SLEEP
  int16_t state = setMode(RADIOLIB_SX127X_SLEEP);
    33c8:	60 e0       	ldi	r22, 0x00	; 0
    33ca:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN6SX127x7setModeEh>
    33ce:	ec 01       	movw	r28, r24

  // set modem
  state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_OP_MODE, modem, 7, 7, 5);
    33d0:	f5 01       	movw	r30, r10
    33d2:	e7 5e       	subi	r30, 0xE7	; 231
    33d4:	fe 4f       	sbci	r31, 0xFE	; 254
    33d6:	cc 24       	eor	r12, r12
    33d8:	ca 94       	dec	r12
    33da:	0f 2e       	mov	r0, r31
    33dc:	f5 e0       	ldi	r31, 0x05	; 5
    33de:	ef 2e       	mov	r14, r31
    33e0:	f0 2d       	mov	r31, r0
    33e2:	07 e0       	ldi	r16, 0x07	; 7
    33e4:	27 e0       	ldi	r18, 0x07	; 7
    33e6:	41 2f       	mov	r20, r17
    33e8:	61 e0       	ldi	r22, 0x01	; 1
    33ea:	70 e0       	ldi	r23, 0x00	; 0
    33ec:	80 81       	ld	r24, Z
    33ee:	91 81       	ldd	r25, Z+1	; 0x01
    33f0:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    33f4:	c8 2b       	or	r28, r24
    33f6:	d9 2b       	or	r29, r25

  // set mode to STANDBY
  state |= setMode(RADIOLIB_SX127X_STANDBY);
    33f8:	61 e0       	ldi	r22, 0x01	; 1
    33fa:	c5 01       	movw	r24, r10
    33fc:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN6SX127x7setModeEh>
  return(state);
}
    3400:	8c 2b       	or	r24, r28
    3402:	9d 2b       	or	r25, r29
    3404:	df 91       	pop	r29
    3406:	cf 91       	pop	r28
    3408:	1f 91       	pop	r17
    340a:	0f 91       	pop	r16
    340c:	ef 90       	pop	r14
    340e:	cf 90       	pop	r12
    3410:	bf 90       	pop	r11
    3412:	af 90       	pop	r10
    3414:	08 95       	ret

00003416 <_ZN6SX127x15setCurrentLimitEh>:

  // write register
  return(this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_SYNC_WORD, syncWord));
}

int16_t SX127x::setCurrentLimit(uint8_t currentLimit) {
    3416:	af 92       	push	r10
    3418:	bf 92       	push	r11
    341a:	cf 92       	push	r12
    341c:	ef 92       	push	r14
    341e:	0f 93       	push	r16
    3420:	1f 93       	push	r17
    3422:	cf 93       	push	r28
    3424:	8c 01       	movw	r16, r24
  // check allowed range
  if(!(((currentLimit >= 45) && (currentLimit <= 240)) || (currentLimit == 0))) {
    3426:	93 ed       	ldi	r25, 0xD3	; 211
    3428:	96 0f       	add	r25, r22
    342a:	94 3c       	cpi	r25, 0xC4	; 196
    342c:	10 f0       	brcs	.+4      	; 0x3432 <_ZN6SX127x15setCurrentLimitEh+0x1c>
    342e:	61 11       	cpse	r22, r1
    3430:	62 c0       	rjmp	.+196    	; 0x34f6 <_ZN6SX127x15setCurrentLimitEh+0xe0>
    3432:	c6 2f       	mov	r28, r22
    return(RADIOLIB_ERR_INVALID_CURRENT_LIMIT);
  }

  // set mode to standby
  int16_t state = setMode(RADIOLIB_SX127X_STANDBY);
    3434:	61 e0       	ldi	r22, 0x01	; 1
    3436:	c8 01       	movw	r24, r16
    3438:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN6SX127x7setModeEh>
    343c:	5c 01       	movw	r10, r24

  // set OCP limit
  uint8_t raw;
  if(currentLimit == 0) {
    343e:	cc 23       	and	r28, r28
    3440:	69 f0       	breq	.+26     	; 0x345c <_ZN6SX127x15setCurrentLimitEh+0x46>
    // limit set to 0, disable OCP
    state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_OCP, RADIOLIB_SX127X_OCP_OFF, 5, 5);
  } else if(currentLimit <= 120) {
    3442:	c9 37       	cpi	r28, 0x79	; 121
    3444:	f8 f0       	brcs	.+62     	; 0x3484 <_ZN6SX127x15setCurrentLimitEh+0x6e>
    raw = (currentLimit - 45) / 5;
    state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_OCP, RADIOLIB_SX127X_OCP_ON | raw, 5, 0);
  } else if(currentLimit <= 240) {
    3446:	c1 3f       	cpi	r28, 0xF1	; 241
    3448:	d0 f1       	brcs	.+116    	; 0x34be <_ZN6SX127x15setCurrentLimitEh+0xa8>
    raw = (currentLimit + 30) / 10;
    state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_OCP, RADIOLIB_SX127X_OCP_ON | raw, 5, 0);
  }
  return(state);
}
    344a:	c5 01       	movw	r24, r10
    344c:	cf 91       	pop	r28
    344e:	1f 91       	pop	r17
    3450:	0f 91       	pop	r16
    3452:	ef 90       	pop	r14
    3454:	cf 90       	pop	r12
    3456:	bf 90       	pop	r11
    3458:	af 90       	pop	r10
    345a:	08 95       	ret

  // set OCP limit
  uint8_t raw;
  if(currentLimit == 0) {
    // limit set to 0, disable OCP
    state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_OCP, RADIOLIB_SX127X_OCP_OFF, 5, 5);
    345c:	f8 01       	movw	r30, r16
    345e:	e7 5e       	subi	r30, 0xE7	; 231
    3460:	fe 4f       	sbci	r31, 0xFE	; 254
    3462:	cc 24       	eor	r12, r12
    3464:	ca 94       	dec	r12
    3466:	68 94       	set
    3468:	ee 24       	eor	r14, r14
    346a:	e1 f8       	bld	r14, 1
    346c:	05 e0       	ldi	r16, 0x05	; 5
    346e:	25 e0       	ldi	r18, 0x05	; 5
    3470:	40 e0       	ldi	r20, 0x00	; 0
    3472:	6b e0       	ldi	r22, 0x0B	; 11
    3474:	70 e0       	ldi	r23, 0x00	; 0
    3476:	80 81       	ld	r24, Z
    3478:	91 81       	ldd	r25, Z+1	; 0x01
    347a:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    347e:	a8 2a       	or	r10, r24
    3480:	b9 2a       	or	r11, r25
    3482:	e3 cf       	rjmp	.-58     	; 0x344a <_ZN6SX127x15setCurrentLimitEh+0x34>
  } else if(currentLimit <= 120) {
    raw = (currentLimit - 45) / 5;
    3484:	2c 2f       	mov	r18, r28
    3486:	2d 52       	subi	r18, 0x2D	; 45
    3488:	33 0b       	sbc	r19, r19
    348a:	c9 01       	movw	r24, r18
    348c:	65 e0       	ldi	r22, 0x05	; 5
    348e:	70 e0       	ldi	r23, 0x00	; 0
    3490:	0e 94 fc 3a 	call	0x75f8	; 0x75f8 <__divmodhi4>
    state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_OCP, RADIOLIB_SX127X_OCP_ON | raw, 5, 0);
    3494:	f8 01       	movw	r30, r16
    3496:	e7 5e       	subi	r30, 0xE7	; 231
    3498:	fe 4f       	sbci	r31, 0xFE	; 254
    349a:	46 2f       	mov	r20, r22
    349c:	40 62       	ori	r20, 0x20	; 32
    349e:	cc 24       	eor	r12, r12
    34a0:	ca 94       	dec	r12
    34a2:	68 94       	set
    34a4:	ee 24       	eor	r14, r14
    34a6:	e1 f8       	bld	r14, 1
    34a8:	00 e0       	ldi	r16, 0x00	; 0
    34aa:	25 e0       	ldi	r18, 0x05	; 5
    34ac:	6b e0       	ldi	r22, 0x0B	; 11
    34ae:	70 e0       	ldi	r23, 0x00	; 0
    34b0:	80 81       	ld	r24, Z
    34b2:	91 81       	ldd	r25, Z+1	; 0x01
    34b4:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    34b8:	a8 2a       	or	r10, r24
    34ba:	b9 2a       	or	r11, r25
    34bc:	c6 cf       	rjmp	.-116    	; 0x344a <_ZN6SX127x15setCurrentLimitEh+0x34>
  } else if(currentLimit <= 240) {
    raw = (currentLimit + 30) / 10;
    34be:	8c 2f       	mov	r24, r28
    34c0:	90 e0       	ldi	r25, 0x00	; 0
    34c2:	4e 96       	adiw	r24, 0x1e	; 30
    34c4:	6a e0       	ldi	r22, 0x0A	; 10
    34c6:	70 e0       	ldi	r23, 0x00	; 0
    34c8:	0e 94 fc 3a 	call	0x75f8	; 0x75f8 <__divmodhi4>
    state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_OCP, RADIOLIB_SX127X_OCP_ON | raw, 5, 0);
    34cc:	f8 01       	movw	r30, r16
    34ce:	e7 5e       	subi	r30, 0xE7	; 231
    34d0:	fe 4f       	sbci	r31, 0xFE	; 254
    34d2:	46 2f       	mov	r20, r22
    34d4:	40 62       	ori	r20, 0x20	; 32
    34d6:	cc 24       	eor	r12, r12
    34d8:	ca 94       	dec	r12
    34da:	68 94       	set
    34dc:	ee 24       	eor	r14, r14
    34de:	e1 f8       	bld	r14, 1
    34e0:	00 e0       	ldi	r16, 0x00	; 0
    34e2:	25 e0       	ldi	r18, 0x05	; 5
    34e4:	6b e0       	ldi	r22, 0x0B	; 11
    34e6:	70 e0       	ldi	r23, 0x00	; 0
    34e8:	80 81       	ld	r24, Z
    34ea:	91 81       	ldd	r25, Z+1	; 0x01
    34ec:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    34f0:	a8 2a       	or	r10, r24
    34f2:	b9 2a       	or	r11, r25
    34f4:	aa cf       	rjmp	.-172    	; 0x344a <_ZN6SX127x15setCurrentLimitEh+0x34>
}

int16_t SX127x::setCurrentLimit(uint8_t currentLimit) {
  // check allowed range
  if(!(((currentLimit >= 45) && (currentLimit <= 240)) || (currentLimit == 0))) {
    return(RADIOLIB_ERR_INVALID_CURRENT_LIMIT);
    34f6:	0f 2e       	mov	r0, r31
    34f8:	ff ee       	ldi	r31, 0xEF	; 239
    34fa:	af 2e       	mov	r10, r31
    34fc:	bb 24       	eor	r11, r11
    34fe:	ba 94       	dec	r11
    3500:	f0 2d       	mov	r31, r0
    3502:	a3 cf       	rjmp	.-186    	; 0x344a <_ZN6SX127x15setCurrentLimitEh+0x34>

00003504 <_ZN6SX127x7standbyEv>:

  // set mode to sleep
  return(setMode(RADIOLIB_SX127X_SLEEP));
}

int16_t SX127x::standby() {
    3504:	cf 93       	push	r28
    3506:	df 93       	push	r29
    3508:	ec 01       	movw	r28, r24
  // set RF switch (if present)
  this->mod->setRfSwitchState(Module::MODE_IDLE);
    350a:	fc 01       	movw	r30, r24
    350c:	e7 5e       	subi	r30, 0xE7	; 231
    350e:	fe 4f       	sbci	r31, 0xFE	; 254
    3510:	61 e0       	ldi	r22, 0x01	; 1
    3512:	80 81       	ld	r24, Z
    3514:	91 81       	ldd	r25, Z+1	; 0x01
    3516:	0e 94 c3 09 	call	0x1386	; 0x1386 <_ZN6Module16setRfSwitchStateEh>

  // set mode to standby
  return(setMode(RADIOLIB_SX127X_STANDBY));
    351a:	61 e0       	ldi	r22, 0x01	; 1
    351c:	ce 01       	movw	r24, r28
    351e:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN6SX127x7setModeEh>
}
    3522:	df 91       	pop	r29
    3524:	cf 91       	pop	r28
    3526:	08 95       	ret

00003528 <_ZN3gel5Radio7standbyEv>:
    setState(Idle);
    return Error::None;        
}

Error Radio::standby()
{
    3528:	0f 93       	push	r16
    352a:	1f 93       	push	r17
    352c:	cf 93       	push	r28
    352e:	df 93       	push	r29
    3530:	ec 01       	movw	r28, r24
    3532:	8b 01       	movw	r16, r22
    int err = radio.standby();
    3534:	cb 01       	movw	r24, r22
    3536:	c4 96       	adiw	r24, 0x34	; 52
    3538:	0e 94 82 1a 	call	0x3504	; 0x3504 <_ZN6SX127x7standbyEv>

    if (err != RADIOLIB_ERR_NONE)
    353c:	89 2b       	or	r24, r25
    353e:	81 f0       	breq	.+32     	; 0x3560 <_ZN3gel5Radio7standbyEv+0x38>
    3540:	8c e8       	ldi	r24, 0x8C	; 140
    3542:	92 e0       	ldi	r25, 0x02	; 2
    3544:	99 83       	std	Y+1, r25	; 0x01
    3546:	88 83       	st	Y, r24
    3548:	87 e0       	ldi	r24, 0x07	; 7
    354a:	90 e0       	ldi	r25, 0x00	; 0
    354c:	9b 83       	std	Y+3, r25	; 0x03
    354e:	8a 83       	std	Y+2, r24	; 0x02
    3550:	1d 82       	std	Y+5, r1	; 0x05
    3552:	1c 82       	std	Y+4, r1	; 0x04
        return Error::Internal;

    setState(Idle);
    return Error::None;        
}
    3554:	ce 01       	movw	r24, r28
    3556:	df 91       	pop	r29
    3558:	cf 91       	pop	r28
    355a:	1f 91       	pop	r17
    355c:	0f 91       	pop	r16
    355e:	08 95       	ret
    int err = radio.standby();

    if (err != RADIOLIB_ERR_NONE)
        return Error::Internal;

    setState(Idle);
    3560:	70 e0       	ldi	r23, 0x00	; 0
    3562:	60 e0       	ldi	r22, 0x00	; 0
    3564:	c8 01       	movw	r24, r16
    3566:	0e 94 f5 06 	call	0xdea	; 0xdea <_ZN3gel5Radio8setStateENS0_5StateE>
    356a:	8c e8       	ldi	r24, 0x8C	; 140
    356c:	92 e0       	ldi	r25, 0x02	; 2
    356e:	99 83       	std	Y+1, r25	; 0x01
    3570:	88 83       	st	Y, r24
    3572:	1b 82       	std	Y+3, r1	; 0x03
    3574:	1a 82       	std	Y+2, r1	; 0x02
    3576:	1d 82       	std	Y+5, r1	; 0x05
    3578:	1c 82       	std	Y+4, r1	; 0x04
    357a:	ec cf       	rjmp	.-40     	; 0x3554 <_ZN3gel5Radio7standbyEv+0x2c>

0000357c <_ZN3gel5Radio8callbackEv>:
    prevState = currentState;
    currentState = newState;
}

void Radio::callback()
{
    357c:	0f 93       	push	r16
    357e:	1f 93       	push	r17
    3580:	cf 93       	push	r28
    3582:	df 93       	push	r29
    3584:	00 d0       	rcall	.+0      	; 0x3586 <_ZN3gel5Radio8callbackEv+0xa>
    3586:	00 d0       	rcall	.+0      	; 0x3588 <_ZN3gel5Radio8callbackEv+0xc>
    3588:	00 d0       	rcall	.+0      	; 0x358a <_ZN3gel5Radio8callbackEv+0xe>
    358a:	cd b7       	in	r28, 0x3d	; 61
    358c:	de b7       	in	r29, 0x3e	; 62
    358e:	8c 01       	movw	r16, r24
    if (currentState == Receiving)
    3590:	fc 01       	movw	r30, r24
    3592:	e4 59       	subi	r30, 0x94	; 148
    3594:	fe 4f       	sbci	r31, 0xFE	; 254
    3596:	80 81       	ld	r24, Z
    3598:	91 81       	ldd	r25, Z+1	; 0x01
    359a:	02 97       	sbiw	r24, 0x02	; 2
    359c:	a9 f4       	brne	.+42     	; 0x35c8 <_ZN3gel5Radio8callbackEv+0x4c>
        dataReceived = true;
    359e:	81 e0       	ldi	r24, 0x01	; 1
    35a0:	31 97       	sbiw	r30, 0x01	; 1
    35a2:	80 83       	st	Z, r24
    else
        setState(Idle);
    
    if (currentState == Scanning)
    35a4:	f8 01       	movw	r30, r16
    35a6:	e4 59       	subi	r30, 0x94	; 148
    35a8:	fe 4f       	sbci	r31, 0xFE	; 254
    35aa:	80 81       	ld	r24, Z
    35ac:	91 81       	ldd	r25, Z+1	; 0x01
    35ae:	03 97       	sbiw	r24, 0x03	; 3
    35b0:	89 f0       	breq	.+34     	; 0x35d4 <_ZN3gel5Radio8callbackEv+0x58>
        standby();
};
    35b2:	26 96       	adiw	r28, 0x06	; 6
    35b4:	0f b6       	in	r0, 0x3f	; 63
    35b6:	f8 94       	cli
    35b8:	de bf       	out	0x3e, r29	; 62
    35ba:	0f be       	out	0x3f, r0	; 63
    35bc:	cd bf       	out	0x3d, r28	; 61
    35be:	df 91       	pop	r29
    35c0:	cf 91       	pop	r28
    35c2:	1f 91       	pop	r17
    35c4:	0f 91       	pop	r16
    35c6:	08 95       	ret
void Radio::callback()
{
    if (currentState == Receiving)
        dataReceived = true;
    else
        setState(Idle);
    35c8:	70 e0       	ldi	r23, 0x00	; 0
    35ca:	60 e0       	ldi	r22, 0x00	; 0
    35cc:	c8 01       	movw	r24, r16
    35ce:	0e 94 f5 06 	call	0xdea	; 0xdea <_ZN3gel5Radio8setStateENS0_5StateE>
    35d2:	e8 cf       	rjmp	.-48     	; 0x35a4 <_ZN3gel5Radio8callbackEv+0x28>
    
    if (currentState == Scanning)
        standby();
    35d4:	b8 01       	movw	r22, r16
    35d6:	ce 01       	movw	r24, r28
    35d8:	01 96       	adiw	r24, 0x01	; 1
    35da:	0e 94 94 1a 	call	0x3528	; 0x3528 <_ZN3gel5Radio7standbyEv>
    35de:	e9 cf       	rjmp	.-46     	; 0x35b2 <_ZN3gel5Radio8callbackEv+0x36>

000035e0 <_ZN3gel5Radio9callback0Ev>:

    // Change settings
    Error setPreambleLength(size_t length);

private:
    static void callback0(void) { Radio::get(0)->callback(); }
    35e0:	80 e0       	ldi	r24, 0x00	; 0
    35e2:	0e 94 ec 06 	call	0xdd8	; 0xdd8 <_ZN3gel5Radio3getEh>
    35e6:	0e 94 be 1a 	call	0x357c	; 0x357c <_ZN3gel5Radio8callbackEv>
    35ea:	08 95       	ret

000035ec <_ZN3gel5Radio9callback1Ev>:
    static void callback1(void) { Radio::get(1)->callback(); }
    35ec:	81 e0       	ldi	r24, 0x01	; 1
    35ee:	0e 94 ec 06 	call	0xdd8	; 0xdd8 <_ZN3gel5Radio3getEh>
    35f2:	0e 94 be 1a 	call	0x357c	; 0x357c <_ZN3gel5Radio8callbackEv>
    35f6:	08 95       	ret

000035f8 <_ZN6SX127816setCodingRateRawEh>:
    state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_DETECTION_THRESHOLD, RADIOLIB_SX127X_DETECTION_THRESHOLD_SF_7_12);
  }
  return(state);
}

int16_t SX1278::setCodingRateRaw(uint8_t newCodingRate) {
    35f8:	af 92       	push	r10
    35fa:	bf 92       	push	r11
    35fc:	cf 92       	push	r12
    35fe:	ef 92       	push	r14
    3600:	0f 93       	push	r16
    3602:	1f 93       	push	r17
    3604:	cf 93       	push	r28
    3606:	df 93       	push	r29
    3608:	ec 01       	movw	r28, r24
    360a:	16 2f       	mov	r17, r22
  // set mode to standby
  int16_t state = SX127x::standby();
    360c:	0e 94 82 1a 	call	0x3504	; 0x3504 <_ZN6SX127x7standbyEv>
    3610:	5c 01       	movw	r10, r24

  // write register
  state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_MODEM_CONFIG_1, newCodingRate, 3, 1);
    3612:	c7 5e       	subi	r28, 0xE7	; 231
    3614:	de 4f       	sbci	r29, 0xFE	; 254
    3616:	cc 24       	eor	r12, r12
    3618:	ca 94       	dec	r12
    361a:	68 94       	set
    361c:	ee 24       	eor	r14, r14
    361e:	e1 f8       	bld	r14, 1
    3620:	01 e0       	ldi	r16, 0x01	; 1
    3622:	23 e0       	ldi	r18, 0x03	; 3
    3624:	41 2f       	mov	r20, r17
    3626:	6d e1       	ldi	r22, 0x1D	; 29
    3628:	70 e0       	ldi	r23, 0x00	; 0
    362a:	88 81       	ld	r24, Y
    362c:	99 81       	ldd	r25, Y+1	; 0x01
    362e:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
  return(state);
}
    3632:	8a 29       	or	r24, r10
    3634:	9b 29       	or	r25, r11
    3636:	df 91       	pop	r29
    3638:	cf 91       	pop	r28
    363a:	1f 91       	pop	r17
    363c:	0f 91       	pop	r16
    363e:	ef 90       	pop	r14
    3640:	cf 90       	pop	r12
    3642:	bf 90       	pop	r11
    3644:	af 90       	pop	r10
    3646:	08 95       	ret

00003648 <_ZN6SX127821setSpreadingFactorRawEh>:
  // write register
  state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_MODEM_CONFIG_1, newBandwidth, 7, 4);
  return(state);
}

int16_t SX1278::setSpreadingFactorRaw(uint8_t newSpreadingFactor) {
    3648:	af 92       	push	r10
    364a:	bf 92       	push	r11
    364c:	cf 92       	push	r12
    364e:	ef 92       	push	r14
    3650:	0f 93       	push	r16
    3652:	1f 93       	push	r17
    3654:	cf 93       	push	r28
    3656:	df 93       	push	r29
    3658:	5c 01       	movw	r10, r24
    365a:	16 2f       	mov	r17, r22
  // set mode to standby
  int16_t state = SX127x::standby();
    365c:	0e 94 82 1a 	call	0x3504	; 0x3504 <_ZN6SX127x7standbyEv>
    3660:	ec 01       	movw	r28, r24

  // write registers
  if(newSpreadingFactor == RADIOLIB_SX127X_SF_6) {
    3662:	10 36       	cpi	r17, 0x60	; 96
    3664:	09 f4       	brne	.+2      	; 0x3668 <_ZN6SX127821setSpreadingFactorRawEh+0x20>
    3666:	41 c0       	rjmp	.+130    	; 0x36ea <_ZN6SX127821setSpreadingFactorRawEh+0xa2>
    state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_MODEM_CONFIG_1, RADIOLIB_SX1278_HEADER_IMPL_MODE, 0, 0);
    state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_MODEM_CONFIG_2, RADIOLIB_SX127X_SF_6 | RADIOLIB_SX127X_TX_MODE_SINGLE, 7, 3);
    state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_DETECT_OPTIMIZE, RADIOLIB_SX127X_DETECT_OPTIMIZE_SF_6, 2, 0);
    state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_DETECTION_THRESHOLD, RADIOLIB_SX127X_DETECTION_THRESHOLD_SF_6);
  } else {
    state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_MODEM_CONFIG_1, RADIOLIB_SX1278_HEADER_EXPL_MODE, 0, 0);
    3668:	f7 ee       	ldi	r31, 0xE7	; 231
    366a:	af 1a       	sub	r10, r31
    366c:	fe ef       	ldi	r31, 0xFE	; 254
    366e:	bf 0a       	sbc	r11, r31
    3670:	cc 24       	eor	r12, r12
    3672:	ca 94       	dec	r12
    3674:	68 94       	set
    3676:	ee 24       	eor	r14, r14
    3678:	e1 f8       	bld	r14, 1
    367a:	00 e0       	ldi	r16, 0x00	; 0
    367c:	20 e0       	ldi	r18, 0x00	; 0
    367e:	40 e0       	ldi	r20, 0x00	; 0
    3680:	6d e1       	ldi	r22, 0x1D	; 29
    3682:	70 e0       	ldi	r23, 0x00	; 0
    3684:	f5 01       	movw	r30, r10
    3686:	80 81       	ld	r24, Z
    3688:	91 81       	ldd	r25, Z+1	; 0x01
    368a:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    368e:	c8 2b       	or	r28, r24
    3690:	d9 2b       	or	r29, r25
    state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_MODEM_CONFIG_2, newSpreadingFactor | RADIOLIB_SX127X_TX_MODE_SINGLE, 7, 3);
    3692:	03 e0       	ldi	r16, 0x03	; 3
    3694:	27 e0       	ldi	r18, 0x07	; 7
    3696:	41 2f       	mov	r20, r17
    3698:	6e e1       	ldi	r22, 0x1E	; 30
    369a:	70 e0       	ldi	r23, 0x00	; 0
    369c:	f5 01       	movw	r30, r10
    369e:	80 81       	ld	r24, Z
    36a0:	91 81       	ldd	r25, Z+1	; 0x01
    36a2:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    36a6:	c8 2b       	or	r28, r24
    36a8:	d9 2b       	or	r29, r25
    state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_DETECT_OPTIMIZE, RADIOLIB_SX127X_DETECT_OPTIMIZE_SF_7_12, 2, 0);
    36aa:	00 e0       	ldi	r16, 0x00	; 0
    36ac:	22 e0       	ldi	r18, 0x02	; 2
    36ae:	43 e0       	ldi	r20, 0x03	; 3
    36b0:	61 e3       	ldi	r22, 0x31	; 49
    36b2:	70 e0       	ldi	r23, 0x00	; 0
    36b4:	f5 01       	movw	r30, r10
    36b6:	80 81       	ld	r24, Z
    36b8:	91 81       	ldd	r25, Z+1	; 0x01
    36ba:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    36be:	c8 2b       	or	r28, r24
    36c0:	d9 2b       	or	r29, r25
    state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_DETECTION_THRESHOLD, RADIOLIB_SX127X_DETECTION_THRESHOLD_SF_7_12);
    36c2:	27 e0       	ldi	r18, 0x07	; 7
    36c4:	4a e0       	ldi	r20, 0x0A	; 10
    36c6:	67 e3       	ldi	r22, 0x37	; 55
    36c8:	70 e0       	ldi	r23, 0x00	; 0
    36ca:	f5 01       	movw	r30, r10
    36cc:	80 81       	ld	r24, Z
    36ce:	91 81       	ldd	r25, Z+1	; 0x01
    36d0:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    36d4:	8c 2b       	or	r24, r28
    36d6:	9d 2b       	or	r25, r29
  }
  return(state);
}
    36d8:	df 91       	pop	r29
    36da:	cf 91       	pop	r28
    36dc:	1f 91       	pop	r17
    36de:	0f 91       	pop	r16
    36e0:	ef 90       	pop	r14
    36e2:	cf 90       	pop	r12
    36e4:	bf 90       	pop	r11
    36e6:	af 90       	pop	r10
    36e8:	08 95       	ret
  // set mode to standby
  int16_t state = SX127x::standby();

  // write registers
  if(newSpreadingFactor == RADIOLIB_SX127X_SF_6) {
    state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_MODEM_CONFIG_1, RADIOLIB_SX1278_HEADER_IMPL_MODE, 0, 0);
    36ea:	87 ee       	ldi	r24, 0xE7	; 231
    36ec:	a8 1a       	sub	r10, r24
    36ee:	8e ef       	ldi	r24, 0xFE	; 254
    36f0:	b8 0a       	sbc	r11, r24
    36f2:	cc 24       	eor	r12, r12
    36f4:	ca 94       	dec	r12
    36f6:	68 94       	set
    36f8:	ee 24       	eor	r14, r14
    36fa:	e1 f8       	bld	r14, 1
    36fc:	00 e0       	ldi	r16, 0x00	; 0
    36fe:	20 e0       	ldi	r18, 0x00	; 0
    3700:	41 e0       	ldi	r20, 0x01	; 1
    3702:	6d e1       	ldi	r22, 0x1D	; 29
    3704:	70 e0       	ldi	r23, 0x00	; 0
    3706:	f5 01       	movw	r30, r10
    3708:	80 81       	ld	r24, Z
    370a:	91 81       	ldd	r25, Z+1	; 0x01
    370c:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    3710:	c8 2b       	or	r28, r24
    3712:	d9 2b       	or	r29, r25
    state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_MODEM_CONFIG_2, RADIOLIB_SX127X_SF_6 | RADIOLIB_SX127X_TX_MODE_SINGLE, 7, 3);
    3714:	03 e0       	ldi	r16, 0x03	; 3
    3716:	27 e0       	ldi	r18, 0x07	; 7
    3718:	40 e6       	ldi	r20, 0x60	; 96
    371a:	6e e1       	ldi	r22, 0x1E	; 30
    371c:	70 e0       	ldi	r23, 0x00	; 0
    371e:	f5 01       	movw	r30, r10
    3720:	80 81       	ld	r24, Z
    3722:	91 81       	ldd	r25, Z+1	; 0x01
    3724:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    3728:	c8 2b       	or	r28, r24
    372a:	d9 2b       	or	r29, r25
    state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_DETECT_OPTIMIZE, RADIOLIB_SX127X_DETECT_OPTIMIZE_SF_6, 2, 0);
    372c:	00 e0       	ldi	r16, 0x00	; 0
    372e:	22 e0       	ldi	r18, 0x02	; 2
    3730:	45 e0       	ldi	r20, 0x05	; 5
    3732:	61 e3       	ldi	r22, 0x31	; 49
    3734:	70 e0       	ldi	r23, 0x00	; 0
    3736:	f5 01       	movw	r30, r10
    3738:	80 81       	ld	r24, Z
    373a:	91 81       	ldd	r25, Z+1	; 0x01
    373c:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    3740:	c8 2b       	or	r28, r24
    3742:	d9 2b       	or	r29, r25
    state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_DETECTION_THRESHOLD, RADIOLIB_SX127X_DETECTION_THRESHOLD_SF_6);
    3744:	27 e0       	ldi	r18, 0x07	; 7
    3746:	4c e0       	ldi	r20, 0x0C	; 12
    3748:	67 e3       	ldi	r22, 0x37	; 55
    374a:	70 e0       	ldi	r23, 0x00	; 0
    374c:	f5 01       	movw	r30, r10
    374e:	80 81       	ld	r24, Z
    3750:	91 81       	ldd	r25, Z+1	; 0x01
    3752:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    3756:	8c 2b       	or	r24, r28
    3758:	9d 2b       	or	r25, r29
    375a:	be cf       	rjmp	.-132    	; 0x36d8 <_ZN6SX127821setSpreadingFactorRawEh+0x90>

0000375c <_ZN6SX127815setBandwidthRawEh>:

int16_t SX1278::explicitHeader() {
  return(setHeaderType(RADIOLIB_SX1278_HEADER_EXPL_MODE));
}

int16_t SX1278::setBandwidthRaw(uint8_t newBandwidth) {
    375c:	af 92       	push	r10
    375e:	bf 92       	push	r11
    3760:	cf 92       	push	r12
    3762:	ef 92       	push	r14
    3764:	0f 93       	push	r16
    3766:	1f 93       	push	r17
    3768:	cf 93       	push	r28
    376a:	df 93       	push	r29
    376c:	ec 01       	movw	r28, r24
    376e:	16 2f       	mov	r17, r22
  // set mode to standby
  int16_t state = SX127x::standby();
    3770:	0e 94 82 1a 	call	0x3504	; 0x3504 <_ZN6SX127x7standbyEv>
    3774:	5c 01       	movw	r10, r24

  // write register
  state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_MODEM_CONFIG_1, newBandwidth, 7, 4);
    3776:	c7 5e       	subi	r28, 0xE7	; 231
    3778:	de 4f       	sbci	r29, 0xFE	; 254
    377a:	cc 24       	eor	r12, r12
    377c:	ca 94       	dec	r12
    377e:	68 94       	set
    3780:	ee 24       	eor	r14, r14
    3782:	e1 f8       	bld	r14, 1
    3784:	04 e0       	ldi	r16, 0x04	; 4
    3786:	27 e0       	ldi	r18, 0x07	; 7
    3788:	41 2f       	mov	r20, r17
    378a:	6d e1       	ldi	r22, 0x1D	; 29
    378c:	70 e0       	ldi	r23, 0x00	; 0
    378e:	88 81       	ld	r24, Y
    3790:	99 81       	ldd	r25, Y+1	; 0x01
    3792:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
  return(state);
}
    3796:	8a 29       	or	r24, r10
    3798:	9b 29       	or	r25, r11
    379a:	df 91       	pop	r29
    379c:	cf 91       	pop	r28
    379e:	1f 91       	pop	r17
    37a0:	0f 91       	pop	r16
    37a2:	ef 90       	pop	r14
    37a4:	cf 90       	pop	r12
    37a6:	bf 90       	pop	r11
    37a8:	af 90       	pop	r10
    37aa:	08 95       	ret

000037ac <_ZN6SX127814setOutputPowerEab>:

int16_t SX1278::setOutputPower(int8_t power) {
  return(this->setOutputPower(power, false));
}

int16_t SX1278::setOutputPower(int8_t power, bool useRfo) {
    37ac:	af 92       	push	r10
    37ae:	bf 92       	push	r11
    37b0:	cf 92       	push	r12
    37b2:	ef 92       	push	r14
    37b4:	0f 93       	push	r16
    37b6:	1f 93       	push	r17
    37b8:	cf 93       	push	r28
    37ba:	df 93       	push	r29
  // check allowed power range
  if(useRfo) {
    37bc:	44 23       	and	r20, r20
    37be:	09 f4       	brne	.+2      	; 0x37c2 <_ZN6SX127814setOutputPowerEab+0x16>
    37c0:	41 c0       	rjmp	.+130    	; 0x3844 <_ZN6SX127814setOutputPowerEab+0x98>
    // RFO output
    RADIOLIB_CHECK_RANGE(power, -3, 15, RADIOLIB_ERR_INVALID_OUTPUT_POWER);
    37c2:	23 e0       	ldi	r18, 0x03	; 3
    37c4:	26 0f       	add	r18, r22
    37c6:	23 31       	cpi	r18, 0x13	; 19
    37c8:	08 f0       	brcs	.+2      	; 0x37cc <_ZN6SX127814setOutputPowerEab+0x20>
    37ca:	9d c0       	rjmp	.+314    	; 0x3906 <_ZN6SX127814setOutputPowerEab+0x15a>
    37cc:	04 2f       	mov	r16, r20
    37ce:	16 2f       	mov	r17, r22
    37d0:	ec 01       	movw	r28, r24
      RADIOLIB_CHECK_RANGE(power, 2, 17, RADIOLIB_ERR_INVALID_OUTPUT_POWER);
    }
  }

  // set mode to standby
  int16_t state = SX127x::standby();
    37d2:	0e 94 82 1a 	call	0x3504	; 0x3504 <_ZN6SX127x7standbyEv>
    37d6:	5c 01       	movw	r10, r24

  if(useRfo) {
    37d8:	00 23       	and	r16, r16
    37da:	09 f4       	brne	.+2      	; 0x37de <_ZN6SX127814setOutputPowerEab+0x32>
    37dc:	40 c0       	rjmp	.+128    	; 0x385e <_ZN6SX127814setOutputPowerEab+0xb2>
    uint8_t paCfg = 0;
    if(power < 0) {
    37de:	11 23       	and	r17, r17
    37e0:	dc f1       	brlt	.+118    	; 0x3858 <_ZN6SX127814setOutputPowerEab+0xac>
      // low power mode RFO output
      paCfg = RADIOLIB_SX1278_LOW_POWER | (power + 3);
    } else {
      // high power mode RFO output
      paCfg = RADIOLIB_SX1278_MAX_POWER | power;
    37e2:	10 67       	ori	r17, 0x70	; 112
    }

    state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_PA_CONFIG, RADIOLIB_SX127X_PA_SELECT_RFO, 7, 7);
    37e4:	c7 5e       	subi	r28, 0xE7	; 231
    37e6:	de 4f       	sbci	r29, 0xFE	; 254
    37e8:	cc 24       	eor	r12, r12
    37ea:	ca 94       	dec	r12
    37ec:	68 94       	set
    37ee:	ee 24       	eor	r14, r14
    37f0:	e1 f8       	bld	r14, 1
    37f2:	07 e0       	ldi	r16, 0x07	; 7
    37f4:	27 e0       	ldi	r18, 0x07	; 7
    37f6:	40 e0       	ldi	r20, 0x00	; 0
    37f8:	69 e0       	ldi	r22, 0x09	; 9
    37fa:	70 e0       	ldi	r23, 0x00	; 0
    37fc:	88 81       	ld	r24, Y
    37fe:	99 81       	ldd	r25, Y+1	; 0x01
    3800:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    3804:	a8 2a       	or	r10, r24
    3806:	b9 2a       	or	r11, r25
    state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_PA_CONFIG, paCfg, 6, 0);
    3808:	00 e0       	ldi	r16, 0x00	; 0
    380a:	26 e0       	ldi	r18, 0x06	; 6
    380c:	41 2f       	mov	r20, r17
    380e:	69 e0       	ldi	r22, 0x09	; 9
    3810:	70 e0       	ldi	r23, 0x00	; 0
    3812:	88 81       	ld	r24, Y
    3814:	99 81       	ldd	r25, Y+1	; 0x01
    3816:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    381a:	a8 2a       	or	r10, r24
    381c:	b9 2a       	or	r11, r25
    state |= this->mod->SPIsetRegValue(RADIOLIB_SX1278_REG_PA_DAC, RADIOLIB_SX127X_PA_BOOST_OFF, 2, 0);
    381e:	22 e0       	ldi	r18, 0x02	; 2
    3820:	44 e0       	ldi	r20, 0x04	; 4
    3822:	6d e4       	ldi	r22, 0x4D	; 77
    3824:	70 e0       	ldi	r23, 0x00	; 0
    3826:	88 81       	ld	r24, Y
    3828:	99 81       	ldd	r25, Y+1	; 0x01
    382a:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    382e:	8a 29       	or	r24, r10
    3830:	9b 29       	or	r25, r11

    }
  }

  return(state);
}
    3832:	df 91       	pop	r29
    3834:	cf 91       	pop	r28
    3836:	1f 91       	pop	r17
    3838:	0f 91       	pop	r16
    383a:	ef 90       	pop	r14
    383c:	cf 90       	pop	r12
    383e:	bf 90       	pop	r11
    3840:	af 90       	pop	r10
    3842:	08 95       	ret
  if(useRfo) {
    // RFO output
    RADIOLIB_CHECK_RANGE(power, -3, 15, RADIOLIB_ERR_INVALID_OUTPUT_POWER);
  } else {
    // PA_BOOST output, check high-power operation
    if(power != 20) {
    3844:	64 31       	cpi	r22, 0x14	; 20
    3846:	11 f2       	breq	.-124    	; 0x37cc <_ZN6SX127814setOutputPowerEab+0x20>
      RADIOLIB_CHECK_RANGE(power, 2, 17, RADIOLIB_ERR_INVALID_OUTPUT_POWER);
    3848:	2e ef       	ldi	r18, 0xFE	; 254
    384a:	26 0f       	add	r18, r22
    384c:	20 31       	cpi	r18, 0x10	; 16
    384e:	08 f4       	brcc	.+2      	; 0x3852 <_ZN6SX127814setOutputPowerEab+0xa6>
    3850:	bd cf       	rjmp	.-134    	; 0x37cc <_ZN6SX127814setOutputPowerEab+0x20>
    3852:	83 ef       	ldi	r24, 0xF3	; 243
    3854:	9f ef       	ldi	r25, 0xFF	; 255
    3856:	ed cf       	rjmp	.-38     	; 0x3832 <_ZN6SX127814setOutputPowerEab+0x86>

  if(useRfo) {
    uint8_t paCfg = 0;
    if(power < 0) {
      // low power mode RFO output
      paCfg = RADIOLIB_SX1278_LOW_POWER | (power + 3);
    3858:	1d 5f       	subi	r17, 0xFD	; 253
    385a:	10 62       	ori	r17, 0x20	; 32
    385c:	c3 cf       	rjmp	.-122    	; 0x37e4 <_ZN6SX127814setOutputPowerEab+0x38>
    state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_PA_CONFIG, RADIOLIB_SX127X_PA_SELECT_RFO, 7, 7);
    state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_PA_CONFIG, paCfg, 6, 0);
    state |= this->mod->SPIsetRegValue(RADIOLIB_SX1278_REG_PA_DAC, RADIOLIB_SX127X_PA_BOOST_OFF, 2, 0);

  } else {
    if(power != 20) {
    385e:	14 31       	cpi	r17, 0x14	; 20
    3860:	51 f1       	breq	.+84     	; 0x38b6 <_ZN6SX127814setOutputPowerEab+0x10a>
      // power is 2 - 17 dBm, enable PA1 + PA2 on PA_BOOST
      state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_PA_CONFIG, RADIOLIB_SX127X_PA_SELECT_BOOST, 7, 7);
    3862:	c7 5e       	subi	r28, 0xE7	; 231
    3864:	de 4f       	sbci	r29, 0xFE	; 254
    3866:	cc 24       	eor	r12, r12
    3868:	ca 94       	dec	r12
    386a:	68 94       	set
    386c:	ee 24       	eor	r14, r14
    386e:	e1 f8       	bld	r14, 1
    3870:	07 e0       	ldi	r16, 0x07	; 7
    3872:	27 e0       	ldi	r18, 0x07	; 7
    3874:	40 e8       	ldi	r20, 0x80	; 128
    3876:	69 e0       	ldi	r22, 0x09	; 9
    3878:	70 e0       	ldi	r23, 0x00	; 0
    387a:	88 81       	ld	r24, Y
    387c:	99 81       	ldd	r25, Y+1	; 0x01
    387e:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    3882:	a8 2a       	or	r10, r24
    3884:	b9 2a       	or	r11, r25
      state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_PA_CONFIG, RADIOLIB_SX1278_MAX_POWER | (power - 2), 6, 0);
    3886:	4e ef       	ldi	r20, 0xFE	; 254
    3888:	41 0f       	add	r20, r17
    388a:	40 67       	ori	r20, 0x70	; 112
    388c:	00 e0       	ldi	r16, 0x00	; 0
    388e:	26 e0       	ldi	r18, 0x06	; 6
    3890:	69 e0       	ldi	r22, 0x09	; 9
    3892:	70 e0       	ldi	r23, 0x00	; 0
    3894:	88 81       	ld	r24, Y
    3896:	99 81       	ldd	r25, Y+1	; 0x01
    3898:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    389c:	a8 2a       	or	r10, r24
    389e:	b9 2a       	or	r11, r25
      state |= this->mod->SPIsetRegValue(RADIOLIB_SX1278_REG_PA_DAC, RADIOLIB_SX127X_PA_BOOST_OFF, 2, 0);
    38a0:	22 e0       	ldi	r18, 0x02	; 2
    38a2:	44 e0       	ldi	r20, 0x04	; 4
    38a4:	6d e4       	ldi	r22, 0x4D	; 77
    38a6:	70 e0       	ldi	r23, 0x00	; 0
    38a8:	88 81       	ld	r24, Y
    38aa:	99 81       	ldd	r25, Y+1	; 0x01
    38ac:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    38b0:	8a 29       	or	r24, r10
    38b2:	9b 29       	or	r25, r11
    38b4:	be cf       	rjmp	.-132    	; 0x3832 <_ZN6SX127814setOutputPowerEab+0x86>

    } else {
      // power is 20 dBm, enable PA1 + PA2 on PA_BOOST and enable high power control
      state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_PA_CONFIG, RADIOLIB_SX127X_PA_SELECT_BOOST, 7, 7);
    38b6:	c7 5e       	subi	r28, 0xE7	; 231
    38b8:	de 4f       	sbci	r29, 0xFE	; 254
    38ba:	cc 24       	eor	r12, r12
    38bc:	ca 94       	dec	r12
    38be:	68 94       	set
    38c0:	ee 24       	eor	r14, r14
    38c2:	e1 f8       	bld	r14, 1
    38c4:	07 e0       	ldi	r16, 0x07	; 7
    38c6:	27 e0       	ldi	r18, 0x07	; 7
    38c8:	40 e8       	ldi	r20, 0x80	; 128
    38ca:	69 e0       	ldi	r22, 0x09	; 9
    38cc:	70 e0       	ldi	r23, 0x00	; 0
    38ce:	88 81       	ld	r24, Y
    38d0:	99 81       	ldd	r25, Y+1	; 0x01
    38d2:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    38d6:	a8 2a       	or	r10, r24
    38d8:	b9 2a       	or	r11, r25
      state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_PA_CONFIG, RADIOLIB_SX1278_MAX_POWER | 0x0F, 6, 0);
    38da:	00 e0       	ldi	r16, 0x00	; 0
    38dc:	26 e0       	ldi	r18, 0x06	; 6
    38de:	4f e7       	ldi	r20, 0x7F	; 127
    38e0:	69 e0       	ldi	r22, 0x09	; 9
    38e2:	70 e0       	ldi	r23, 0x00	; 0
    38e4:	88 81       	ld	r24, Y
    38e6:	99 81       	ldd	r25, Y+1	; 0x01
    38e8:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    38ec:	a8 2a       	or	r10, r24
    38ee:	b9 2a       	or	r11, r25
      state |= this->mod->SPIsetRegValue(RADIOLIB_SX1278_REG_PA_DAC, RADIOLIB_SX127X_PA_BOOST_ON, 2, 0);
    38f0:	22 e0       	ldi	r18, 0x02	; 2
    38f2:	47 e0       	ldi	r20, 0x07	; 7
    38f4:	6d e4       	ldi	r22, 0x4D	; 77
    38f6:	70 e0       	ldi	r23, 0x00	; 0
    38f8:	88 81       	ld	r24, Y
    38fa:	99 81       	ldd	r25, Y+1	; 0x01
    38fc:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    3900:	8a 29       	or	r24, r10
    3902:	9b 29       	or	r25, r11
    3904:	96 cf       	rjmp	.-212    	; 0x3832 <_ZN6SX127814setOutputPowerEab+0x86>

int16_t SX1278::setOutputPower(int8_t power, bool useRfo) {
  // check allowed power range
  if(useRfo) {
    // RFO output
    RADIOLIB_CHECK_RANGE(power, -3, 15, RADIOLIB_ERR_INVALID_OUTPUT_POWER);
    3906:	83 ef       	ldi	r24, 0xF3	; 243
    3908:	9f ef       	ldi	r25, 0xFF	; 255
    390a:	93 cf       	rjmp	.-218    	; 0x3832 <_ZN6SX127814setOutputPowerEab+0x86>

0000390c <_ZN6SX127814setOutputPowerEa>:

  return(state);
}

int16_t SX1278::setOutputPower(int8_t power) {
  return(this->setOutputPower(power, false));
    390c:	40 e0       	ldi	r20, 0x00	; 0
    390e:	0e 94 d6 1b 	call	0x37ac	; 0x37ac <_ZN6SX127814setOutputPowerEab>
}
    3912:	08 95       	ret

00003914 <_ZN6SX127x5sleepEv>:
  }

  return(RADIOLIB_CHANNEL_FREE);
}

int16_t SX127x::sleep() {
    3914:	cf 93       	push	r28
    3916:	df 93       	push	r29
    3918:	ec 01       	movw	r28, r24
  // set RF switch (if present)
  this->mod->setRfSwitchState(Module::MODE_IDLE);
    391a:	fc 01       	movw	r30, r24
    391c:	e7 5e       	subi	r30, 0xE7	; 231
    391e:	fe 4f       	sbci	r31, 0xFE	; 254
    3920:	61 e0       	ldi	r22, 0x01	; 1
    3922:	80 81       	ld	r24, Z
    3924:	91 81       	ldd	r25, Z+1	; 0x01
    3926:	0e 94 c3 09 	call	0x1386	; 0x1386 <_ZN6Module16setRfSwitchStateEh>

  // set mode to sleep
  return(setMode(RADIOLIB_SX127X_SLEEP));
    392a:	60 e0       	ldi	r22, 0x00	; 0
    392c:	ce 01       	movw	r24, r28
    392e:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN6SX127x7setModeEh>
}
    3932:	df 91       	pop	r29
    3934:	cf 91       	pop	r28
    3936:	08 95       	ret

00003938 <_ZN6SX127x11setEncodingEh>:
  state = this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_RSSI_CONFIG, offset << 3, 7, 3);
  state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_RSSI_CONFIG, smoothingSamples, 2, 0);
  return(state);
}

int16_t SX127x::setEncoding(uint8_t encoding) {
    3938:	cf 92       	push	r12
    393a:	ef 92       	push	r14
    393c:	0f 93       	push	r16
    393e:	1f 93       	push	r17
    3940:	cf 93       	push	r28
    3942:	df 93       	push	r29
    3944:	ec 01       	movw	r28, r24
    3946:	16 2f       	mov	r17, r22
  // check active modem
  if(getActiveModem() != RADIOLIB_SX127X_FSK_OOK) {
    3948:	0e 94 ec 18 	call	0x31d8	; 0x31d8 <_ZN6SX127x14getActiveModemEv>
    394c:	89 2b       	or	r24, r25
    394e:	09 f0       	breq	.+2      	; 0x3952 <_ZN6SX127x11setEncodingEh+0x1a>
    3950:	41 c0       	rjmp	.+130    	; 0x39d4 <_ZN6SX127x11setEncodingEh+0x9c>
    return(RADIOLIB_ERR_WRONG_MODEM);
  }

  // set encoding
  switch(encoding) {
    3952:	11 30       	cpi	r17, 0x01	; 1
    3954:	e9 f0       	breq	.+58     	; 0x3990 <_ZN6SX127x11setEncodingEh+0x58>
    3956:	28 f0       	brcs	.+10     	; 0x3962 <_ZN6SX127x11setEncodingEh+0x2a>
    3958:	12 30       	cpi	r17, 0x02	; 2
    395a:	59 f1       	breq	.+86     	; 0x39b2 <_ZN6SX127x11setEncodingEh+0x7a>
    case RADIOLIB_ENCODING_MANCHESTER:
      return(this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_PACKET_CONFIG_1, RADIOLIB_SX127X_DC_FREE_MANCHESTER, 6, 5));
    case RADIOLIB_ENCODING_WHITENING:
      return(this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_PACKET_CONFIG_1, RADIOLIB_SX127X_DC_FREE_WHITENING, 6, 5));
    default:
      return(RADIOLIB_ERR_INVALID_ENCODING);
    395c:	89 ee       	ldi	r24, 0xE9	; 233
    395e:	9f ef       	ldi	r25, 0xFF	; 255
    3960:	10 c0       	rjmp	.+32     	; 0x3982 <_ZN6SX127x11setEncodingEh+0x4a>
  }

  // set encoding
  switch(encoding) {
    case RADIOLIB_ENCODING_NRZ:
      return(this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_PACKET_CONFIG_1, RADIOLIB_SX127X_DC_FREE_NONE, 6, 5));
    3962:	c7 5e       	subi	r28, 0xE7	; 231
    3964:	de 4f       	sbci	r29, 0xFE	; 254
    3966:	cc 24       	eor	r12, r12
    3968:	ca 94       	dec	r12
    396a:	68 94       	set
    396c:	ee 24       	eor	r14, r14
    396e:	e1 f8       	bld	r14, 1
    3970:	05 e0       	ldi	r16, 0x05	; 5
    3972:	26 e0       	ldi	r18, 0x06	; 6
    3974:	40 e0       	ldi	r20, 0x00	; 0
    3976:	60 e3       	ldi	r22, 0x30	; 48
    3978:	70 e0       	ldi	r23, 0x00	; 0
    397a:	88 81       	ld	r24, Y
    397c:	99 81       	ldd	r25, Y+1	; 0x01
    397e:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    case RADIOLIB_ENCODING_WHITENING:
      return(this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_PACKET_CONFIG_1, RADIOLIB_SX127X_DC_FREE_WHITENING, 6, 5));
    default:
      return(RADIOLIB_ERR_INVALID_ENCODING);
  }
}
    3982:	df 91       	pop	r29
    3984:	cf 91       	pop	r28
    3986:	1f 91       	pop	r17
    3988:	0f 91       	pop	r16
    398a:	ef 90       	pop	r14
    398c:	cf 90       	pop	r12
    398e:	08 95       	ret
  // set encoding
  switch(encoding) {
    case RADIOLIB_ENCODING_NRZ:
      return(this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_PACKET_CONFIG_1, RADIOLIB_SX127X_DC_FREE_NONE, 6, 5));
    case RADIOLIB_ENCODING_MANCHESTER:
      return(this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_PACKET_CONFIG_1, RADIOLIB_SX127X_DC_FREE_MANCHESTER, 6, 5));
    3990:	c7 5e       	subi	r28, 0xE7	; 231
    3992:	de 4f       	sbci	r29, 0xFE	; 254
    3994:	cc 24       	eor	r12, r12
    3996:	ca 94       	dec	r12
    3998:	68 94       	set
    399a:	ee 24       	eor	r14, r14
    399c:	e1 f8       	bld	r14, 1
    399e:	05 e0       	ldi	r16, 0x05	; 5
    39a0:	26 e0       	ldi	r18, 0x06	; 6
    39a2:	40 e2       	ldi	r20, 0x20	; 32
    39a4:	60 e3       	ldi	r22, 0x30	; 48
    39a6:	70 e0       	ldi	r23, 0x00	; 0
    39a8:	88 81       	ld	r24, Y
    39aa:	99 81       	ldd	r25, Y+1	; 0x01
    39ac:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    39b0:	e8 cf       	rjmp	.-48     	; 0x3982 <_ZN6SX127x11setEncodingEh+0x4a>
    case RADIOLIB_ENCODING_WHITENING:
      return(this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_PACKET_CONFIG_1, RADIOLIB_SX127X_DC_FREE_WHITENING, 6, 5));
    39b2:	c7 5e       	subi	r28, 0xE7	; 231
    39b4:	de 4f       	sbci	r29, 0xFE	; 254
    39b6:	cc 24       	eor	r12, r12
    39b8:	ca 94       	dec	r12
    39ba:	68 94       	set
    39bc:	ee 24       	eor	r14, r14
    39be:	e1 f8       	bld	r14, 1
    39c0:	05 e0       	ldi	r16, 0x05	; 5
    39c2:	26 e0       	ldi	r18, 0x06	; 6
    39c4:	40 e4       	ldi	r20, 0x40	; 64
    39c6:	60 e3       	ldi	r22, 0x30	; 48
    39c8:	70 e0       	ldi	r23, 0x00	; 0
    39ca:	88 81       	ld	r24, Y
    39cc:	99 81       	ldd	r25, Y+1	; 0x01
    39ce:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    39d2:	d7 cf       	rjmp	.-82     	; 0x3982 <_ZN6SX127x11setEncodingEh+0x4a>
}

int16_t SX127x::setEncoding(uint8_t encoding) {
  // check active modem
  if(getActiveModem() != RADIOLIB_SX127X_FSK_OOK) {
    return(RADIOLIB_ERR_WRONG_MODEM);
    39d4:	8c ee       	ldi	r24, 0xEC	; 236
    39d6:	9f ef       	ldi	r25, 0xFF	; 255
    39d8:	d4 cf       	rjmp	.-88     	; 0x3982 <_ZN6SX127x11setEncodingEh+0x4a>

000039da <_ZN6SX127x16setAFCAGCTriggerEh>:

  //set AFC auto on/off
  return(this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_RX_CONFIG, isEnabled ? RADIOLIB_SX127X_AFC_AUTO_ON : RADIOLIB_SX127X_AFC_AUTO_OFF, 4, 4));
}

int16_t SX127x::setAFCAGCTrigger(uint8_t trigger) {
    39da:	cf 92       	push	r12
    39dc:	ef 92       	push	r14
    39de:	0f 93       	push	r16
    39e0:	1f 93       	push	r17
    39e2:	cf 93       	push	r28
    39e4:	df 93       	push	r29
    39e6:	ec 01       	movw	r28, r24
    39e8:	16 2f       	mov	r17, r22
  if(getActiveModem() != RADIOLIB_SX127X_FSK_OOK) {
    39ea:	0e 94 ec 18 	call	0x31d8	; 0x31d8 <_ZN6SX127x14getActiveModemEv>
    39ee:	89 2b       	or	r24, r25
    39f0:	b9 f4       	brne	.+46     	; 0x3a20 <_ZN6SX127x16setAFCAGCTriggerEh+0x46>
    return(RADIOLIB_ERR_WRONG_MODEM);
  }

  //set AFC&AGC trigger
  return(this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_RX_CONFIG, trigger, 2, 0));
    39f2:	c7 5e       	subi	r28, 0xE7	; 231
    39f4:	de 4f       	sbci	r29, 0xFE	; 254
    39f6:	cc 24       	eor	r12, r12
    39f8:	ca 94       	dec	r12
    39fa:	68 94       	set
    39fc:	ee 24       	eor	r14, r14
    39fe:	e1 f8       	bld	r14, 1
    3a00:	00 e0       	ldi	r16, 0x00	; 0
    3a02:	22 e0       	ldi	r18, 0x02	; 2
    3a04:	41 2f       	mov	r20, r17
    3a06:	6d e0       	ldi	r22, 0x0D	; 13
    3a08:	70 e0       	ldi	r23, 0x00	; 0
    3a0a:	88 81       	ld	r24, Y
    3a0c:	99 81       	ldd	r25, Y+1	; 0x01
    3a0e:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
}
    3a12:	df 91       	pop	r29
    3a14:	cf 91       	pop	r28
    3a16:	1f 91       	pop	r17
    3a18:	0f 91       	pop	r16
    3a1a:	ef 90       	pop	r14
    3a1c:	cf 90       	pop	r12
    3a1e:	08 95       	ret
  return(this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_RX_CONFIG, isEnabled ? RADIOLIB_SX127X_AFC_AUTO_ON : RADIOLIB_SX127X_AFC_AUTO_OFF, 4, 4));
}

int16_t SX127x::setAFCAGCTrigger(uint8_t trigger) {
  if(getActiveModem() != RADIOLIB_SX127X_FSK_OOK) {
    return(RADIOLIB_ERR_WRONG_MODEM);
    3a20:	8c ee       	ldi	r24, 0xEC	; 236
    3a22:	9f ef       	ldi	r25, 0xFF	; 255
    3a24:	f6 cf       	rjmp	.-20     	; 0x3a12 <_ZN6SX127x16setAFCAGCTriggerEh+0x38>

00003a26 <_ZN6SX127x10directModeEv>:

  // start receiving
  return(setMode(RADIOLIB_SX127X_RX));
}

int16_t SX127x::directMode() {
    3a26:	cf 92       	push	r12
    3a28:	ef 92       	push	r14
    3a2a:	0f 93       	push	r16
    3a2c:	cf 93       	push	r28
    3a2e:	df 93       	push	r29
    3a30:	ec 01       	movw	r28, r24
  // set mode to standby
  int16_t state = setMode(RADIOLIB_SX127X_STANDBY);
    3a32:	61 e0       	ldi	r22, 0x01	; 1
    3a34:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN6SX127x7setModeEh>
  RADIOLIB_ASSERT(state);
    3a38:	00 97       	sbiw	r24, 0x00	; 0
    3a3a:	31 f0       	breq	.+12     	; 0x3a48 <_ZN6SX127x10directModeEv+0x22>
  state = SX127x::setAFCAGCTrigger(RADIOLIB_SX127X_RX_TRIGGER_NONE);
  RADIOLIB_ASSERT(state);

  // set continuous mode
  return(this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_PACKET_CONFIG_2, RADIOLIB_SX127X_DATA_MODE_CONTINUOUS, 6, 6));
}
    3a3c:	df 91       	pop	r29
    3a3e:	cf 91       	pop	r28
    3a40:	0f 91       	pop	r16
    3a42:	ef 90       	pop	r14
    3a44:	cf 90       	pop	r12
    3a46:	08 95       	ret
  // set mode to standby
  int16_t state = setMode(RADIOLIB_SX127X_STANDBY);
  RADIOLIB_ASSERT(state);

  // set DIO mapping
  state = this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_DIO_MAPPING_1, RADIOLIB_SX127X_DIO1_CONT_DCLK | RADIOLIB_SX127X_DIO2_CONT_DATA, 5, 2);
    3a48:	cc 24       	eor	r12, r12
    3a4a:	ca 94       	dec	r12
    3a4c:	68 94       	set
    3a4e:	ee 24       	eor	r14, r14
    3a50:	e1 f8       	bld	r14, 1
    3a52:	02 e0       	ldi	r16, 0x02	; 2
    3a54:	25 e0       	ldi	r18, 0x05	; 5
    3a56:	40 e0       	ldi	r20, 0x00	; 0
    3a58:	60 e4       	ldi	r22, 0x40	; 64
    3a5a:	70 e0       	ldi	r23, 0x00	; 0
    3a5c:	fe 01       	movw	r30, r28
    3a5e:	e7 5e       	subi	r30, 0xE7	; 231
    3a60:	fe 4f       	sbci	r31, 0xFE	; 254
    3a62:	80 81       	ld	r24, Z
    3a64:	91 81       	ldd	r25, Z+1	; 0x01
    3a66:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
  RADIOLIB_ASSERT(state);
    3a6a:	00 97       	sbiw	r24, 0x00	; 0
    3a6c:	39 f7       	brne	.-50     	; 0x3a3c <_ZN6SX127x10directModeEv+0x16>

  // enable receiver startup without preamble or RSSI
  state = SX127x::setAFCAGCTrigger(RADIOLIB_SX127X_RX_TRIGGER_NONE);
    3a6e:	60 e0       	ldi	r22, 0x00	; 0
    3a70:	ce 01       	movw	r24, r28
    3a72:	0e 94 ed 1c 	call	0x39da	; 0x39da <_ZN6SX127x16setAFCAGCTriggerEh>
  RADIOLIB_ASSERT(state);
    3a76:	00 97       	sbiw	r24, 0x00	; 0
    3a78:	09 f7       	brne	.-62     	; 0x3a3c <_ZN6SX127x10directModeEv+0x16>

  // set continuous mode
  return(this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_PACKET_CONFIG_2, RADIOLIB_SX127X_DATA_MODE_CONTINUOUS, 6, 6));
    3a7a:	c7 5e       	subi	r28, 0xE7	; 231
    3a7c:	de 4f       	sbci	r29, 0xFE	; 254
    3a7e:	06 e0       	ldi	r16, 0x06	; 6
    3a80:	26 e0       	ldi	r18, 0x06	; 6
    3a82:	40 e0       	ldi	r20, 0x00	; 0
    3a84:	61 e3       	ldi	r22, 0x31	; 49
    3a86:	70 e0       	ldi	r23, 0x00	; 0
    3a88:	88 81       	ld	r24, Y
    3a8a:	99 81       	ldd	r25, Y+1	; 0x01
    3a8c:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    3a90:	d5 cf       	rjmp	.-86     	; 0x3a3c <_ZN6SX127x10directModeEv+0x16>

00003a92 <_ZN6SX127x21setFrequencyDeviationEf>:
    this->bitRate = br;
  }
  return(state);
}

int16_t SX127x::setFrequencyDeviation(float freqDev) {
    3a92:	4f 92       	push	r4
    3a94:	5f 92       	push	r5
    3a96:	6f 92       	push	r6
    3a98:	7f 92       	push	r7
    3a9a:	af 92       	push	r10
    3a9c:	bf 92       	push	r11
    3a9e:	cf 92       	push	r12
    3aa0:	df 92       	push	r13
    3aa2:	ef 92       	push	r14
    3aa4:	ff 92       	push	r15
    3aa6:	0f 93       	push	r16
    3aa8:	1f 93       	push	r17
    3aaa:	cf 93       	push	r28
    3aac:	df 93       	push	r29
    3aae:	ec 01       	movw	r28, r24
    3ab0:	c4 2e       	mov	r12, r20
    3ab2:	d5 2e       	mov	r13, r21
    3ab4:	a6 2e       	mov	r10, r22
    3ab6:	b7 2e       	mov	r11, r23
  // check active modem
  if(getActiveModem() != RADIOLIB_SX127X_FSK_OOK) {
    3ab8:	0e 94 ec 18 	call	0x31d8	; 0x31d8 <_ZN6SX127x14getActiveModemEv>
    3abc:	89 2b       	or	r24, r25
    3abe:	09 f0       	breq	.+2      	; 0x3ac2 <_ZN6SX127x21setFrequencyDeviationEf+0x30>
    3ac0:	8c c0       	rjmp	.+280    	; 0x3bda <_ZN6SX127x21setFrequencyDeviationEf+0x148>
    return(RADIOLIB_ERR_WRONG_MODEM);
  }

  // set frequency deviation to lowest available setting (required for digimodes)
  float newFreqDev = freqDev;
  if(freqDev < 0.0) {
    3ac2:	20 e0       	ldi	r18, 0x00	; 0
    3ac4:	30 e0       	ldi	r19, 0x00	; 0
    3ac6:	a9 01       	movw	r20, r18
    3ac8:	6c 2d       	mov	r22, r12
    3aca:	7d 2d       	mov	r23, r13
    3acc:	8a 2d       	mov	r24, r10
    3ace:	9b 2d       	mov	r25, r11
    3ad0:	0e 94 71 39 	call	0x72e2	; 0x72e2 <__cmpsf2>
    3ad4:	88 23       	and	r24, r24
    3ad6:	0c f4       	brge	.+2      	; 0x3ada <_ZN6SX127x21setFrequencyDeviationEf+0x48>
    3ad8:	42 c0       	rjmp	.+132    	; 0x3b5e <_ZN6SX127x21setFrequencyDeviationEf+0xcc>
  if(getActiveModem() != RADIOLIB_SX127X_FSK_OOK) {
    return(RADIOLIB_ERR_WRONG_MODEM);
  }

  // set frequency deviation to lowest available setting (required for digimodes)
  float newFreqDev = freqDev;
    3ada:	ec 2c       	mov	r14, r12
    3adc:	fd 2c       	mov	r15, r13
    3ade:	0a 2d       	mov	r16, r10
    3ae0:	1b 2d       	mov	r17, r11
  if(freqDev < 0.0) {
    newFreqDev = 0.6;
  }

  // check frequency deviation range
  if(!((newFreqDev + this->bitRate/2.0 <= 250.0) && (freqDev <= 200.0))) {
    3ae2:	fe 01       	movw	r30, r28
    3ae4:	eb 5d       	subi	r30, 0xDB	; 219
    3ae6:	fe 4f       	sbci	r31, 0xFE	; 254
    3ae8:	60 81       	ld	r22, Z
    3aea:	71 81       	ldd	r23, Z+1	; 0x01
    3aec:	82 81       	ldd	r24, Z+2	; 0x02
    3aee:	93 81       	ldd	r25, Z+3	; 0x03
    3af0:	20 e0       	ldi	r18, 0x00	; 0
    3af2:	30 e0       	ldi	r19, 0x00	; 0
    3af4:	40 e0       	ldi	r20, 0x00	; 0
    3af6:	5f e3       	ldi	r21, 0x3F	; 63
    3af8:	0e 94 d7 39 	call	0x73ae	; 0x73ae <__mulsf3>
    3afc:	2e 2d       	mov	r18, r14
    3afe:	3f 2d       	mov	r19, r15
    3b00:	40 2f       	mov	r20, r16
    3b02:	51 2f       	mov	r21, r17
    3b04:	0e 94 6c 3b 	call	0x76d8	; 0x76d8 <__addsf3>
    3b08:	20 e0       	ldi	r18, 0x00	; 0
    3b0a:	30 e0       	ldi	r19, 0x00	; 0
    3b0c:	4a e7       	ldi	r20, 0x7A	; 122
    3b0e:	53 e4       	ldi	r21, 0x43	; 67
    3b10:	0e 94 71 39 	call	0x72e2	; 0x72e2 <__cmpsf2>
    3b14:	18 16       	cp	r1, r24
    3b16:	0c f4       	brge	.+2      	; 0x3b1a <_ZN6SX127x21setFrequencyDeviationEf+0x88>
    3b18:	63 c0       	rjmp	.+198    	; 0x3be0 <_ZN6SX127x21setFrequencyDeviationEf+0x14e>
    3b1a:	20 e0       	ldi	r18, 0x00	; 0
    3b1c:	30 e0       	ldi	r19, 0x00	; 0
    3b1e:	48 e4       	ldi	r20, 0x48	; 72
    3b20:	53 e4       	ldi	r21, 0x43	; 67
    3b22:	6c 2d       	mov	r22, r12
    3b24:	7d 2d       	mov	r23, r13
    3b26:	8a 2d       	mov	r24, r10
    3b28:	9b 2d       	mov	r25, r11
    3b2a:	0e 94 71 39 	call	0x72e2	; 0x72e2 <__cmpsf2>
    3b2e:	18 16       	cp	r1, r24
    3b30:	0c f4       	brge	.+2      	; 0x3b34 <_ZN6SX127x21setFrequencyDeviationEf+0xa2>
    3b32:	59 c0       	rjmp	.+178    	; 0x3be6 <_ZN6SX127x21setFrequencyDeviationEf+0x154>
    return(RADIOLIB_ERR_INVALID_FREQUENCY_DEVIATION);
  }

  // set mode to STANDBY
  int16_t state = setMode(RADIOLIB_SX127X_STANDBY);
    3b34:	61 e0       	ldi	r22, 0x01	; 1
    3b36:	ce 01       	movw	r24, r28
    3b38:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN6SX127x7setModeEh>
  RADIOLIB_ASSERT(state);
    3b3c:	00 97       	sbiw	r24, 0x00	; 0
    3b3e:	d1 f0       	breq	.+52     	; 0x3b74 <_ZN6SX127x21setFrequencyDeviationEf+0xe2>
  uint32_t base = 1;
  uint32_t FDEV = (newFreqDev * (base << 19)) / 32000;
  state = this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_FDEV_MSB, (FDEV & 0xFF00) >> 8, 5, 0);
  state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_FDEV_LSB, FDEV & 0x00FF, 7, 0);
  return(state);
}
    3b40:	df 91       	pop	r29
    3b42:	cf 91       	pop	r28
    3b44:	1f 91       	pop	r17
    3b46:	0f 91       	pop	r16
    3b48:	ff 90       	pop	r15
    3b4a:	ef 90       	pop	r14
    3b4c:	df 90       	pop	r13
    3b4e:	cf 90       	pop	r12
    3b50:	bf 90       	pop	r11
    3b52:	af 90       	pop	r10
    3b54:	7f 90       	pop	r7
    3b56:	6f 90       	pop	r6
    3b58:	5f 90       	pop	r5
    3b5a:	4f 90       	pop	r4
    3b5c:	08 95       	ret
  }

  // set frequency deviation to lowest available setting (required for digimodes)
  float newFreqDev = freqDev;
  if(freqDev < 0.0) {
    newFreqDev = 0.6;
    3b5e:	0f 2e       	mov	r0, r31
    3b60:	fa e9       	ldi	r31, 0x9A	; 154
    3b62:	ef 2e       	mov	r14, r31
    3b64:	f0 2d       	mov	r31, r0
    3b66:	0f 2e       	mov	r0, r31
    3b68:	f9 e9       	ldi	r31, 0x99	; 153
    3b6a:	ff 2e       	mov	r15, r31
    3b6c:	f0 2d       	mov	r31, r0
    3b6e:	09 e1       	ldi	r16, 0x19	; 25
    3b70:	1f e3       	ldi	r17, 0x3F	; 63
    3b72:	b7 cf       	rjmp	.-146    	; 0x3ae2 <_ZN6SX127x21setFrequencyDeviationEf+0x50>
  int16_t state = setMode(RADIOLIB_SX127X_STANDBY);
  RADIOLIB_ASSERT(state);

  // set allowed frequency deviation
  uint32_t base = 1;
  uint32_t FDEV = (newFreqDev * (base << 19)) / 32000;
    3b74:	20 e0       	ldi	r18, 0x00	; 0
    3b76:	30 e0       	ldi	r19, 0x00	; 0
    3b78:	40 e0       	ldi	r20, 0x00	; 0
    3b7a:	59 e4       	ldi	r21, 0x49	; 73
    3b7c:	6e 2d       	mov	r22, r14
    3b7e:	7f 2d       	mov	r23, r15
    3b80:	80 2f       	mov	r24, r16
    3b82:	91 2f       	mov	r25, r17
    3b84:	0e 94 d7 39 	call	0x73ae	; 0x73ae <__mulsf3>
    3b88:	20 e0       	ldi	r18, 0x00	; 0
    3b8a:	30 e0       	ldi	r19, 0x00	; 0
    3b8c:	4a ef       	ldi	r20, 0xFA	; 250
    3b8e:	56 e4       	ldi	r21, 0x46	; 70
    3b90:	0e 94 ef 3b 	call	0x77de	; 0x77de <__divsf3>
    3b94:	0e 94 61 3c 	call	0x78c2	; 0x78c2 <__fixunssfsi>
    3b98:	2b 01       	movw	r4, r22
    3b9a:	3c 01       	movw	r6, r24
  state = this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_FDEV_MSB, (FDEV & 0xFF00) >> 8, 5, 0);
    3b9c:	c7 5e       	subi	r28, 0xE7	; 231
    3b9e:	de 4f       	sbci	r29, 0xFE	; 254
    3ba0:	77 27       	eor	r23, r23
    3ba2:	67 2d       	mov	r22, r7
    3ba4:	56 2d       	mov	r21, r6
    3ba6:	45 2d       	mov	r20, r5
    3ba8:	cc 24       	eor	r12, r12
    3baa:	ca 94       	dec	r12
    3bac:	68 94       	set
    3bae:	ee 24       	eor	r14, r14
    3bb0:	e1 f8       	bld	r14, 1
    3bb2:	00 e0       	ldi	r16, 0x00	; 0
    3bb4:	25 e0       	ldi	r18, 0x05	; 5
    3bb6:	64 e0       	ldi	r22, 0x04	; 4
    3bb8:	70 e0       	ldi	r23, 0x00	; 0
    3bba:	88 81       	ld	r24, Y
    3bbc:	99 81       	ldd	r25, Y+1	; 0x01
    3bbe:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    3bc2:	5c 01       	movw	r10, r24
  state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_FDEV_LSB, FDEV & 0x00FF, 7, 0);
    3bc4:	27 e0       	ldi	r18, 0x07	; 7
    3bc6:	44 2d       	mov	r20, r4
    3bc8:	65 e0       	ldi	r22, 0x05	; 5
    3bca:	70 e0       	ldi	r23, 0x00	; 0
    3bcc:	88 81       	ld	r24, Y
    3bce:	99 81       	ldd	r25, Y+1	; 0x01
    3bd0:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    3bd4:	8a 29       	or	r24, r10
    3bd6:	9b 29       	or	r25, r11
    3bd8:	b3 cf       	rjmp	.-154    	; 0x3b40 <_ZN6SX127x21setFrequencyDeviationEf+0xae>
}

int16_t SX127x::setFrequencyDeviation(float freqDev) {
  // check active modem
  if(getActiveModem() != RADIOLIB_SX127X_FSK_OOK) {
    return(RADIOLIB_ERR_WRONG_MODEM);
    3bda:	8c ee       	ldi	r24, 0xEC	; 236
    3bdc:	9f ef       	ldi	r25, 0xFF	; 255
    3bde:	b0 cf       	rjmp	.-160    	; 0x3b40 <_ZN6SX127x21setFrequencyDeviationEf+0xae>
    newFreqDev = 0.6;
  }

  // check frequency deviation range
  if(!((newFreqDev + this->bitRate/2.0 <= 250.0) && (freqDev <= 200.0))) {
    return(RADIOLIB_ERR_INVALID_FREQUENCY_DEVIATION);
    3be0:	8a e9       	ldi	r24, 0x9A	; 154
    3be2:	9f ef       	ldi	r25, 0xFF	; 255
    3be4:	ad cf       	rjmp	.-166    	; 0x3b40 <_ZN6SX127x21setFrequencyDeviationEf+0xae>
    3be6:	8a e9       	ldi	r24, 0x9A	; 154
    3be8:	9f ef       	ldi	r25, 0xFF	; 255
    3bea:	aa cf       	rjmp	.-172    	; 0x3b40 <_ZN6SX127x21setFrequencyDeviationEf+0xae>

00003bec <_ZN6SX127x16setBitRateCommonEfh>:

float SX127x::getDataRate() const {
  return(this->dataRate);
}

int16_t SX127x::setBitRateCommon(float br, uint8_t fracRegAddr) {
    3bec:	4f 92       	push	r4
    3bee:	5f 92       	push	r5
    3bf0:	6f 92       	push	r6
    3bf2:	7f 92       	push	r7
    3bf4:	8f 92       	push	r8
    3bf6:	9f 92       	push	r9
    3bf8:	af 92       	push	r10
    3bfa:	bf 92       	push	r11
    3bfc:	cf 92       	push	r12
    3bfe:	ef 92       	push	r14
    3c00:	0f 93       	push	r16
    3c02:	1f 93       	push	r17
    3c04:	cf 93       	push	r28
    3c06:	df 93       	push	r29
    3c08:	cd b7       	in	r28, 0x3d	; 61
    3c0a:	de b7       	in	r29, 0x3e	; 62
    3c0c:	2a 97       	sbiw	r28, 0x0a	; 10
    3c0e:	0f b6       	in	r0, 0x3f	; 63
    3c10:	f8 94       	cli
    3c12:	de bf       	out	0x3e, r29	; 62
    3c14:	0f be       	out	0x3f, r0	; 63
    3c16:	cd bf       	out	0x3d, r28	; 61
    3c18:	2c 01       	movw	r4, r24
    3c1a:	4a 01       	movw	r8, r20
    3c1c:	5b 01       	movw	r10, r22
    3c1e:	12 2f       	mov	r17, r18
  // check active modem
  if(getActiveModem() != RADIOLIB_SX127X_FSK_OOK) {
    3c20:	0e 94 ec 18 	call	0x31d8	; 0x31d8 <_ZN6SX127x14getActiveModemEv>
    3c24:	89 2b       	or	r24, r25
    3c26:	09 f0       	breq	.+2      	; 0x3c2a <_ZN6SX127x16setBitRateCommonEfh+0x3e>
    3c28:	c5 c0       	rjmp	.+394    	; 0x3db4 <_ZN6SX127x16setBitRateCommonEfh+0x1c8>
    return(RADIOLIB_ERR_WRONG_MODEM);
  }

  // check allowed bit rate
  // datasheet says 1.2 kbps should be the smallest possible, but 0.512 works fine
  if(ookEnabled) {
    3c2a:	f2 01       	movw	r30, r4
    3c2c:	e7 5d       	subi	r30, 0xD7	; 215
    3c2e:	fe 4f       	sbci	r31, 0xFE	; 254
    3c30:	80 81       	ld	r24, Z
    3c32:	88 23       	and	r24, r24
    3c34:	c9 f1       	breq	.+114    	; 0x3ca8 <_ZN6SX127x16setBitRateCommonEfh+0xbc>
    RADIOLIB_CHECK_RANGE(br, 0.5, 32.768002, RADIOLIB_ERR_INVALID_BIT_RATE);      // Found that 32.768 is 32.768002
    3c36:	20 e0       	ldi	r18, 0x00	; 0
    3c38:	30 e0       	ldi	r19, 0x00	; 0
    3c3a:	40 e0       	ldi	r20, 0x00	; 0
    3c3c:	5f e3       	ldi	r21, 0x3F	; 63
    3c3e:	c5 01       	movw	r24, r10
    3c40:	b4 01       	movw	r22, r8
    3c42:	0e 94 d1 3c 	call	0x79a2	; 0x79a2 <__gesf2>
    3c46:	88 23       	and	r24, r24
    3c48:	0c f4       	brge	.+2      	; 0x3c4c <_ZN6SX127x16setBitRateCommonEfh+0x60>
    3c4a:	bb c0       	rjmp	.+374    	; 0x3dc2 <_ZN6SX127x16setBitRateCommonEfh+0x1d6>
    3c4c:	2f e6       	ldi	r18, 0x6F	; 111
    3c4e:	32 e1       	ldi	r19, 0x12	; 18
    3c50:	43 e0       	ldi	r20, 0x03	; 3
    3c52:	52 e4       	ldi	r21, 0x42	; 66
    3c54:	c5 01       	movw	r24, r10
    3c56:	b4 01       	movw	r22, r8
    3c58:	0e 94 71 39 	call	0x72e2	; 0x72e2 <__cmpsf2>
    3c5c:	18 16       	cp	r1, r24
    3c5e:	ec f0       	brlt	.+58     	; 0x3c9a <_ZN6SX127x16setBitRateCommonEfh+0xae>
  } else {
    RADIOLIB_CHECK_RANGE(br, 0.5, 300.0, RADIOLIB_ERR_INVALID_BIT_RATE);
  }

  // set mode to STANDBY
  int16_t state = setMode(RADIOLIB_SX127X_STANDBY);
    3c60:	61 e0       	ldi	r22, 0x01	; 1
    3c62:	c2 01       	movw	r24, r4
    3c64:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN6SX127x7setModeEh>
    3c68:	3c 01       	movw	r6, r24
  RADIOLIB_ASSERT(state);
    3c6a:	89 2b       	or	r24, r25
    3c6c:	c9 f1       	breq	.+114    	; 0x3ce0 <_ZN6SX127x16setBitRateCommonEfh+0xf4>

  if(state == RADIOLIB_ERR_NONE) {
    this->bitRate = br;
  }
  return(state);
}
    3c6e:	c3 01       	movw	r24, r6
    3c70:	2a 96       	adiw	r28, 0x0a	; 10
    3c72:	0f b6       	in	r0, 0x3f	; 63
    3c74:	f8 94       	cli
    3c76:	de bf       	out	0x3e, r29	; 62
    3c78:	0f be       	out	0x3f, r0	; 63
    3c7a:	cd bf       	out	0x3d, r28	; 61
    3c7c:	df 91       	pop	r29
    3c7e:	cf 91       	pop	r28
    3c80:	1f 91       	pop	r17
    3c82:	0f 91       	pop	r16
    3c84:	ef 90       	pop	r14
    3c86:	cf 90       	pop	r12
    3c88:	bf 90       	pop	r11
    3c8a:	af 90       	pop	r10
    3c8c:	9f 90       	pop	r9
    3c8e:	8f 90       	pop	r8
    3c90:	7f 90       	pop	r7
    3c92:	6f 90       	pop	r6
    3c94:	5f 90       	pop	r5
    3c96:	4f 90       	pop	r4
    3c98:	08 95       	ret
  }

  // check allowed bit rate
  // datasheet says 1.2 kbps should be the smallest possible, but 0.512 works fine
  if(ookEnabled) {
    RADIOLIB_CHECK_RANGE(br, 0.5, 32.768002, RADIOLIB_ERR_INVALID_BIT_RATE);      // Found that 32.768 is 32.768002
    3c9a:	0f 2e       	mov	r0, r31
    3c9c:	fb e9       	ldi	r31, 0x9B	; 155
    3c9e:	6f 2e       	mov	r6, r31
    3ca0:	77 24       	eor	r7, r7
    3ca2:	7a 94       	dec	r7
    3ca4:	f0 2d       	mov	r31, r0
    3ca6:	e3 cf       	rjmp	.-58     	; 0x3c6e <_ZN6SX127x16setBitRateCommonEfh+0x82>
  } else {
    RADIOLIB_CHECK_RANGE(br, 0.5, 300.0, RADIOLIB_ERR_INVALID_BIT_RATE);
    3ca8:	20 e0       	ldi	r18, 0x00	; 0
    3caa:	30 e0       	ldi	r19, 0x00	; 0
    3cac:	40 e0       	ldi	r20, 0x00	; 0
    3cae:	5f e3       	ldi	r21, 0x3F	; 63
    3cb0:	c5 01       	movw	r24, r10
    3cb2:	b4 01       	movw	r22, r8
    3cb4:	0e 94 d1 3c 	call	0x79a2	; 0x79a2 <__gesf2>
    3cb8:	88 23       	and	r24, r24
    3cba:	0c f4       	brge	.+2      	; 0x3cbe <_ZN6SX127x16setBitRateCommonEfh+0xd2>
    3cbc:	89 c0       	rjmp	.+274    	; 0x3dd0 <_ZN6SX127x16setBitRateCommonEfh+0x1e4>
    3cbe:	20 e0       	ldi	r18, 0x00	; 0
    3cc0:	30 e0       	ldi	r19, 0x00	; 0
    3cc2:	46 e9       	ldi	r20, 0x96	; 150
    3cc4:	53 e4       	ldi	r21, 0x43	; 67
    3cc6:	c5 01       	movw	r24, r10
    3cc8:	b4 01       	movw	r22, r8
    3cca:	0e 94 71 39 	call	0x72e2	; 0x72e2 <__cmpsf2>
    3cce:	18 16       	cp	r1, r24
    3cd0:	3c f6       	brge	.-114    	; 0x3c60 <_ZN6SX127x16setBitRateCommonEfh+0x74>
    3cd2:	0f 2e       	mov	r0, r31
    3cd4:	fb e9       	ldi	r31, 0x9B	; 155
    3cd6:	6f 2e       	mov	r6, r31
    3cd8:	77 24       	eor	r7, r7
    3cda:	7a 94       	dec	r7
    3cdc:	f0 2d       	mov	r31, r0
    3cde:	c7 cf       	rjmp	.-114    	; 0x3c6e <_ZN6SX127x16setBitRateCommonEfh+0x82>
  // set mode to STANDBY
  int16_t state = setMode(RADIOLIB_SX127X_STANDBY);
  RADIOLIB_ASSERT(state);

  // set bit rate
  uint16_t bitRate = (RADIOLIB_SX127X_CRYSTAL_FREQ * 1000.0) / br;
    3ce0:	a5 01       	movw	r20, r10
    3ce2:	94 01       	movw	r18, r8
    3ce4:	60 e0       	ldi	r22, 0x00	; 0
    3ce6:	70 e0       	ldi	r23, 0x00	; 0
    3ce8:	8a ef       	ldi	r24, 0xFA	; 250
    3cea:	96 e4       	ldi	r25, 0x46	; 70
    3cec:	0e 94 ef 3b 	call	0x77de	; 0x77de <__divsf3>
    3cf0:	6d 83       	std	Y+5, r22	; 0x05
    3cf2:	7e 83       	std	Y+6, r23	; 0x06
    3cf4:	8f 83       	std	Y+7, r24	; 0x07
    3cf6:	98 87       	std	Y+8, r25	; 0x08
    3cf8:	0e 94 61 3c 	call	0x78c2	; 0x78c2 <__fixunssfsi>
    3cfc:	69 83       	std	Y+1, r22	; 0x01
    3cfe:	7a 83       	std	Y+2, r23	; 0x02
    3d00:	8b 83       	std	Y+3, r24	; 0x03
    3d02:	9c 83       	std	Y+4, r25	; 0x04
  state = this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_BITRATE_MSB, (bitRate & 0xFF00) >> 8, 7, 0);
    3d04:	cc 24       	eor	r12, r12
    3d06:	ca 94       	dec	r12
    3d08:	68 94       	set
    3d0a:	ee 24       	eor	r14, r14
    3d0c:	e1 f8       	bld	r14, 1
    3d0e:	00 e0       	ldi	r16, 0x00	; 0
    3d10:	27 e0       	ldi	r18, 0x07	; 7
    3d12:	4a 81       	ldd	r20, Y+2	; 0x02
    3d14:	62 e0       	ldi	r22, 0x02	; 2
    3d16:	70 e0       	ldi	r23, 0x00	; 0
    3d18:	c2 01       	movw	r24, r4
    3d1a:	87 5e       	subi	r24, 0xE7	; 231
    3d1c:	9e 4f       	sbci	r25, 0xFE	; 254
    3d1e:	9a 87       	std	Y+10, r25	; 0x0a
    3d20:	89 87       	std	Y+9, r24	; 0x09
    3d22:	fc 01       	movw	r30, r24
    3d24:	80 81       	ld	r24, Z
    3d26:	91 81       	ldd	r25, Z+1	; 0x01
    3d28:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    3d2c:	3c 01       	movw	r6, r24
  state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_BITRATE_LSB, bitRate & 0x00FF, 7, 0);
    3d2e:	27 e0       	ldi	r18, 0x07	; 7
    3d30:	49 81       	ldd	r20, Y+1	; 0x01
    3d32:	63 e0       	ldi	r22, 0x03	; 3
    3d34:	70 e0       	ldi	r23, 0x00	; 0
    3d36:	e9 85       	ldd	r30, Y+9	; 0x09
    3d38:	fa 85       	ldd	r31, Y+10	; 0x0a
    3d3a:	80 81       	ld	r24, Z
    3d3c:	91 81       	ldd	r25, Z+1	; 0x01
    3d3e:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    3d42:	68 2a       	or	r6, r24
    3d44:	79 2a       	or	r7, r25

  // set fractional part of bit rate
  if(!ookEnabled) {
    3d46:	f2 01       	movw	r30, r4
    3d48:	e7 5d       	subi	r30, 0xD7	; 215
    3d4a:	fe 4f       	sbci	r31, 0xFE	; 254
    3d4c:	80 81       	ld	r24, Z
    3d4e:	88 23       	and	r24, r24
    3d50:	61 f0       	breq	.+24     	; 0x3d6a <_ZN6SX127x16setBitRateCommonEfh+0x17e>
    float bitRateRem = ((RADIOLIB_SX127X_CRYSTAL_FREQ * 1000.0) / (float)br) - (float)bitRate;
    uint8_t bitRateFrac = bitRateRem * 16;
    state |= this->mod->SPIsetRegValue(fracRegAddr, bitRateFrac, 7, 0);
  }

  if(state == RADIOLIB_ERR_NONE) {
    3d52:	61 14       	cp	r6, r1
    3d54:	71 04       	cpc	r7, r1
    3d56:	09 f0       	breq	.+2      	; 0x3d5a <_ZN6SX127x16setBitRateCommonEfh+0x16e>
    3d58:	8a cf       	rjmp	.-236    	; 0x3c6e <_ZN6SX127x16setBitRateCommonEfh+0x82>
    this->bitRate = br;
    3d5a:	f2 01       	movw	r30, r4
    3d5c:	eb 5d       	subi	r30, 0xDB	; 219
    3d5e:	fe 4f       	sbci	r31, 0xFE	; 254
    3d60:	80 82       	st	Z, r8
    3d62:	91 82       	std	Z+1, r9	; 0x01
    3d64:	a2 82       	std	Z+2, r10	; 0x02
    3d66:	b3 82       	std	Z+3, r11	; 0x03
    3d68:	82 cf       	rjmp	.-252    	; 0x3c6e <_ZN6SX127x16setBitRateCommonEfh+0x82>
  state = this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_BITRATE_MSB, (bitRate & 0xFF00) >> 8, 7, 0);
  state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_BITRATE_LSB, bitRate & 0x00FF, 7, 0);

  // set fractional part of bit rate
  if(!ookEnabled) {
    float bitRateRem = ((RADIOLIB_SX127X_CRYSTAL_FREQ * 1000.0) / (float)br) - (float)bitRate;
    3d6a:	29 81       	ldd	r18, Y+1	; 0x01
    3d6c:	3a 81       	ldd	r19, Y+2	; 0x02
    3d6e:	b9 01       	movw	r22, r18
    3d70:	90 e0       	ldi	r25, 0x00	; 0
    3d72:	80 e0       	ldi	r24, 0x00	; 0
    3d74:	0e 94 76 39 	call	0x72ec	; 0x72ec <__floatunsisf>
    3d78:	9b 01       	movw	r18, r22
    3d7a:	ac 01       	movw	r20, r24
    3d7c:	6d 81       	ldd	r22, Y+5	; 0x05
    3d7e:	7e 81       	ldd	r23, Y+6	; 0x06
    3d80:	8f 81       	ldd	r24, Y+7	; 0x07
    3d82:	98 85       	ldd	r25, Y+8	; 0x08
    3d84:	0e 94 6b 3b 	call	0x76d6	; 0x76d6 <__subsf3>
    uint8_t bitRateFrac = bitRateRem * 16;
    3d88:	20 e0       	ldi	r18, 0x00	; 0
    3d8a:	30 e0       	ldi	r19, 0x00	; 0
    3d8c:	40 e8       	ldi	r20, 0x80	; 128
    3d8e:	51 e4       	ldi	r21, 0x41	; 65
    3d90:	0e 94 d7 39 	call	0x73ae	; 0x73ae <__mulsf3>
    3d94:	0e 94 61 3c 	call	0x78c2	; 0x78c2 <__fixunssfsi>
    3d98:	46 2f       	mov	r20, r22
    state |= this->mod->SPIsetRegValue(fracRegAddr, bitRateFrac, 7, 0);
    3d9a:	61 2f       	mov	r22, r17
    3d9c:	70 e0       	ldi	r23, 0x00	; 0
    3d9e:	27 e0       	ldi	r18, 0x07	; 7
    3da0:	f2 01       	movw	r30, r4
    3da2:	e7 5e       	subi	r30, 0xE7	; 231
    3da4:	fe 4f       	sbci	r31, 0xFE	; 254
    3da6:	80 81       	ld	r24, Z
    3da8:	91 81       	ldd	r25, Z+1	; 0x01
    3daa:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    3dae:	68 2a       	or	r6, r24
    3db0:	79 2a       	or	r7, r25
    3db2:	cf cf       	rjmp	.-98     	; 0x3d52 <_ZN6SX127x16setBitRateCommonEfh+0x166>
}

int16_t SX127x::setBitRateCommon(float br, uint8_t fracRegAddr) {
  // check active modem
  if(getActiveModem() != RADIOLIB_SX127X_FSK_OOK) {
    return(RADIOLIB_ERR_WRONG_MODEM);
    3db4:	0f 2e       	mov	r0, r31
    3db6:	fc ee       	ldi	r31, 0xEC	; 236
    3db8:	6f 2e       	mov	r6, r31
    3dba:	77 24       	eor	r7, r7
    3dbc:	7a 94       	dec	r7
    3dbe:	f0 2d       	mov	r31, r0
    3dc0:	56 cf       	rjmp	.-340    	; 0x3c6e <_ZN6SX127x16setBitRateCommonEfh+0x82>
  }

  // check allowed bit rate
  // datasheet says 1.2 kbps should be the smallest possible, but 0.512 works fine
  if(ookEnabled) {
    RADIOLIB_CHECK_RANGE(br, 0.5, 32.768002, RADIOLIB_ERR_INVALID_BIT_RATE);      // Found that 32.768 is 32.768002
    3dc2:	0f 2e       	mov	r0, r31
    3dc4:	fb e9       	ldi	r31, 0x9B	; 155
    3dc6:	6f 2e       	mov	r6, r31
    3dc8:	77 24       	eor	r7, r7
    3dca:	7a 94       	dec	r7
    3dcc:	f0 2d       	mov	r31, r0
    3dce:	4f cf       	rjmp	.-354    	; 0x3c6e <_ZN6SX127x16setBitRateCommonEfh+0x82>
  } else {
    RADIOLIB_CHECK_RANGE(br, 0.5, 300.0, RADIOLIB_ERR_INVALID_BIT_RATE);
    3dd0:	0f 2e       	mov	r0, r31
    3dd2:	fb e9       	ldi	r31, 0x9B	; 155
    3dd4:	6f 2e       	mov	r6, r31
    3dd6:	77 24       	eor	r7, r7
    3dd8:	7a 94       	dec	r7
    3dda:	f0 2d       	mov	r31, r0
    3ddc:	48 cf       	rjmp	.-368    	; 0x3c6e <_ZN6SX127x16setBitRateCommonEfh+0x82>

00003dde <_ZN6SX127810setBitRateEf>:
  }
  return(state);
}

int16_t SX1278::setBitRate(float br) {
  return(SX127x::setBitRateCommon(br, RADIOLIB_SX1278_REG_BIT_RATE_FRAC));
    3dde:	2d e5       	ldi	r18, 0x5D	; 93
    3de0:	0e 94 f6 1d 	call	0x3bec	; 0x3bec <_ZN6SX127x16setBitRateCommonEfh>
}
    3de4:	08 95       	ret

00003de6 <_ZN6SX127x17setPreambleLengthEj>:
    state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_OCP, RADIOLIB_SX127X_OCP_ON | raw, 5, 0);
  }
  return(state);
}

int16_t SX127x::setPreambleLength(size_t preambleLength) {
    3de6:	8f 92       	push	r8
    3de8:	9f 92       	push	r9
    3dea:	af 92       	push	r10
    3dec:	bf 92       	push	r11
    3dee:	cf 92       	push	r12
    3df0:	ef 92       	push	r14
    3df2:	0f 93       	push	r16
    3df4:	cf 93       	push	r28
    3df6:	df 93       	push	r29
    3df8:	ec 01       	movw	r28, r24
    3dfa:	4b 01       	movw	r8, r22
  // set mode to standby
  int16_t state = setMode(RADIOLIB_SX127X_STANDBY);
    3dfc:	61 e0       	ldi	r22, 0x01	; 1
    3dfe:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN6SX127x7setModeEh>
  RADIOLIB_ASSERT(state);
    3e02:	00 97       	sbiw	r24, 0x00	; 0
    3e04:	51 f0       	breq	.+20     	; 0x3e1a <_ZN6SX127x17setPreambleLengthEj+0x34>
    state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_PREAMBLE_LSB_FSK, (uint8_t)(numBytes & 0xFF));
    return(state);
  }

  return(RADIOLIB_ERR_UNKNOWN);
}
    3e06:	df 91       	pop	r29
    3e08:	cf 91       	pop	r28
    3e0a:	0f 91       	pop	r16
    3e0c:	ef 90       	pop	r14
    3e0e:	cf 90       	pop	r12
    3e10:	bf 90       	pop	r11
    3e12:	af 90       	pop	r10
    3e14:	9f 90       	pop	r9
    3e16:	8f 90       	pop	r8
    3e18:	08 95       	ret
  // set mode to standby
  int16_t state = setMode(RADIOLIB_SX127X_STANDBY);
  RADIOLIB_ASSERT(state);

  // check active modem
  uint8_t modem = getActiveModem();
    3e1a:	ce 01       	movw	r24, r28
    3e1c:	0e 94 ec 18 	call	0x31d8	; 0x31d8 <_ZN6SX127x14getActiveModemEv>
  if(modem == RADIOLIB_SX127X_LORA) {
    3e20:	80 38       	cpi	r24, 0x80	; 128
    3e22:	21 f1       	breq	.+72     	; 0x3e6c <_ZN6SX127x17setPreambleLengthEj+0x86>
    // set preamble length
    state = this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_PREAMBLE_MSB, (uint8_t)((preambleLength >> 8) & 0xFF));
    state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_PREAMBLE_LSB, (uint8_t)(preambleLength & 0xFF));
    return(state);

  } else if(modem == RADIOLIB_SX127X_FSK_OOK) {
    3e24:	81 11       	cpse	r24, r1
    3e26:	45 c0       	rjmp	.+138    	; 0x3eb2 <_ZN6SX127x17setPreambleLengthEj+0xcc>
    // set preamble length (in bytes)
    uint16_t numBytes = preambleLength / 8;
    3e28:	96 94       	lsr	r9
    3e2a:	87 94       	ror	r8
    3e2c:	96 94       	lsr	r9
    3e2e:	87 94       	ror	r8
    3e30:	96 94       	lsr	r9
    3e32:	87 94       	ror	r8
    state = this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_PREAMBLE_MSB_FSK, (uint8_t)((numBytes >> 8) & 0xFF));
    3e34:	c7 5e       	subi	r28, 0xE7	; 231
    3e36:	de 4f       	sbci	r29, 0xFE	; 254
    3e38:	cc 24       	eor	r12, r12
    3e3a:	ca 94       	dec	r12
    3e3c:	68 94       	set
    3e3e:	ee 24       	eor	r14, r14
    3e40:	e1 f8       	bld	r14, 1
    3e42:	00 e0       	ldi	r16, 0x00	; 0
    3e44:	27 e0       	ldi	r18, 0x07	; 7
    3e46:	49 2d       	mov	r20, r9
    3e48:	65 e2       	ldi	r22, 0x25	; 37
    3e4a:	70 e0       	ldi	r23, 0x00	; 0
    3e4c:	88 81       	ld	r24, Y
    3e4e:	99 81       	ldd	r25, Y+1	; 0x01
    3e50:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    3e54:	5c 01       	movw	r10, r24
    state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_PREAMBLE_LSB_FSK, (uint8_t)(numBytes & 0xFF));
    3e56:	27 e0       	ldi	r18, 0x07	; 7
    3e58:	48 2d       	mov	r20, r8
    3e5a:	66 e2       	ldi	r22, 0x26	; 38
    3e5c:	70 e0       	ldi	r23, 0x00	; 0
    3e5e:	88 81       	ld	r24, Y
    3e60:	99 81       	ldd	r25, Y+1	; 0x01
    3e62:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    3e66:	8a 29       	or	r24, r10
    3e68:	9b 29       	or	r25, r11
    3e6a:	cd cf       	rjmp	.-102    	; 0x3e06 <_ZN6SX127x17setPreambleLengthEj+0x20>

  // check active modem
  uint8_t modem = getActiveModem();
  if(modem == RADIOLIB_SX127X_LORA) {
    // check allowed range
    if(preambleLength < 6) {
    3e6c:	86 e0       	ldi	r24, 0x06	; 6
    3e6e:	88 16       	cp	r8, r24
    3e70:	91 04       	cpc	r9, r1
    3e72:	e0 f0       	brcs	.+56     	; 0x3eac <_ZN6SX127x17setPreambleLengthEj+0xc6>
      return(RADIOLIB_ERR_INVALID_PREAMBLE_LENGTH);
    }

    // set preamble length
    state = this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_PREAMBLE_MSB, (uint8_t)((preambleLength >> 8) & 0xFF));
    3e74:	c7 5e       	subi	r28, 0xE7	; 231
    3e76:	de 4f       	sbci	r29, 0xFE	; 254
    3e78:	cc 24       	eor	r12, r12
    3e7a:	ca 94       	dec	r12
    3e7c:	68 94       	set
    3e7e:	ee 24       	eor	r14, r14
    3e80:	e1 f8       	bld	r14, 1
    3e82:	00 e0       	ldi	r16, 0x00	; 0
    3e84:	27 e0       	ldi	r18, 0x07	; 7
    3e86:	49 2d       	mov	r20, r9
    3e88:	60 e2       	ldi	r22, 0x20	; 32
    3e8a:	70 e0       	ldi	r23, 0x00	; 0
    3e8c:	88 81       	ld	r24, Y
    3e8e:	99 81       	ldd	r25, Y+1	; 0x01
    3e90:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    3e94:	5c 01       	movw	r10, r24
    state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_PREAMBLE_LSB, (uint8_t)(preambleLength & 0xFF));
    3e96:	27 e0       	ldi	r18, 0x07	; 7
    3e98:	48 2d       	mov	r20, r8
    3e9a:	61 e2       	ldi	r22, 0x21	; 33
    3e9c:	70 e0       	ldi	r23, 0x00	; 0
    3e9e:	88 81       	ld	r24, Y
    3ea0:	99 81       	ldd	r25, Y+1	; 0x01
    3ea2:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    3ea6:	8a 29       	or	r24, r10
    3ea8:	9b 29       	or	r25, r11
    3eaa:	ad cf       	rjmp	.-166    	; 0x3e06 <_ZN6SX127x17setPreambleLengthEj+0x20>
  // check active modem
  uint8_t modem = getActiveModem();
  if(modem == RADIOLIB_SX127X_LORA) {
    // check allowed range
    if(preambleLength < 6) {
      return(RADIOLIB_ERR_INVALID_PREAMBLE_LENGTH);
    3eac:	8e ee       	ldi	r24, 0xEE	; 238
    3eae:	9f ef       	ldi	r25, 0xFF	; 255
    3eb0:	aa cf       	rjmp	.-172    	; 0x3e06 <_ZN6SX127x17setPreambleLengthEj+0x20>
    state = this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_PREAMBLE_MSB_FSK, (uint8_t)((numBytes >> 8) & 0xFF));
    state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_PREAMBLE_LSB_FSK, (uint8_t)(numBytes & 0xFF));
    return(state);
  }

  return(RADIOLIB_ERR_UNKNOWN);
    3eb2:	8f ef       	ldi	r24, 0xFF	; 255
    3eb4:	9f ef       	ldi	r25, 0xFF	; 255
    3eb6:	a7 cf       	rjmp	.-178    	; 0x3e06 <_ZN6SX127x17setPreambleLengthEj+0x20>

00003eb8 <_ZN6SX127x11setSyncWordEh>:
    return(RADIOLIB_PREAMBLE_DETECTED);
  }
  return(RADIOLIB_CHANNEL_FREE);
}

int16_t SX127x::setSyncWord(uint8_t syncWord) {
    3eb8:	cf 92       	push	r12
    3eba:	ef 92       	push	r14
    3ebc:	0f 93       	push	r16
    3ebe:	1f 93       	push	r17
    3ec0:	cf 93       	push	r28
    3ec2:	df 93       	push	r29
    3ec4:	ec 01       	movw	r28, r24
    3ec6:	16 2f       	mov	r17, r22
  // check active modem
  if(getActiveModem() != RADIOLIB_SX127X_LORA) {
    3ec8:	0e 94 ec 18 	call	0x31d8	; 0x31d8 <_ZN6SX127x14getActiveModemEv>
    3ecc:	80 38       	cpi	r24, 0x80	; 128
    3ece:	91 05       	cpc	r25, r1
    3ed0:	d9 f4       	brne	.+54     	; 0x3f08 <_ZN6SX127x11setSyncWordEh+0x50>
    return(RADIOLIB_ERR_WRONG_MODEM);
  }

  // set mode to standby
  setMode(RADIOLIB_SX127X_STANDBY);
    3ed2:	61 e0       	ldi	r22, 0x01	; 1
    3ed4:	ce 01       	movw	r24, r28
    3ed6:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN6SX127x7setModeEh>

  // write register
  return(this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_SYNC_WORD, syncWord));
    3eda:	c7 5e       	subi	r28, 0xE7	; 231
    3edc:	de 4f       	sbci	r29, 0xFE	; 254
    3ede:	cc 24       	eor	r12, r12
    3ee0:	ca 94       	dec	r12
    3ee2:	68 94       	set
    3ee4:	ee 24       	eor	r14, r14
    3ee6:	e1 f8       	bld	r14, 1
    3ee8:	00 e0       	ldi	r16, 0x00	; 0
    3eea:	27 e0       	ldi	r18, 0x07	; 7
    3eec:	41 2f       	mov	r20, r17
    3eee:	69 e3       	ldi	r22, 0x39	; 57
    3ef0:	70 e0       	ldi	r23, 0x00	; 0
    3ef2:	88 81       	ld	r24, Y
    3ef4:	99 81       	ldd	r25, Y+1	; 0x01
    3ef6:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
}
    3efa:	df 91       	pop	r29
    3efc:	cf 91       	pop	r28
    3efe:	1f 91       	pop	r17
    3f00:	0f 91       	pop	r16
    3f02:	ef 90       	pop	r14
    3f04:	cf 90       	pop	r12
    3f06:	08 95       	ret
}

int16_t SX127x::setSyncWord(uint8_t syncWord) {
  // check active modem
  if(getActiveModem() != RADIOLIB_SX127X_LORA) {
    return(RADIOLIB_ERR_WRONG_MODEM);
    3f08:	8c ee       	ldi	r24, 0xEC	; 236
    3f0a:	9f ef       	ldi	r25, 0xFF	; 255
    3f0c:	f6 cf       	rjmp	.-20     	; 0x3efa <_ZN6SX127x11setSyncWordEh+0x42>

00003f0e <_ZN6SX127x11setSyncWordEPhj>:

  //set AFC&AGC trigger
  return(this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_RX_CONFIG, trigger, 2, 0));
}

int16_t SX127x::setSyncWord(uint8_t* syncWord, size_t len) {
    3f0e:	4f 92       	push	r4
    3f10:	5f 92       	push	r5
    3f12:	6f 92       	push	r6
    3f14:	7f 92       	push	r7
    3f16:	8f 92       	push	r8
    3f18:	9f 92       	push	r9
    3f1a:	af 92       	push	r10
    3f1c:	bf 92       	push	r11
    3f1e:	cf 92       	push	r12
    3f20:	ef 92       	push	r14
    3f22:	0f 93       	push	r16
    3f24:	1f 93       	push	r17
    3f26:	cf 93       	push	r28
    3f28:	df 93       	push	r29
    3f2a:	4c 01       	movw	r8, r24
    3f2c:	5b 01       	movw	r10, r22
    3f2e:	ea 01       	movw	r28, r20
  // check active modem
  uint8_t modem = getActiveModem();
    3f30:	0e 94 ec 18 	call	0x31d8	; 0x31d8 <_ZN6SX127x14getActiveModemEv>
  if(modem == RADIOLIB_SX127X_FSK_OOK) {
    3f34:	81 11       	cpse	r24, r1
    3f36:	43 c0       	rjmp	.+134    	; 0x3fbe <_ZN6SX127x11setSyncWordEPhj+0xb0>
    RADIOLIB_CHECK_RANGE(len, 1, 8, RADIOLIB_ERR_INVALID_SYNC_WORD);
    3f38:	ce 01       	movw	r24, r28
    3f3a:	01 97       	sbiw	r24, 0x01	; 1
    3f3c:	08 97       	sbiw	r24, 0x08	; 8
    3f3e:	08 f0       	brcs	.+2      	; 0x3f42 <_ZN6SX127x11setSyncWordEPhj+0x34>
    3f40:	58 c0       	rjmp	.+176    	; 0x3ff2 <_ZN6SX127x11setSyncWordEPhj+0xe4>

    // sync word must not contain value 0x00
    for(size_t i = 0; i < len; i++) {
    3f42:	90 e0       	ldi	r25, 0x00	; 0
    3f44:	80 e0       	ldi	r24, 0x00	; 0
    3f46:	8c 17       	cp	r24, r28
    3f48:	9d 07       	cpc	r25, r29
    3f4a:	48 f4       	brcc	.+18     	; 0x3f5e <_ZN6SX127x11setSyncWordEPhj+0x50>
      if(syncWord[i] == 0x00) {
    3f4c:	f5 01       	movw	r30, r10
    3f4e:	e8 0f       	add	r30, r24
    3f50:	f9 1f       	adc	r31, r25
    3f52:	20 81       	ld	r18, Z
    3f54:	22 23       	and	r18, r18
    3f56:	09 f4       	brne	.+2      	; 0x3f5a <_ZN6SX127x11setSyncWordEPhj+0x4c>
    3f58:	4f c0       	rjmp	.+158    	; 0x3ff8 <_ZN6SX127x11setSyncWordEPhj+0xea>
  uint8_t modem = getActiveModem();
  if(modem == RADIOLIB_SX127X_FSK_OOK) {
    RADIOLIB_CHECK_RANGE(len, 1, 8, RADIOLIB_ERR_INVALID_SYNC_WORD);

    // sync word must not contain value 0x00
    for(size_t i = 0; i < len; i++) {
    3f5a:	01 96       	adiw	r24, 0x01	; 1
    3f5c:	f4 cf       	rjmp	.-24     	; 0x3f46 <_ZN6SX127x11setSyncWordEPhj+0x38>
        return(RADIOLIB_ERR_INVALID_SYNC_WORD);
      }
    }

    // enable sync word recognition
    int16_t state = this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_SYNC_CONFIG, RADIOLIB_SX127X_SYNC_ON, 4, 4);
    3f5e:	cc 24       	eor	r12, r12
    3f60:	ca 94       	dec	r12
    3f62:	68 94       	set
    3f64:	ee 24       	eor	r14, r14
    3f66:	e1 f8       	bld	r14, 1
    3f68:	04 e0       	ldi	r16, 0x04	; 4
    3f6a:	24 e0       	ldi	r18, 0x04	; 4
    3f6c:	40 e1       	ldi	r20, 0x10	; 16
    3f6e:	67 e2       	ldi	r22, 0x27	; 39
    3f70:	70 e0       	ldi	r23, 0x00	; 0
    3f72:	24 01       	movw	r4, r8
    3f74:	87 ee       	ldi	r24, 0xE7	; 231
    3f76:	48 1a       	sub	r4, r24
    3f78:	8e ef       	ldi	r24, 0xFE	; 254
    3f7a:	58 0a       	sbc	r5, r24
    3f7c:	f2 01       	movw	r30, r4
    3f7e:	80 81       	ld	r24, Z
    3f80:	91 81       	ldd	r25, Z+1	; 0x01
    3f82:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    3f86:	3c 01       	movw	r6, r24
    state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_SYNC_CONFIG, len - 1, 2, 0);
    3f88:	00 e0       	ldi	r16, 0x00	; 0
    3f8a:	22 e0       	ldi	r18, 0x02	; 2
    3f8c:	4c 2f       	mov	r20, r28
    3f8e:	41 50       	subi	r20, 0x01	; 1
    3f90:	67 e2       	ldi	r22, 0x27	; 39
    3f92:	70 e0       	ldi	r23, 0x00	; 0
    3f94:	f2 01       	movw	r30, r4
    3f96:	80 81       	ld	r24, Z
    3f98:	91 81       	ldd	r25, Z+1	; 0x01
    3f9a:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    3f9e:	83 01       	movw	r16, r6
    3fa0:	08 2b       	or	r16, r24
    3fa2:	19 2b       	or	r17, r25
    RADIOLIB_ASSERT(state);
    3fa4:	01 15       	cp	r16, r1
    3fa6:	11 05       	cpc	r17, r1
    3fa8:	a1 f4       	brne	.+40     	; 0x3fd2 <_ZN6SX127x11setSyncWordEPhj+0xc4>

    // set sync word
    this->mod->SPIwriteRegisterBurst(RADIOLIB_SX127X_REG_SYNC_VALUE_1, syncWord, len);
    3faa:	f2 01       	movw	r30, r4
    3fac:	9e 01       	movw	r18, r28
    3fae:	a5 01       	movw	r20, r10
    3fb0:	68 e2       	ldi	r22, 0x28	; 40
    3fb2:	70 e0       	ldi	r23, 0x00	; 0
    3fb4:	80 81       	ld	r24, Z
    3fb6:	91 81       	ldd	r25, Z+1	; 0x01
    3fb8:	0e 94 3b 17 	call	0x2e76	; 0x2e76 <_ZN6Module21SPIwriteRegisterBurstEjPhj>
    3fbc:	0a c0       	rjmp	.+20     	; 0x3fd2 <_ZN6SX127x11setSyncWordEPhj+0xc4>
    return(RADIOLIB_ERR_NONE);
  
  } else if(modem == RADIOLIB_SX127X_LORA) {
    3fbe:	80 38       	cpi	r24, 0x80	; 128
    3fc0:	f1 f4       	brne	.+60     	; 0x3ffe <_ZN6SX127x11setSyncWordEPhj+0xf0>
    // with length set to 1 and LoRa modem active, assume it is the LoRa sync word
    if(len > 1) {
    3fc2:	22 97       	sbiw	r28, 0x02	; 2
    3fc4:	f8 f4       	brcc	.+62     	; 0x4004 <_ZN6SX127x11setSyncWordEPhj+0xf6>
      return(RADIOLIB_ERR_INVALID_SYNC_WORD);
    }

    return(this->setSyncWord(syncWord[0]));
    3fc6:	f5 01       	movw	r30, r10
    3fc8:	60 81       	ld	r22, Z
    3fca:	c4 01       	movw	r24, r8
    3fcc:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN6SX127x11setSyncWordEh>
    3fd0:	8c 01       	movw	r16, r24
  }

  return(RADIOLIB_ERR_WRONG_MODEM);
}
    3fd2:	c8 01       	movw	r24, r16
    3fd4:	df 91       	pop	r29
    3fd6:	cf 91       	pop	r28
    3fd8:	1f 91       	pop	r17
    3fda:	0f 91       	pop	r16
    3fdc:	ef 90       	pop	r14
    3fde:	cf 90       	pop	r12
    3fe0:	bf 90       	pop	r11
    3fe2:	af 90       	pop	r10
    3fe4:	9f 90       	pop	r9
    3fe6:	8f 90       	pop	r8
    3fe8:	7f 90       	pop	r7
    3fea:	6f 90       	pop	r6
    3fec:	5f 90       	pop	r5
    3fee:	4f 90       	pop	r4
    3ff0:	08 95       	ret

int16_t SX127x::setSyncWord(uint8_t* syncWord, size_t len) {
  // check active modem
  uint8_t modem = getActiveModem();
  if(modem == RADIOLIB_SX127X_FSK_OOK) {
    RADIOLIB_CHECK_RANGE(len, 1, 8, RADIOLIB_ERR_INVALID_SYNC_WORD);
    3ff2:	07 e9       	ldi	r16, 0x97	; 151
    3ff4:	1f ef       	ldi	r17, 0xFF	; 255
    3ff6:	ed cf       	rjmp	.-38     	; 0x3fd2 <_ZN6SX127x11setSyncWordEPhj+0xc4>

    // sync word must not contain value 0x00
    for(size_t i = 0; i < len; i++) {
      if(syncWord[i] == 0x00) {
        return(RADIOLIB_ERR_INVALID_SYNC_WORD);
    3ff8:	07 e9       	ldi	r16, 0x97	; 151
    3ffa:	1f ef       	ldi	r17, 0xFF	; 255
    3ffc:	ea cf       	rjmp	.-44     	; 0x3fd2 <_ZN6SX127x11setSyncWordEPhj+0xc4>
    }

    return(this->setSyncWord(syncWord[0]));
  }

  return(RADIOLIB_ERR_WRONG_MODEM);
    3ffe:	0c ee       	ldi	r16, 0xEC	; 236
    4000:	1f ef       	ldi	r17, 0xFF	; 255
    4002:	e7 cf       	rjmp	.-50     	; 0x3fd2 <_ZN6SX127x11setSyncWordEPhj+0xc4>
    return(RADIOLIB_ERR_NONE);
  
  } else if(modem == RADIOLIB_SX127X_LORA) {
    // with length set to 1 and LoRa modem active, assume it is the LoRa sync word
    if(len > 1) {
      return(RADIOLIB_ERR_INVALID_SYNC_WORD);
    4004:	07 e9       	ldi	r16, 0x97	; 151
    4006:	1f ef       	ldi	r17, 0xFF	; 255
    4008:	e4 cf       	rjmp	.-56     	; 0x3fd2 <_ZN6SX127x11setSyncWordEPhj+0xc4>

0000400a <_ZN6SX127x16startChannelScanEv>:
  clearIRQFlags();

  return(state);
}

int16_t SX127x::startChannelScan() {
    400a:	cf 92       	push	r12
    400c:	ef 92       	push	r14
    400e:	0f 93       	push	r16
    4010:	cf 93       	push	r28
    4012:	df 93       	push	r29
    4014:	ec 01       	movw	r28, r24
  // check active modem
  if(getActiveModem() != RADIOLIB_SX127X_LORA) {
    4016:	0e 94 ec 18 	call	0x31d8	; 0x31d8 <_ZN6SX127x14getActiveModemEv>
    401a:	80 38       	cpi	r24, 0x80	; 128
    401c:	91 05       	cpc	r25, r1
    401e:	79 f5       	brne	.+94     	; 0x407e <_ZN6SX127x16startChannelScanEv+0x74>
    return(RADIOLIB_ERR_WRONG_MODEM);
  }

  // set mode to standby
  int16_t state = setMode(RADIOLIB_SX127X_STANDBY);
    4020:	61 e0       	ldi	r22, 0x01	; 1
    4022:	ce 01       	movw	r24, r28
    4024:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN6SX127x7setModeEh>
  RADIOLIB_ASSERT(state);
    4028:	00 97       	sbiw	r24, 0x00	; 0
    402a:	31 f0       	breq	.+12     	; 0x4038 <_ZN6SX127x16startChannelScanEv+0x2e>
  this->mod->setRfSwitchState(Module::MODE_RX);

  // set mode to CAD
  state = setMode(RADIOLIB_SX127X_CAD);
  return(state);
}
    402c:	df 91       	pop	r29
    402e:	cf 91       	pop	r28
    4030:	0f 91       	pop	r16
    4032:	ef 90       	pop	r14
    4034:	cf 90       	pop	r12
    4036:	08 95       	ret
  // set mode to standby
  int16_t state = setMode(RADIOLIB_SX127X_STANDBY);
  RADIOLIB_ASSERT(state);

  // clear interrupt flags
  clearIRQFlags();
    4038:	ce 01       	movw	r24, r28
    403a:	0e 94 61 19 	call	0x32c2	; 0x32c2 <_ZN6SX127x13clearIRQFlagsEv>

  // set DIO pin mapping
  state = this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_DIO_MAPPING_1, RADIOLIB_SX127X_DIO0_LORA_CAD_DONE | RADIOLIB_SX127X_DIO1_LORA_CAD_DETECTED, 7, 4);
    403e:	cc 24       	eor	r12, r12
    4040:	ca 94       	dec	r12
    4042:	68 94       	set
    4044:	ee 24       	eor	r14, r14
    4046:	e1 f8       	bld	r14, 1
    4048:	04 e0       	ldi	r16, 0x04	; 4
    404a:	27 e0       	ldi	r18, 0x07	; 7
    404c:	40 ea       	ldi	r20, 0xA0	; 160
    404e:	60 e4       	ldi	r22, 0x40	; 64
    4050:	70 e0       	ldi	r23, 0x00	; 0
    4052:	fe 01       	movw	r30, r28
    4054:	e7 5e       	subi	r30, 0xE7	; 231
    4056:	fe 4f       	sbci	r31, 0xFE	; 254
    4058:	80 81       	ld	r24, Z
    405a:	91 81       	ldd	r25, Z+1	; 0x01
    405c:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
  RADIOLIB_ASSERT(state);
    4060:	00 97       	sbiw	r24, 0x00	; 0
    4062:	21 f7       	brne	.-56     	; 0x402c <_ZN6SX127x16startChannelScanEv+0x22>

  // set RF switch (if present)
  this->mod->setRfSwitchState(Module::MODE_RX);
    4064:	fe 01       	movw	r30, r28
    4066:	e7 5e       	subi	r30, 0xE7	; 231
    4068:	fe 4f       	sbci	r31, 0xFE	; 254
    406a:	62 e0       	ldi	r22, 0x02	; 2
    406c:	80 81       	ld	r24, Z
    406e:	91 81       	ldd	r25, Z+1	; 0x01
    4070:	0e 94 c3 09 	call	0x1386	; 0x1386 <_ZN6Module16setRfSwitchStateEh>

  // set mode to CAD
  state = setMode(RADIOLIB_SX127X_CAD);
    4074:	67 e0       	ldi	r22, 0x07	; 7
    4076:	ce 01       	movw	r24, r28
    4078:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN6SX127x7setModeEh>
    407c:	d7 cf       	rjmp	.-82     	; 0x402c <_ZN6SX127x16startChannelScanEv+0x22>
}

int16_t SX127x::startChannelScan() {
  // check active modem
  if(getActiveModem() != RADIOLIB_SX127X_LORA) {
    return(RADIOLIB_ERR_WRONG_MODEM);
    407e:	8c ee       	ldi	r24, 0xEC	; 236
    4080:	9f ef       	ldi	r25, 0xFF	; 255
    4082:	d4 cf       	rjmp	.-88     	; 0x402c <_ZN6SX127x16startChannelScanEv+0x22>

00004084 <_ZN6SX127x13receiveDirectEv>:

  // start transmitting
  return(setMode(RADIOLIB_SX127X_TX));
}

int16_t SX127x::receiveDirect() {
    4084:	cf 93       	push	r28
    4086:	df 93       	push	r29
    4088:	ec 01       	movw	r28, r24
  // check modem
  if(getActiveModem() != RADIOLIB_SX127X_FSK_OOK) {
    408a:	0e 94 ec 18 	call	0x31d8	; 0x31d8 <_ZN6SX127x14getActiveModemEv>
    408e:	89 2b       	or	r24, r25
    4090:	a9 f4       	brne	.+42     	; 0x40bc <_ZN6SX127x13receiveDirectEv+0x38>
    return(RADIOLIB_ERR_WRONG_MODEM);
  }

  // set RF switch (if present)
  this->mod->setRfSwitchState(Module::MODE_RX);
    4092:	62 e0       	ldi	r22, 0x02	; 2
    4094:	fe 01       	movw	r30, r28
    4096:	e7 5e       	subi	r30, 0xE7	; 231
    4098:	fe 4f       	sbci	r31, 0xFE	; 254
    409a:	80 81       	ld	r24, Z
    409c:	91 81       	ldd	r25, Z+1	; 0x01
    409e:	0e 94 c3 09 	call	0x1386	; 0x1386 <_ZN6Module16setRfSwitchStateEh>

  // activate direct mode
  int16_t state = directMode();
    40a2:	ce 01       	movw	r24, r28
    40a4:	0e 94 13 1d 	call	0x3a26	; 0x3a26 <_ZN6SX127x10directModeEv>
  RADIOLIB_ASSERT(state);
    40a8:	00 97       	sbiw	r24, 0x00	; 0
    40aa:	19 f0       	breq	.+6      	; 0x40b2 <_ZN6SX127x13receiveDirectEv+0x2e>
  // apply fixes to errata
  RADIOLIB_ERRATA_SX127X(true);

  // start receiving
  return(setMode(RADIOLIB_SX127X_RX));
}
    40ac:	df 91       	pop	r29
    40ae:	cf 91       	pop	r28
    40b0:	08 95       	ret

  // apply fixes to errata
  RADIOLIB_ERRATA_SX127X(true);

  // start receiving
  return(setMode(RADIOLIB_SX127X_RX));
    40b2:	65 e0       	ldi	r22, 0x05	; 5
    40b4:	ce 01       	movw	r24, r28
    40b6:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN6SX127x7setModeEh>
    40ba:	f8 cf       	rjmp	.-16     	; 0x40ac <_ZN6SX127x13receiveDirectEv+0x28>
}

int16_t SX127x::receiveDirect() {
  // check modem
  if(getActiveModem() != RADIOLIB_SX127X_FSK_OOK) {
    return(RADIOLIB_ERR_WRONG_MODEM);
    40bc:	8c ee       	ldi	r24, 0xEC	; 236
    40be:	9f ef       	ldi	r25, 0xFF	; 255
    40c0:	f5 cf       	rjmp	.-22     	; 0x40ac <_ZN6SX127x13receiveDirectEv+0x28>

000040c2 <_ZN6SX127x14transmitDirectEm>:
int16_t SX127x::standby(uint8_t mode) {
  (void)mode;
  return(standby());
}

int16_t SX127x::transmitDirect(uint32_t frf) {
    40c2:	cf 92       	push	r12
    40c4:	df 92       	push	r13
    40c6:	ef 92       	push	r14
    40c8:	ff 92       	push	r15
    40ca:	0f 93       	push	r16
    40cc:	1f 93       	push	r17
    40ce:	cf 93       	push	r28
    40d0:	df 93       	push	r29
    40d2:	ec 01       	movw	r28, r24
    40d4:	6a 01       	movw	r12, r20
    40d6:	7b 01       	movw	r14, r22
  // check modem
  if(getActiveModem() != RADIOLIB_SX127X_FSK_OOK) {
    40d8:	0e 94 ec 18 	call	0x31d8	; 0x31d8 <_ZN6SX127x14getActiveModemEv>
    40dc:	89 2b       	or	r24, r25
    40de:	09 f0       	breq	.+2      	; 0x40e2 <_ZN6SX127x14transmitDirectEm+0x20>
    40e0:	44 c0       	rjmp	.+136    	; 0x416a <_ZN6SX127x14transmitDirectEm+0xa8>
    return(RADIOLIB_ERR_WRONG_MODEM);
  }

  // set RF switch (if present)
  this->mod->setRfSwitchState(Module::MODE_TX);
    40e2:	63 e0       	ldi	r22, 0x03	; 3
    40e4:	fe 01       	movw	r30, r28
    40e6:	e7 5e       	subi	r30, 0xE7	; 231
    40e8:	fe 4f       	sbci	r31, 0xFE	; 254
    40ea:	80 81       	ld	r24, Z
    40ec:	91 81       	ldd	r25, Z+1	; 0x01
    40ee:	0e 94 c3 09 	call	0x1386	; 0x1386 <_ZN6Module16setRfSwitchStateEh>

  // user requested to start transmitting immediately (required for RTTY)
  if(frf != 0) {
    40f2:	c1 14       	cp	r12, r1
    40f4:	d1 04       	cpc	r13, r1
    40f6:	e1 04       	cpc	r14, r1
    40f8:	f1 04       	cpc	r15, r1
    40fa:	51 f4       	brne	.+20     	; 0x4110 <_ZN6SX127x14transmitDirectEm+0x4e>

    return(setMode(RADIOLIB_SX127X_TX));
  }

  // activate direct mode
  int16_t state = directMode();
    40fc:	ce 01       	movw	r24, r28
    40fe:	0e 94 13 1d 	call	0x3a26	; 0x3a26 <_ZN6SX127x10directModeEv>
  RADIOLIB_ASSERT(state);
    4102:	00 97       	sbiw	r24, 0x00	; 0
    4104:	49 f5       	brne	.+82     	; 0x4158 <_ZN6SX127x14transmitDirectEm+0x96>

  // apply fixes to errata
  RADIOLIB_ERRATA_SX127X(false);

  // start transmitting
  return(setMode(RADIOLIB_SX127X_TX));
    4106:	63 e0       	ldi	r22, 0x03	; 3
    4108:	ce 01       	movw	r24, r28
    410a:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN6SX127x7setModeEh>
    410e:	24 c0       	rjmp	.+72     	; 0x4158 <_ZN6SX127x14transmitDirectEm+0x96>
  // set RF switch (if present)
  this->mod->setRfSwitchState(Module::MODE_TX);

  // user requested to start transmitting immediately (required for RTTY)
  if(frf != 0) {
    this->mod->SPIwriteRegister(RADIOLIB_SX127X_REG_FRF_MSB, (frf & 0xFF0000) >> 16);
    4110:	8e 01       	movw	r16, r28
    4112:	07 5e       	subi	r16, 0xE7	; 231
    4114:	1e 4f       	sbci	r17, 0xFE	; 254
    4116:	a7 01       	movw	r20, r14
    4118:	66 27       	eor	r22, r22
    411a:	77 27       	eor	r23, r23
    411c:	66 e0       	ldi	r22, 0x06	; 6
    411e:	70 e0       	ldi	r23, 0x00	; 0
    4120:	f8 01       	movw	r30, r16
    4122:	80 81       	ld	r24, Z
    4124:	91 81       	ldd	r25, Z+1	; 0x01
    4126:	0e 94 ee 16 	call	0x2ddc	; 0x2ddc <_ZN6Module16SPIwriteRegisterEjh>
    this->mod->SPIwriteRegister(RADIOLIB_SX127X_REG_FRF_MID, (frf & 0x00FF00) >> 8);
    412a:	77 27       	eor	r23, r23
    412c:	6f 2d       	mov	r22, r15
    412e:	5e 2d       	mov	r21, r14
    4130:	4d 2d       	mov	r20, r13
    4132:	67 e0       	ldi	r22, 0x07	; 7
    4134:	70 e0       	ldi	r23, 0x00	; 0
    4136:	f8 01       	movw	r30, r16
    4138:	80 81       	ld	r24, Z
    413a:	91 81       	ldd	r25, Z+1	; 0x01
    413c:	0e 94 ee 16 	call	0x2ddc	; 0x2ddc <_ZN6Module16SPIwriteRegisterEjh>
    this->mod->SPIwriteRegister(RADIOLIB_SX127X_REG_FRF_LSB, frf & 0x0000FF);
    4140:	4c 2d       	mov	r20, r12
    4142:	68 e0       	ldi	r22, 0x08	; 8
    4144:	70 e0       	ldi	r23, 0x00	; 0
    4146:	f8 01       	movw	r30, r16
    4148:	80 81       	ld	r24, Z
    414a:	91 81       	ldd	r25, Z+1	; 0x01
    414c:	0e 94 ee 16 	call	0x2ddc	; 0x2ddc <_ZN6Module16SPIwriteRegisterEjh>

    return(setMode(RADIOLIB_SX127X_TX));
    4150:	63 e0       	ldi	r22, 0x03	; 3
    4152:	ce 01       	movw	r24, r28
    4154:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN6SX127x7setModeEh>
  // apply fixes to errata
  RADIOLIB_ERRATA_SX127X(false);

  // start transmitting
  return(setMode(RADIOLIB_SX127X_TX));
}
    4158:	df 91       	pop	r29
    415a:	cf 91       	pop	r28
    415c:	1f 91       	pop	r17
    415e:	0f 91       	pop	r16
    4160:	ff 90       	pop	r15
    4162:	ef 90       	pop	r14
    4164:	df 90       	pop	r13
    4166:	cf 90       	pop	r12
    4168:	08 95       	ret
}

int16_t SX127x::transmitDirect(uint32_t frf) {
  // check modem
  if(getActiveModem() != RADIOLIB_SX127X_FSK_OOK) {
    return(RADIOLIB_ERR_WRONG_MODEM);
    416a:	8c ee       	ldi	r24, 0xEC	; 236
    416c:	9f ef       	ldi	r25, 0xFF	; 255
    416e:	f4 cf       	rjmp	.-24     	; 0x4158 <_ZN6SX127x14transmitDirectEm+0x96>

00004170 <_ZN6SX127x8transmitEPhjh>:
  state = variablePacketLengthMode();

  return(state);
}

int16_t SX127x::transmit(uint8_t* data, size_t len, uint8_t addr) {
    4170:	4f 92       	push	r4
    4172:	5f 92       	push	r5
    4174:	6f 92       	push	r6
    4176:	7f 92       	push	r7
    4178:	af 92       	push	r10
    417a:	bf 92       	push	r11
    417c:	cf 92       	push	r12
    417e:	df 92       	push	r13
    4180:	ef 92       	push	r14
    4182:	ff 92       	push	r15
    4184:	0f 93       	push	r16
    4186:	1f 93       	push	r17
    4188:	cf 93       	push	r28
    418a:	df 93       	push	r29
    418c:	ec 01       	movw	r28, r24
    418e:	8b 01       	movw	r16, r22
    4190:	5a 01       	movw	r10, r20
    4192:	f2 2e       	mov	r15, r18
  // set mode to standby
  int16_t state = setMode(RADIOLIB_SX127X_STANDBY);
    4194:	61 e0       	ldi	r22, 0x01	; 1
    4196:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN6SX127x7setModeEh>
  RADIOLIB_ASSERT(state);
    419a:	00 97       	sbiw	r24, 0x00	; 0
    419c:	79 f0       	breq	.+30     	; 0x41bc <_ZN6SX127x8transmitEPhjh+0x4c>
  // update data rate
  uint32_t elapsed = this->mod->hal->micros() - start;
  this->dataRate = (len*8.0)/((float)elapsed/1000000.0);

  return(finishTransmit());
}
    419e:	df 91       	pop	r29
    41a0:	cf 91       	pop	r28
    41a2:	1f 91       	pop	r17
    41a4:	0f 91       	pop	r16
    41a6:	ff 90       	pop	r15
    41a8:	ef 90       	pop	r14
    41aa:	df 90       	pop	r13
    41ac:	cf 90       	pop	r12
    41ae:	bf 90       	pop	r11
    41b0:	af 90       	pop	r10
    41b2:	7f 90       	pop	r7
    41b4:	6f 90       	pop	r6
    41b6:	5f 90       	pop	r5
    41b8:	4f 90       	pop	r4
    41ba:	08 95       	ret
int16_t SX127x::transmit(uint8_t* data, size_t len, uint8_t addr) {
  // set mode to standby
  int16_t state = setMode(RADIOLIB_SX127X_STANDBY);
  RADIOLIB_ASSERT(state);

  int16_t modem = getActiveModem();
    41bc:	ce 01       	movw	r24, r28
    41be:	0e 94 ec 18 	call	0x31d8	; 0x31d8 <_ZN6SX127x14getActiveModemEv>
  uint32_t start = 0;
  if(modem == RADIOLIB_SX127X_LORA) {
    41c2:	80 38       	cpi	r24, 0x80	; 128
    41c4:	91 05       	cpc	r25, r1
    41c6:	09 f0       	breq	.+2      	; 0x41ca <_ZN6SX127x8transmitEPhjh+0x5a>
    41c8:	7a c0       	rjmp	.+244    	; 0x42be <_ZN6SX127x8transmitEPhjh+0x14e>
    // calculate timeout (150 % of expected time-on-air)
    uint32_t timeout = getTimeOnAir(len) * 1.5;
    41ca:	e8 81       	ld	r30, Y
    41cc:	f9 81       	ldd	r31, Y+1	; 0x01
    41ce:	02 a8       	ldd	r0, Z+50	; 0x32
    41d0:	f3 a9       	ldd	r31, Z+51	; 0x33
    41d2:	e0 2d       	mov	r30, r0
    41d4:	b5 01       	movw	r22, r10
    41d6:	ce 01       	movw	r24, r28
    41d8:	09 95       	icall
    41da:	0e 94 76 39 	call	0x72ec	; 0x72ec <__floatunsisf>
    41de:	20 e0       	ldi	r18, 0x00	; 0
    41e0:	30 e0       	ldi	r19, 0x00	; 0
    41e2:	40 ec       	ldi	r20, 0xC0	; 192
    41e4:	5f e3       	ldi	r21, 0x3F	; 63
    41e6:	0e 94 d7 39 	call	0x73ae	; 0x73ae <__mulsf3>
    41ea:	0e 94 61 3c 	call	0x78c2	; 0x78c2 <__fixunssfsi>
    41ee:	2b 01       	movw	r4, r22
    41f0:	3c 01       	movw	r6, r24

    // start transmission
    state = startTransmit(data, len, addr);
    41f2:	e8 81       	ld	r30, Y
    41f4:	f9 81       	ldd	r31, Y+1	; 0x01
    41f6:	06 84       	ldd	r0, Z+14	; 0x0e
    41f8:	f7 85       	ldd	r31, Z+15	; 0x0f
    41fa:	e0 2d       	mov	r30, r0
    41fc:	2f 2d       	mov	r18, r15
    41fe:	a5 01       	movw	r20, r10
    4200:	b8 01       	movw	r22, r16
    4202:	ce 01       	movw	r24, r28
    4204:	09 95       	icall
    RADIOLIB_ASSERT(state);
    4206:	00 97       	sbiw	r24, 0x00	; 0
    4208:	51 f6       	brne	.-108    	; 0x419e <_ZN6SX127x8transmitEPhjh+0x2e>

    // wait for packet transmission or timeout
    start = this->mod->hal->micros();
    420a:	fe 01       	movw	r30, r28
    420c:	e7 5e       	subi	r30, 0xE7	; 231
    420e:	fe 4f       	sbci	r31, 0xFE	; 254
    4210:	01 90       	ld	r0, Z+
    4212:	f0 81       	ld	r31, Z
    4214:	e0 2d       	mov	r30, r0
    4216:	80 81       	ld	r24, Z
    4218:	91 81       	ldd	r25, Z+1	; 0x01
    421a:	dc 01       	movw	r26, r24
    421c:	ed 91       	ld	r30, X+
    421e:	fc 91       	ld	r31, X
    4220:	00 88       	ldd	r0, Z+16	; 0x10
    4222:	f1 89       	ldd	r31, Z+17	; 0x11
    4224:	e0 2d       	mov	r30, r0
    4226:	09 95       	icall
    4228:	6b 01       	movw	r12, r22
    422a:	7c 01       	movw	r14, r24
    while(!this->mod->hal->digitalRead(this->mod->getIrq())) {
    422c:	fe 01       	movw	r30, r28
    422e:	e7 5e       	subi	r30, 0xE7	; 231
    4230:	fe 4f       	sbci	r31, 0xFE	; 254
    4232:	a0 81       	ld	r26, Z
    4234:	b1 81       	ldd	r27, Z+1	; 0x01
    4236:	8d 91       	ld	r24, X+
    4238:	9c 91       	ld	r25, X
    423a:	11 97       	sbiw	r26, 0x01	; 1
    423c:	fc 01       	movw	r30, r24
    423e:	20 81       	ld	r18, Z
    4240:	31 81       	ldd	r19, Z+1	; 0x01
    4242:	f9 01       	movw	r30, r18
    4244:	24 81       	ldd	r18, Z+4	; 0x04
    4246:	35 81       	ldd	r19, Z+5	; 0x05

    /*!
      \brief Access method to get the pin number of interrupt/GPIO.
      \returns Pin number of interrupt/GPIO configured in the constructor.
    */
    uint32_t getIrq() const { return(irqPin); }
    4248:	50 96       	adiw	r26, 0x10	; 16
    424a:	4d 91       	ld	r20, X+
    424c:	5d 91       	ld	r21, X+
    424e:	6d 91       	ld	r22, X+
    4250:	7c 91       	ld	r23, X
    4252:	53 97       	sbiw	r26, 0x13	; 19
    4254:	f9 01       	movw	r30, r18
    4256:	09 95       	icall
    4258:	67 2b       	or	r22, r23
    425a:	68 2b       	or	r22, r24
    425c:	69 2b       	or	r22, r25
    425e:	09 f0       	breq	.+2      	; 0x4262 <_ZN6SX127x8transmitEPhjh+0xf2>
    4260:	b3 c0       	rjmp	.+358    	; 0x43c8 <_ZN6SX127x8transmitEPhjh+0x258>
      this->mod->hal->yield();
    4262:	8e 01       	movw	r16, r28
    4264:	07 5e       	subi	r16, 0xE7	; 231
    4266:	1e 4f       	sbci	r17, 0xFE	; 254
    4268:	d8 01       	movw	r26, r16
    426a:	ed 91       	ld	r30, X+
    426c:	fc 91       	ld	r31, X
    426e:	80 81       	ld	r24, Z
    4270:	91 81       	ldd	r25, Z+1	; 0x01
    4272:	dc 01       	movw	r26, r24
    4274:	ed 91       	ld	r30, X+
    4276:	fc 91       	ld	r31, X
    4278:	06 a0       	ldd	r0, Z+38	; 0x26
    427a:	f7 a1       	ldd	r31, Z+39	; 0x27
    427c:	e0 2d       	mov	r30, r0
    427e:	09 95       	icall
      if(this->mod->hal->micros() - start > timeout) {
    4280:	d8 01       	movw	r26, r16
    4282:	ed 91       	ld	r30, X+
    4284:	fc 91       	ld	r31, X
    4286:	80 81       	ld	r24, Z
    4288:	91 81       	ldd	r25, Z+1	; 0x01
    428a:	dc 01       	movw	r26, r24
    428c:	ed 91       	ld	r30, X+
    428e:	fc 91       	ld	r31, X
    4290:	00 88       	ldd	r0, Z+16	; 0x10
    4292:	f1 89       	ldd	r31, Z+17	; 0x11
    4294:	e0 2d       	mov	r30, r0
    4296:	09 95       	icall
    4298:	6c 19       	sub	r22, r12
    429a:	7d 09       	sbc	r23, r13
    429c:	8e 09       	sbc	r24, r14
    429e:	9f 09       	sbc	r25, r15
    42a0:	46 16       	cp	r4, r22
    42a2:	57 06       	cpc	r5, r23
    42a4:	68 06       	cpc	r6, r24
    42a6:	79 06       	cpc	r7, r25
    42a8:	08 f6       	brcc	.-126    	; 0x422c <_ZN6SX127x8transmitEPhjh+0xbc>
        finishTransmit();
    42aa:	e8 81       	ld	r30, Y
    42ac:	f9 81       	ldd	r31, Y+1	; 0x01
    42ae:	00 88       	ldd	r0, Z+16	; 0x10
    42b0:	f1 89       	ldd	r31, Z+17	; 0x11
    42b2:	e0 2d       	mov	r30, r0
    42b4:	ce 01       	movw	r24, r28
    42b6:	09 95       	icall
        return(RADIOLIB_ERR_TX_TIMEOUT);
    42b8:	8b ef       	ldi	r24, 0xFB	; 251
    42ba:	9f ef       	ldi	r25, 0xFF	; 255
    42bc:	70 cf       	rjmp	.-288    	; 0x419e <_ZN6SX127x8transmitEPhjh+0x2e>
      }
    }

  } else if(modem == RADIOLIB_SX127X_FSK_OOK) {
    42be:	89 2b       	or	r24, r25
    42c0:	09 f0       	breq	.+2      	; 0x42c4 <_ZN6SX127x8transmitEPhjh+0x154>
    42c2:	c5 c0       	rjmp	.+394    	; 0x444e <_ZN6SX127x8transmitEPhjh+0x2de>
    // calculate timeout (5ms + 500 % of expected time-on-air)
    uint32_t timeout = 5000 + getTimeOnAir(len) * 5;
    42c4:	e8 81       	ld	r30, Y
    42c6:	f9 81       	ldd	r31, Y+1	; 0x01
    42c8:	02 a8       	ldd	r0, Z+50	; 0x32
    42ca:	f3 a9       	ldd	r31, Z+51	; 0x33
    42cc:	e0 2d       	mov	r30, r0
    42ce:	b5 01       	movw	r22, r10
    42d0:	ce 01       	movw	r24, r28
    42d2:	09 95       	icall
    42d4:	2b 01       	movw	r4, r22
    42d6:	3c 01       	movw	r6, r24
    42d8:	44 0c       	add	r4, r4
    42da:	55 1c       	adc	r5, r5
    42dc:	66 1c       	adc	r6, r6
    42de:	77 1c       	adc	r7, r7
    42e0:	44 0c       	add	r4, r4
    42e2:	55 1c       	adc	r5, r5
    42e4:	66 1c       	adc	r6, r6
    42e6:	77 1c       	adc	r7, r7
    42e8:	46 0e       	add	r4, r22
    42ea:	57 1e       	adc	r5, r23
    42ec:	68 1e       	adc	r6, r24
    42ee:	79 1e       	adc	r7, r25
    42f0:	b8 e8       	ldi	r27, 0x88	; 136
    42f2:	4b 0e       	add	r4, r27
    42f4:	b3 e1       	ldi	r27, 0x13	; 19
    42f6:	5b 1e       	adc	r5, r27
    42f8:	61 1c       	adc	r6, r1
    42fa:	71 1c       	adc	r7, r1

    // start transmission
    state = startTransmit(data, len, addr);
    42fc:	e8 81       	ld	r30, Y
    42fe:	f9 81       	ldd	r31, Y+1	; 0x01
    4300:	06 84       	ldd	r0, Z+14	; 0x0e
    4302:	f7 85       	ldd	r31, Z+15	; 0x0f
    4304:	e0 2d       	mov	r30, r0
    4306:	2f 2d       	mov	r18, r15
    4308:	a5 01       	movw	r20, r10
    430a:	b8 01       	movw	r22, r16
    430c:	ce 01       	movw	r24, r28
    430e:	09 95       	icall
    RADIOLIB_ASSERT(state);
    4310:	00 97       	sbiw	r24, 0x00	; 0
    4312:	09 f0       	breq	.+2      	; 0x4316 <_ZN6SX127x8transmitEPhjh+0x1a6>
    4314:	44 cf       	rjmp	.-376    	; 0x419e <_ZN6SX127x8transmitEPhjh+0x2e>

    // wait for transmission end or timeout
    start = this->mod->hal->micros();
    4316:	fe 01       	movw	r30, r28
    4318:	e7 5e       	subi	r30, 0xE7	; 231
    431a:	fe 4f       	sbci	r31, 0xFE	; 254
    431c:	01 90       	ld	r0, Z+
    431e:	f0 81       	ld	r31, Z
    4320:	e0 2d       	mov	r30, r0
    4322:	80 81       	ld	r24, Z
    4324:	91 81       	ldd	r25, Z+1	; 0x01
    4326:	dc 01       	movw	r26, r24
    4328:	ed 91       	ld	r30, X+
    432a:	fc 91       	ld	r31, X
    432c:	00 88       	ldd	r0, Z+16	; 0x10
    432e:	f1 89       	ldd	r31, Z+17	; 0x11
    4330:	e0 2d       	mov	r30, r0
    4332:	09 95       	icall
    4334:	6b 01       	movw	r12, r22
    4336:	7c 01       	movw	r14, r24
    while(!this->mod->hal->digitalRead(this->mod->getIrq())) {
    4338:	fe 01       	movw	r30, r28
    433a:	e7 5e       	subi	r30, 0xE7	; 231
    433c:	fe 4f       	sbci	r31, 0xFE	; 254
    433e:	a0 81       	ld	r26, Z
    4340:	b1 81       	ldd	r27, Z+1	; 0x01
    4342:	8d 91       	ld	r24, X+
    4344:	9c 91       	ld	r25, X
    4346:	11 97       	sbiw	r26, 0x01	; 1
    4348:	fc 01       	movw	r30, r24
    434a:	20 81       	ld	r18, Z
    434c:	31 81       	ldd	r19, Z+1	; 0x01
    434e:	f9 01       	movw	r30, r18
    4350:	24 81       	ldd	r18, Z+4	; 0x04
    4352:	35 81       	ldd	r19, Z+5	; 0x05
    4354:	50 96       	adiw	r26, 0x10	; 16
    4356:	4d 91       	ld	r20, X+
    4358:	5d 91       	ld	r21, X+
    435a:	6d 91       	ld	r22, X+
    435c:	7c 91       	ld	r23, X
    435e:	53 97       	sbiw	r26, 0x13	; 19
    4360:	f9 01       	movw	r30, r18
    4362:	09 95       	icall
    4364:	67 2b       	or	r22, r23
    4366:	68 2b       	or	r22, r24
    4368:	69 2b       	or	r22, r25
    436a:	71 f5       	brne	.+92     	; 0x43c8 <_ZN6SX127x8transmitEPhjh+0x258>
      this->mod->hal->yield();
    436c:	8e 01       	movw	r16, r28
    436e:	07 5e       	subi	r16, 0xE7	; 231
    4370:	1e 4f       	sbci	r17, 0xFE	; 254
    4372:	d8 01       	movw	r26, r16
    4374:	ed 91       	ld	r30, X+
    4376:	fc 91       	ld	r31, X
    4378:	80 81       	ld	r24, Z
    437a:	91 81       	ldd	r25, Z+1	; 0x01
    437c:	dc 01       	movw	r26, r24
    437e:	ed 91       	ld	r30, X+
    4380:	fc 91       	ld	r31, X
    4382:	06 a0       	ldd	r0, Z+38	; 0x26
    4384:	f7 a1       	ldd	r31, Z+39	; 0x27
    4386:	e0 2d       	mov	r30, r0
    4388:	09 95       	icall
      if(this->mod->hal->micros() - start > timeout) {
    438a:	d8 01       	movw	r26, r16
    438c:	ed 91       	ld	r30, X+
    438e:	fc 91       	ld	r31, X
    4390:	80 81       	ld	r24, Z
    4392:	91 81       	ldd	r25, Z+1	; 0x01
    4394:	dc 01       	movw	r26, r24
    4396:	ed 91       	ld	r30, X+
    4398:	fc 91       	ld	r31, X
    439a:	00 88       	ldd	r0, Z+16	; 0x10
    439c:	f1 89       	ldd	r31, Z+17	; 0x11
    439e:	e0 2d       	mov	r30, r0
    43a0:	09 95       	icall
    43a2:	6c 19       	sub	r22, r12
    43a4:	7d 09       	sbc	r23, r13
    43a6:	8e 09       	sbc	r24, r14
    43a8:	9f 09       	sbc	r25, r15
    43aa:	46 16       	cp	r4, r22
    43ac:	57 06       	cpc	r5, r23
    43ae:	68 06       	cpc	r6, r24
    43b0:	79 06       	cpc	r7, r25
    43b2:	10 f6       	brcc	.-124    	; 0x4338 <_ZN6SX127x8transmitEPhjh+0x1c8>
        finishTransmit();
    43b4:	e8 81       	ld	r30, Y
    43b6:	f9 81       	ldd	r31, Y+1	; 0x01
    43b8:	00 88       	ldd	r0, Z+16	; 0x10
    43ba:	f1 89       	ldd	r31, Z+17	; 0x11
    43bc:	e0 2d       	mov	r30, r0
    43be:	ce 01       	movw	r24, r28
    43c0:	09 95       	icall
        return(RADIOLIB_ERR_TX_TIMEOUT);
    43c2:	8b ef       	ldi	r24, 0xFB	; 251
    43c4:	9f ef       	ldi	r25, 0xFF	; 255
    43c6:	eb ce       	rjmp	.-554    	; 0x419e <_ZN6SX127x8transmitEPhjh+0x2e>
  } else {
    return(RADIOLIB_ERR_UNKNOWN);
  }

  // update data rate
  uint32_t elapsed = this->mod->hal->micros() - start;
    43c8:	fe 01       	movw	r30, r28
    43ca:	e7 5e       	subi	r30, 0xE7	; 231
    43cc:	fe 4f       	sbci	r31, 0xFE	; 254
    43ce:	01 90       	ld	r0, Z+
    43d0:	f0 81       	ld	r31, Z
    43d2:	e0 2d       	mov	r30, r0
    43d4:	80 81       	ld	r24, Z
    43d6:	91 81       	ldd	r25, Z+1	; 0x01
    43d8:	dc 01       	movw	r26, r24
    43da:	ed 91       	ld	r30, X+
    43dc:	fc 91       	ld	r31, X
    43de:	00 88       	ldd	r0, Z+16	; 0x10
    43e0:	f1 89       	ldd	r31, Z+17	; 0x11
    43e2:	e0 2d       	mov	r30, r0
    43e4:	09 95       	icall
    43e6:	9b 01       	movw	r18, r22
    43e8:	ac 01       	movw	r20, r24
    43ea:	2c 19       	sub	r18, r12
    43ec:	3d 09       	sbc	r19, r13
    43ee:	4e 09       	sbc	r20, r14
    43f0:	5f 09       	sbc	r21, r15
    43f2:	69 01       	movw	r12, r18
    43f4:	7a 01       	movw	r14, r20
  this->dataRate = (len*8.0)/((float)elapsed/1000000.0);
    43f6:	b5 01       	movw	r22, r10
    43f8:	90 e0       	ldi	r25, 0x00	; 0
    43fa:	80 e0       	ldi	r24, 0x00	; 0
    43fc:	0e 94 76 39 	call	0x72ec	; 0x72ec <__floatunsisf>
    4400:	20 e0       	ldi	r18, 0x00	; 0
    4402:	30 e0       	ldi	r19, 0x00	; 0
    4404:	40 e0       	ldi	r20, 0x00	; 0
    4406:	51 e4       	ldi	r21, 0x41	; 65
    4408:	0e 94 d7 39 	call	0x73ae	; 0x73ae <__mulsf3>
    440c:	2b 01       	movw	r4, r22
    440e:	3c 01       	movw	r6, r24
    4410:	c7 01       	movw	r24, r14
    4412:	b6 01       	movw	r22, r12
    4414:	0e 94 76 39 	call	0x72ec	; 0x72ec <__floatunsisf>
    4418:	20 e0       	ldi	r18, 0x00	; 0
    441a:	34 e2       	ldi	r19, 0x24	; 36
    441c:	44 e7       	ldi	r20, 0x74	; 116
    441e:	59 e4       	ldi	r21, 0x49	; 73
    4420:	0e 94 ef 3b 	call	0x77de	; 0x77de <__divsf3>
    4424:	9b 01       	movw	r18, r22
    4426:	ac 01       	movw	r20, r24
    4428:	c3 01       	movw	r24, r6
    442a:	b2 01       	movw	r22, r4
    442c:	0e 94 ef 3b 	call	0x77de	; 0x77de <__divsf3>
    4430:	fe 01       	movw	r30, r28
    4432:	e2 5d       	subi	r30, 0xD2	; 210
    4434:	fe 4f       	sbci	r31, 0xFE	; 254
    4436:	60 83       	st	Z, r22
    4438:	71 83       	std	Z+1, r23	; 0x01
    443a:	82 83       	std	Z+2, r24	; 0x02
    443c:	93 83       	std	Z+3, r25	; 0x03

  return(finishTransmit());
    443e:	e8 81       	ld	r30, Y
    4440:	f9 81       	ldd	r31, Y+1	; 0x01
    4442:	00 88       	ldd	r0, Z+16	; 0x10
    4444:	f1 89       	ldd	r31, Z+17	; 0x11
    4446:	e0 2d       	mov	r30, r0
    4448:	ce 01       	movw	r24, r28
    444a:	09 95       	icall
    444c:	a8 ce       	rjmp	.-688    	; 0x419e <_ZN6SX127x8transmitEPhjh+0x2e>
        finishTransmit();
        return(RADIOLIB_ERR_TX_TIMEOUT);
      }
    }
  } else {
    return(RADIOLIB_ERR_UNKNOWN);
    444e:	8f ef       	ldi	r24, 0xFF	; 255
    4450:	9f ef       	ldi	r25, 0xFF	; 255
    4452:	a5 ce       	rjmp	.-694    	; 0x419e <_ZN6SX127x8transmitEPhjh+0x2e>

00004454 <_ZN6SX127813setHeaderTypeEhj>:
  // write register
  state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_MODEM_CONFIG_1, newCodingRate, 3, 1);
  return(state);
}

int16_t SX1278::setHeaderType(uint8_t headerType, size_t len) {
    4454:	cf 92       	push	r12
    4456:	df 92       	push	r13
    4458:	ef 92       	push	r14
    445a:	ff 92       	push	r15
    445c:	0f 93       	push	r16
    445e:	1f 93       	push	r17
    4460:	cf 93       	push	r28
    4462:	df 93       	push	r29
    4464:	ec 01       	movw	r28, r24
    4466:	16 2f       	mov	r17, r22
    4468:	f4 2e       	mov	r15, r20
    446a:	d5 2e       	mov	r13, r21
  // check active modem
  if(getActiveModem() != RADIOLIB_SX127X_LORA) {
    446c:	0e 94 ec 18 	call	0x31d8	; 0x31d8 <_ZN6SX127x14getActiveModemEv>
    4470:	80 38       	cpi	r24, 0x80	; 128
    4472:	91 05       	cpc	r25, r1
    4474:	71 f5       	brne	.+92     	; 0x44d2 <_ZN6SX127813setHeaderTypeEhj+0x7e>
    return(RADIOLIB_ERR_WRONG_MODEM);
  }

  // set requested packet mode
  int16_t state = this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_MODEM_CONFIG_1, headerType, 0, 0);
    4476:	cc 24       	eor	r12, r12
    4478:	ca 94       	dec	r12
    447a:	68 94       	set
    447c:	ee 24       	eor	r14, r14
    447e:	e1 f8       	bld	r14, 1
    4480:	00 e0       	ldi	r16, 0x00	; 0
    4482:	20 e0       	ldi	r18, 0x00	; 0
    4484:	41 2f       	mov	r20, r17
    4486:	6d e1       	ldi	r22, 0x1D	; 29
    4488:	70 e0       	ldi	r23, 0x00	; 0
    448a:	fe 01       	movw	r30, r28
    448c:	e7 5e       	subi	r30, 0xE7	; 231
    448e:	fe 4f       	sbci	r31, 0xFE	; 254
    4490:	80 81       	ld	r24, Z
    4492:	91 81       	ldd	r25, Z+1	; 0x01
    4494:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
  RADIOLIB_ASSERT(state);
    4498:	00 97       	sbiw	r24, 0x00	; 0
    449a:	49 f0       	breq	.+18     	; 0x44ae <_ZN6SX127813setHeaderTypeEhj+0x5a>

  // update cached value
  SX127x::packetLength = len;

  return(state);
}
    449c:	df 91       	pop	r29
    449e:	cf 91       	pop	r28
    44a0:	1f 91       	pop	r17
    44a2:	0f 91       	pop	r16
    44a4:	ff 90       	pop	r15
    44a6:	ef 90       	pop	r14
    44a8:	df 90       	pop	r13
    44aa:	cf 90       	pop	r12
    44ac:	08 95       	ret
  // set requested packet mode
  int16_t state = this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_MODEM_CONFIG_1, headerType, 0, 0);
  RADIOLIB_ASSERT(state);

  // set length to register
  state = this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_PAYLOAD_LENGTH, len);
    44ae:	27 e0       	ldi	r18, 0x07	; 7
    44b0:	4f 2d       	mov	r20, r15
    44b2:	62 e2       	ldi	r22, 0x22	; 34
    44b4:	70 e0       	ldi	r23, 0x00	; 0
    44b6:	fe 01       	movw	r30, r28
    44b8:	e7 5e       	subi	r30, 0xE7	; 231
    44ba:	fe 4f       	sbci	r31, 0xFE	; 254
    44bc:	80 81       	ld	r24, Z
    44be:	91 81       	ldd	r25, Z+1	; 0x01
    44c0:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
  RADIOLIB_ASSERT(state);
    44c4:	00 97       	sbiw	r24, 0x00	; 0
    44c6:	51 f7       	brne	.-44     	; 0x449c <_ZN6SX127813setHeaderTypeEhj+0x48>

  // update cached value
  SX127x::packetLength = len;
    44c8:	c4 5d       	subi	r28, 0xD4	; 212
    44ca:	de 4f       	sbci	r29, 0xFE	; 254
    44cc:	f8 82       	st	Y, r15
    44ce:	d9 82       	std	Y+1, r13	; 0x01
    44d0:	e5 cf       	rjmp	.-54     	; 0x449c <_ZN6SX127813setHeaderTypeEhj+0x48>
}

int16_t SX1278::setHeaderType(uint8_t headerType, size_t len) {
  // check active modem
  if(getActiveModem() != RADIOLIB_SX127X_LORA) {
    return(RADIOLIB_ERR_WRONG_MODEM);
    44d2:	8c ee       	ldi	r24, 0xEC	; 236
    44d4:	9f ef       	ldi	r25, 0xFF	; 255
    44d6:	e2 cf       	rjmp	.-60     	; 0x449c <_ZN6SX127813setHeaderTypeEhj+0x48>

000044d8 <_ZN6SX127814implicitHeaderEj>:

  this->ldroAuto = true;
  return(RADIOLIB_ERR_NONE);
}

int16_t SX1278::implicitHeader(size_t len) {
    44d8:	ab 01       	movw	r20, r22
  return(setHeaderType(RADIOLIB_SX1278_HEADER_IMPL_MODE, len));
    44da:	61 e0       	ldi	r22, 0x01	; 1
    44dc:	0e 94 2a 22 	call	0x4454	; 0x4454 <_ZN6SX127813setHeaderTypeEhj>
}
    44e0:	08 95       	ret

000044e2 <_ZN6SX12786setCRCEbb>:
    offset = -164;
  }
  return(SX127x::getRSSI(packet, skipReceive, offset));
}

int16_t SX1278::setCRC(bool enable, bool mode) {
    44e2:	cf 92       	push	r12
    44e4:	ef 92       	push	r14
    44e6:	ff 92       	push	r15
    44e8:	0f 93       	push	r16
    44ea:	1f 93       	push	r17
    44ec:	cf 93       	push	r28
    44ee:	df 93       	push	r29
    44f0:	ec 01       	movw	r28, r24
    44f2:	16 2f       	mov	r17, r22
    44f4:	f4 2e       	mov	r15, r20
  if(getActiveModem() == RADIOLIB_SX127X_LORA) {
    44f6:	0e 94 ec 18 	call	0x31d8	; 0x31d8 <_ZN6SX127x14getActiveModemEv>
    44fa:	80 38       	cpi	r24, 0x80	; 128
    44fc:	91 05       	cpc	r25, r1
    44fe:	81 f1       	breq	.+96     	; 0x4560 <_ZN6SX12786setCRCEbb+0x7e>
      return(this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_MODEM_CONFIG_2, RADIOLIB_SX1278_RX_CRC_MODE_OFF, 2, 2));
    }
  } else {
    // set FSK CRC
    int16_t state = RADIOLIB_ERR_NONE;
    if(enable) {
    4500:	11 23       	and	r17, r17
    4502:	09 f4       	brne	.+2      	; 0x4506 <_ZN6SX12786setCRCEbb+0x24>
    4504:	55 c0       	rjmp	.+170    	; 0x45b0 <_ZN6SX12786setCRCEbb+0xce>
      state = this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_PACKET_CONFIG_1, RADIOLIB_SX127X_CRC_ON, 4, 4);
    4506:	cc 24       	eor	r12, r12
    4508:	ca 94       	dec	r12
    450a:	68 94       	set
    450c:	ee 24       	eor	r14, r14
    450e:	e1 f8       	bld	r14, 1
    4510:	04 e0       	ldi	r16, 0x04	; 4
    4512:	24 e0       	ldi	r18, 0x04	; 4
    4514:	40 e1       	ldi	r20, 0x10	; 16
    4516:	60 e3       	ldi	r22, 0x30	; 48
    4518:	70 e0       	ldi	r23, 0x00	; 0
    451a:	fe 01       	movw	r30, r28
    451c:	e7 5e       	subi	r30, 0xE7	; 231
    451e:	fe 4f       	sbci	r31, 0xFE	; 254
    4520:	80 81       	ld	r24, Z
    4522:	91 81       	ldd	r25, Z+1	; 0x01
    4524:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    } else {
      state = this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_PACKET_CONFIG_1, RADIOLIB_SX127X_CRC_OFF, 4, 4);
    }
    RADIOLIB_ASSERT(state);
    4528:	00 97       	sbiw	r24, 0x00	; 0
    452a:	91 f4       	brne	.+36     	; 0x4550 <_ZN6SX12786setCRCEbb+0x6e>

    // set FSK CRC mode
    if(mode) {
    452c:	f1 10       	cpse	r15, r1
    452e:	52 c0       	rjmp	.+164    	; 0x45d4 <_ZN6SX12786setCRCEbb+0xf2>
      return(this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_PACKET_CONFIG_1, RADIOLIB_SX127X_CRC_WHITENING_TYPE_IBM, 0, 0));
    } else {
      return(this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_PACKET_CONFIG_1, RADIOLIB_SX127X_CRC_WHITENING_TYPE_CCITT, 0, 0));
    4530:	c7 5e       	subi	r28, 0xE7	; 231
    4532:	de 4f       	sbci	r29, 0xFE	; 254
    4534:	cc 24       	eor	r12, r12
    4536:	ca 94       	dec	r12
    4538:	68 94       	set
    453a:	ee 24       	eor	r14, r14
    453c:	e1 f8       	bld	r14, 1
    453e:	00 e0       	ldi	r16, 0x00	; 0
    4540:	20 e0       	ldi	r18, 0x00	; 0
    4542:	40 e0       	ldi	r20, 0x00	; 0
    4544:	60 e3       	ldi	r22, 0x30	; 48
    4546:	70 e0       	ldi	r23, 0x00	; 0
    4548:	88 81       	ld	r24, Y
    454a:	99 81       	ldd	r25, Y+1	; 0x01
    454c:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    }
  }
}
    4550:	df 91       	pop	r29
    4552:	cf 91       	pop	r28
    4554:	1f 91       	pop	r17
    4556:	0f 91       	pop	r16
    4558:	ff 90       	pop	r15
    455a:	ef 90       	pop	r14
    455c:	cf 90       	pop	r12
    455e:	08 95       	ret
}

int16_t SX1278::setCRC(bool enable, bool mode) {
  if(getActiveModem() == RADIOLIB_SX127X_LORA) {
    // set LoRa CRC
    SX127x::crcEnabled = enable;
    4560:	fe 01       	movw	r30, r28
    4562:	e6 5d       	subi	r30, 0xD6	; 214
    4564:	fe 4f       	sbci	r31, 0xFE	; 254
    4566:	10 83       	st	Z, r17
    if(enable) {
    4568:	11 23       	and	r17, r17
    456a:	89 f0       	breq	.+34     	; 0x458e <_ZN6SX12786setCRCEbb+0xac>
      return(this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_MODEM_CONFIG_2, RADIOLIB_SX1278_RX_CRC_MODE_ON, 2, 2));
    456c:	c7 5e       	subi	r28, 0xE7	; 231
    456e:	de 4f       	sbci	r29, 0xFE	; 254
    4570:	cc 24       	eor	r12, r12
    4572:	ca 94       	dec	r12
    4574:	68 94       	set
    4576:	ee 24       	eor	r14, r14
    4578:	e1 f8       	bld	r14, 1
    457a:	02 e0       	ldi	r16, 0x02	; 2
    457c:	22 e0       	ldi	r18, 0x02	; 2
    457e:	44 e0       	ldi	r20, 0x04	; 4
    4580:	6e e1       	ldi	r22, 0x1E	; 30
    4582:	70 e0       	ldi	r23, 0x00	; 0
    4584:	88 81       	ld	r24, Y
    4586:	99 81       	ldd	r25, Y+1	; 0x01
    4588:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    458c:	e1 cf       	rjmp	.-62     	; 0x4550 <_ZN6SX12786setCRCEbb+0x6e>
    } else {
      return(this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_MODEM_CONFIG_2, RADIOLIB_SX1278_RX_CRC_MODE_OFF, 2, 2));
    458e:	c7 5e       	subi	r28, 0xE7	; 231
    4590:	de 4f       	sbci	r29, 0xFE	; 254
    4592:	cc 24       	eor	r12, r12
    4594:	ca 94       	dec	r12
    4596:	68 94       	set
    4598:	ee 24       	eor	r14, r14
    459a:	e1 f8       	bld	r14, 1
    459c:	02 e0       	ldi	r16, 0x02	; 2
    459e:	22 e0       	ldi	r18, 0x02	; 2
    45a0:	40 e0       	ldi	r20, 0x00	; 0
    45a2:	6e e1       	ldi	r22, 0x1E	; 30
    45a4:	70 e0       	ldi	r23, 0x00	; 0
    45a6:	88 81       	ld	r24, Y
    45a8:	99 81       	ldd	r25, Y+1	; 0x01
    45aa:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    45ae:	d0 cf       	rjmp	.-96     	; 0x4550 <_ZN6SX12786setCRCEbb+0x6e>
    // set FSK CRC
    int16_t state = RADIOLIB_ERR_NONE;
    if(enable) {
      state = this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_PACKET_CONFIG_1, RADIOLIB_SX127X_CRC_ON, 4, 4);
    } else {
      state = this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_PACKET_CONFIG_1, RADIOLIB_SX127X_CRC_OFF, 4, 4);
    45b0:	cc 24       	eor	r12, r12
    45b2:	ca 94       	dec	r12
    45b4:	68 94       	set
    45b6:	ee 24       	eor	r14, r14
    45b8:	e1 f8       	bld	r14, 1
    45ba:	04 e0       	ldi	r16, 0x04	; 4
    45bc:	24 e0       	ldi	r18, 0x04	; 4
    45be:	40 e0       	ldi	r20, 0x00	; 0
    45c0:	60 e3       	ldi	r22, 0x30	; 48
    45c2:	70 e0       	ldi	r23, 0x00	; 0
    45c4:	fe 01       	movw	r30, r28
    45c6:	e7 5e       	subi	r30, 0xE7	; 231
    45c8:	fe 4f       	sbci	r31, 0xFE	; 254
    45ca:	80 81       	ld	r24, Z
    45cc:	91 81       	ldd	r25, Z+1	; 0x01
    45ce:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    45d2:	aa cf       	rjmp	.-172    	; 0x4528 <_ZN6SX12786setCRCEbb+0x46>
    }
    RADIOLIB_ASSERT(state);

    // set FSK CRC mode
    if(mode) {
      return(this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_PACKET_CONFIG_1, RADIOLIB_SX127X_CRC_WHITENING_TYPE_IBM, 0, 0));
    45d4:	c7 5e       	subi	r28, 0xE7	; 231
    45d6:	de 4f       	sbci	r29, 0xFE	; 254
    45d8:	cc 24       	eor	r12, r12
    45da:	ca 94       	dec	r12
    45dc:	68 94       	set
    45de:	ee 24       	eor	r14, r14
    45e0:	e1 f8       	bld	r14, 1
    45e2:	00 e0       	ldi	r16, 0x00	; 0
    45e4:	20 e0       	ldi	r18, 0x00	; 0
    45e6:	41 e0       	ldi	r20, 0x01	; 1
    45e8:	60 e3       	ldi	r22, 0x30	; 48
    45ea:	70 e0       	ldi	r23, 0x00	; 0
    45ec:	88 81       	ld	r24, Y
    45ee:	99 81       	ldd	r25, Y+1	; 0x01
    45f0:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    45f4:	ad cf       	rjmp	.-166    	; 0x4550 <_ZN6SX12786setCRCEbb+0x6e>

000045f6 <_ZN6SX127817setDataShapingOOKEh>:
    default:
      return(RADIOLIB_ERR_INVALID_DATA_SHAPING);
  }
}

int16_t SX1278::setDataShapingOOK(uint8_t sh) {
    45f6:	af 92       	push	r10
    45f8:	bf 92       	push	r11
    45fa:	cf 92       	push	r12
    45fc:	ef 92       	push	r14
    45fe:	0f 93       	push	r16
    4600:	1f 93       	push	r17
    4602:	cf 93       	push	r28
    4604:	df 93       	push	r29
    4606:	ec 01       	movw	r28, r24
    4608:	16 2f       	mov	r17, r22
  // check active modem
  if(getActiveModem() != RADIOLIB_SX127X_FSK_OOK) {
    460a:	0e 94 ec 18 	call	0x31d8	; 0x31d8 <_ZN6SX127x14getActiveModemEv>
    460e:	89 2b       	or	r24, r25
    4610:	09 f0       	breq	.+2      	; 0x4614 <_ZN6SX127817setDataShapingOOKEh+0x1e>
    4612:	54 c0       	rjmp	.+168    	; 0x46bc <_ZN6SX127817setDataShapingOOKEh+0xc6>
    return(RADIOLIB_ERR_WRONG_MODEM);
  }

  // check modulation
  if(!SX127x::ookEnabled) {
    4614:	fe 01       	movw	r30, r28
    4616:	e7 5d       	subi	r30, 0xD7	; 215
    4618:	fe 4f       	sbci	r31, 0xFE	; 254
    461a:	80 81       	ld	r24, Z
    461c:	88 23       	and	r24, r24
    461e:	09 f4       	brne	.+2      	; 0x4622 <_ZN6SX127817setDataShapingOOKEh+0x2c>
    4620:	50 c0       	rjmp	.+160    	; 0x46c2 <_ZN6SX127817setDataShapingOOKEh+0xcc>
    return(RADIOLIB_ERR_INVALID_MODULATION);
  }

  // set mode to standby
  int16_t state = SX127x::standby();
    4622:	ce 01       	movw	r24, r28
    4624:	0e 94 82 1a 	call	0x3504	; 0x3504 <_ZN6SX127x7standbyEv>
    4628:	5c 01       	movw	r10, r24

  // set data shaping
  switch(sh) {
    462a:	11 30       	cpi	r17, 0x01	; 1
    462c:	09 f1       	breq	.+66     	; 0x4670 <_ZN6SX127817setDataShapingOOKEh+0x7a>
    462e:	68 f0       	brcs	.+26     	; 0x464a <_ZN6SX127817setDataShapingOOKEh+0x54>
    4630:	12 30       	cpi	r17, 0x02	; 2
    4632:	89 f1       	breq	.+98     	; 0x4696 <_ZN6SX127817setDataShapingOOKEh+0xa0>
      break;
    case 2:
      state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_PA_RAMP, RADIOLIB_SX1278_OOK_FILTER_2BR, 6, 5);
      break;
    default:
      return(RADIOLIB_ERR_INVALID_DATA_SHAPING);
    4634:	86 e9       	ldi	r24, 0x96	; 150
    4636:	9f ef       	ldi	r25, 0xFF	; 255
  }

  return(state);
}
    4638:	df 91       	pop	r29
    463a:	cf 91       	pop	r28
    463c:	1f 91       	pop	r17
    463e:	0f 91       	pop	r16
    4640:	ef 90       	pop	r14
    4642:	cf 90       	pop	r12
    4644:	bf 90       	pop	r11
    4646:	af 90       	pop	r10
    4648:	08 95       	ret
  int16_t state = SX127x::standby();

  // set data shaping
  switch(sh) {
    case 0:
      state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_PA_RAMP, RADIOLIB_SX1278_NO_SHAPING, 6, 5);
    464a:	c7 5e       	subi	r28, 0xE7	; 231
    464c:	de 4f       	sbci	r29, 0xFE	; 254
    464e:	cc 24       	eor	r12, r12
    4650:	ca 94       	dec	r12
    4652:	68 94       	set
    4654:	ee 24       	eor	r14, r14
    4656:	e1 f8       	bld	r14, 1
    4658:	05 e0       	ldi	r16, 0x05	; 5
    465a:	26 e0       	ldi	r18, 0x06	; 6
    465c:	40 e0       	ldi	r20, 0x00	; 0
    465e:	6a e0       	ldi	r22, 0x0A	; 10
    4660:	70 e0       	ldi	r23, 0x00	; 0
    4662:	88 81       	ld	r24, Y
    4664:	99 81       	ldd	r25, Y+1	; 0x01
    4666:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    466a:	8a 29       	or	r24, r10
    466c:	9b 29       	or	r25, r11
    466e:	e4 cf       	rjmp	.-56     	; 0x4638 <_ZN6SX127817setDataShapingOOKEh+0x42>
      break;
    case 1:
      state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_PA_RAMP, RADIOLIB_SX1278_OOK_FILTER_BR, 6, 5);
    4670:	c7 5e       	subi	r28, 0xE7	; 231
    4672:	de 4f       	sbci	r29, 0xFE	; 254
    4674:	cc 24       	eor	r12, r12
    4676:	ca 94       	dec	r12
    4678:	68 94       	set
    467a:	ee 24       	eor	r14, r14
    467c:	e1 f8       	bld	r14, 1
    467e:	05 e0       	ldi	r16, 0x05	; 5
    4680:	26 e0       	ldi	r18, 0x06	; 6
    4682:	40 e2       	ldi	r20, 0x20	; 32
    4684:	6a e0       	ldi	r22, 0x0A	; 10
    4686:	70 e0       	ldi	r23, 0x00	; 0
    4688:	88 81       	ld	r24, Y
    468a:	99 81       	ldd	r25, Y+1	; 0x01
    468c:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    4690:	8a 29       	or	r24, r10
    4692:	9b 29       	or	r25, r11
    4694:	d1 cf       	rjmp	.-94     	; 0x4638 <_ZN6SX127817setDataShapingOOKEh+0x42>
      break;
    case 2:
      state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_PA_RAMP, RADIOLIB_SX1278_OOK_FILTER_2BR, 6, 5);
    4696:	c7 5e       	subi	r28, 0xE7	; 231
    4698:	de 4f       	sbci	r29, 0xFE	; 254
    469a:	cc 24       	eor	r12, r12
    469c:	ca 94       	dec	r12
    469e:	68 94       	set
    46a0:	ee 24       	eor	r14, r14
    46a2:	e1 f8       	bld	r14, 1
    46a4:	05 e0       	ldi	r16, 0x05	; 5
    46a6:	26 e0       	ldi	r18, 0x06	; 6
    46a8:	40 e4       	ldi	r20, 0x40	; 64
    46aa:	6a e0       	ldi	r22, 0x0A	; 10
    46ac:	70 e0       	ldi	r23, 0x00	; 0
    46ae:	88 81       	ld	r24, Y
    46b0:	99 81       	ldd	r25, Y+1	; 0x01
    46b2:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    46b6:	8a 29       	or	r24, r10
    46b8:	9b 29       	or	r25, r11
    46ba:	be cf       	rjmp	.-132    	; 0x4638 <_ZN6SX127817setDataShapingOOKEh+0x42>
}

int16_t SX1278::setDataShapingOOK(uint8_t sh) {
  // check active modem
  if(getActiveModem() != RADIOLIB_SX127X_FSK_OOK) {
    return(RADIOLIB_ERR_WRONG_MODEM);
    46bc:	8c ee       	ldi	r24, 0xEC	; 236
    46be:	9f ef       	ldi	r25, 0xFF	; 255
    46c0:	bb cf       	rjmp	.-138    	; 0x4638 <_ZN6SX127817setDataShapingOOKEh+0x42>
  }

  // check modulation
  if(!SX127x::ookEnabled) {
    return(RADIOLIB_ERR_INVALID_MODULATION);
    46c2:	85 e9       	ldi	r24, 0x95	; 149
    46c4:	9f ef       	ldi	r25, 0xFF	; 255
    46c6:	b8 cf       	rjmp	.-144    	; 0x4638 <_ZN6SX127817setDataShapingOOKEh+0x42>

000046c8 <_ZN6SX127814setDataShapingEh>:
  }

  return(state);
}

int16_t SX1278::setDataShaping(uint8_t sh) {
    46c8:	cf 92       	push	r12
    46ca:	ef 92       	push	r14
    46cc:	0f 93       	push	r16
    46ce:	1f 93       	push	r17
    46d0:	cf 93       	push	r28
    46d2:	df 93       	push	r29
    46d4:	ec 01       	movw	r28, r24
    46d6:	16 2f       	mov	r17, r22
  // check active modem
  if(getActiveModem() != RADIOLIB_SX127X_FSK_OOK) {
    46d8:	0e 94 ec 18 	call	0x31d8	; 0x31d8 <_ZN6SX127x14getActiveModemEv>
    46dc:	89 2b       	or	r24, r25
    46de:	09 f0       	breq	.+2      	; 0x46e2 <_ZN6SX127814setDataShapingEh+0x1a>
    46e0:	66 c0       	rjmp	.+204    	; 0x47ae <_ZN6SX127814setDataShapingEh+0xe6>
    return(RADIOLIB_ERR_WRONG_MODEM);
  }

  // check modulation
  if(SX127x::ookEnabled) {
    46e2:	fe 01       	movw	r30, r28
    46e4:	e7 5d       	subi	r30, 0xD7	; 215
    46e6:	fe 4f       	sbci	r31, 0xFE	; 254
    46e8:	80 81       	ld	r24, Z
    46ea:	88 23       	and	r24, r24
    46ec:	69 f0       	breq	.+26     	; 0x4708 <_ZN6SX127814setDataShapingEh+0x40>
    // we're in OOK mode, the only thing we can do is disable
    if(sh == RADIOLIB_SHAPING_NONE) {
    46ee:	11 11       	cpse	r17, r1
    46f0:	61 c0       	rjmp	.+194    	; 0x47b4 <_ZN6SX127814setDataShapingEh+0xec>
      return(setDataShapingOOK(0));
    46f2:	60 e0       	ldi	r22, 0x00	; 0
    46f4:	ce 01       	movw	r24, r28
    46f6:	0e 94 fb 22 	call	0x45f6	; 0x45f6 <_ZN6SX127817setDataShapingOOKEh>
    case RADIOLIB_SHAPING_1_0:
      return(this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_PA_RAMP, RADIOLIB_SX1278_FSK_GAUSSIAN_1_0, 6, 5));
    default:
      return(RADIOLIB_ERR_INVALID_DATA_SHAPING);
  }
}
    46fa:	df 91       	pop	r29
    46fc:	cf 91       	pop	r28
    46fe:	1f 91       	pop	r17
    4700:	0f 91       	pop	r16
    4702:	ef 90       	pop	r14
    4704:	cf 90       	pop	r12
    4706:	08 95       	ret

    return(RADIOLIB_ERR_INVALID_MODULATION);
  }

  // set mode to standby
  int16_t state = SX127x::standby();
    4708:	ce 01       	movw	r24, r28
    470a:	0e 94 82 1a 	call	0x3504	; 0x3504 <_ZN6SX127x7standbyEv>
  RADIOLIB_ASSERT(state);
    470e:	00 97       	sbiw	r24, 0x00	; 0
    4710:	a1 f7       	brne	.-24     	; 0x46fa <_ZN6SX127814setDataShapingEh+0x32>

  // set data shaping
  switch(sh) {
    4712:	11 30       	cpi	r17, 0x01	; 1
    4714:	c9 f0       	breq	.+50     	; 0x4748 <_ZN6SX127814setDataShapingEh+0x80>
    4716:	38 f0       	brcs	.+14     	; 0x4726 <_ZN6SX127814setDataShapingEh+0x5e>
    4718:	12 30       	cpi	r17, 0x02	; 2
    471a:	39 f1       	breq	.+78     	; 0x476a <_ZN6SX127814setDataShapingEh+0xa2>
    471c:	14 30       	cpi	r17, 0x04	; 4
    471e:	b1 f1       	breq	.+108    	; 0x478c <_ZN6SX127814setDataShapingEh+0xc4>
    case RADIOLIB_SHAPING_0_5:
      return(this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_PA_RAMP, RADIOLIB_SX1278_FSK_GAUSSIAN_0_5, 6, 5));
    case RADIOLIB_SHAPING_1_0:
      return(this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_PA_RAMP, RADIOLIB_SX1278_FSK_GAUSSIAN_1_0, 6, 5));
    default:
      return(RADIOLIB_ERR_INVALID_DATA_SHAPING);
    4720:	86 e9       	ldi	r24, 0x96	; 150
    4722:	9f ef       	ldi	r25, 0xFF	; 255
    4724:	ea cf       	rjmp	.-44     	; 0x46fa <_ZN6SX127814setDataShapingEh+0x32>
  RADIOLIB_ASSERT(state);

  // set data shaping
  switch(sh) {
    case RADIOLIB_SHAPING_NONE:
      return(this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_PA_RAMP, RADIOLIB_SX1278_NO_SHAPING, 6, 5));
    4726:	c7 5e       	subi	r28, 0xE7	; 231
    4728:	de 4f       	sbci	r29, 0xFE	; 254
    472a:	cc 24       	eor	r12, r12
    472c:	ca 94       	dec	r12
    472e:	68 94       	set
    4730:	ee 24       	eor	r14, r14
    4732:	e1 f8       	bld	r14, 1
    4734:	05 e0       	ldi	r16, 0x05	; 5
    4736:	26 e0       	ldi	r18, 0x06	; 6
    4738:	40 e0       	ldi	r20, 0x00	; 0
    473a:	6a e0       	ldi	r22, 0x0A	; 10
    473c:	70 e0       	ldi	r23, 0x00	; 0
    473e:	88 81       	ld	r24, Y
    4740:	99 81       	ldd	r25, Y+1	; 0x01
    4742:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    4746:	d9 cf       	rjmp	.-78     	; 0x46fa <_ZN6SX127814setDataShapingEh+0x32>
    case RADIOLIB_SHAPING_0_3:
      return(this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_PA_RAMP, RADIOLIB_SX1278_FSK_GAUSSIAN_0_3, 6, 5));
    4748:	c7 5e       	subi	r28, 0xE7	; 231
    474a:	de 4f       	sbci	r29, 0xFE	; 254
    474c:	cc 24       	eor	r12, r12
    474e:	ca 94       	dec	r12
    4750:	68 94       	set
    4752:	ee 24       	eor	r14, r14
    4754:	e1 f8       	bld	r14, 1
    4756:	05 e0       	ldi	r16, 0x05	; 5
    4758:	26 e0       	ldi	r18, 0x06	; 6
    475a:	40 e6       	ldi	r20, 0x60	; 96
    475c:	6a e0       	ldi	r22, 0x0A	; 10
    475e:	70 e0       	ldi	r23, 0x00	; 0
    4760:	88 81       	ld	r24, Y
    4762:	99 81       	ldd	r25, Y+1	; 0x01
    4764:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    4768:	c8 cf       	rjmp	.-112    	; 0x46fa <_ZN6SX127814setDataShapingEh+0x32>
    case RADIOLIB_SHAPING_0_5:
      return(this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_PA_RAMP, RADIOLIB_SX1278_FSK_GAUSSIAN_0_5, 6, 5));
    476a:	c7 5e       	subi	r28, 0xE7	; 231
    476c:	de 4f       	sbci	r29, 0xFE	; 254
    476e:	cc 24       	eor	r12, r12
    4770:	ca 94       	dec	r12
    4772:	68 94       	set
    4774:	ee 24       	eor	r14, r14
    4776:	e1 f8       	bld	r14, 1
    4778:	05 e0       	ldi	r16, 0x05	; 5
    477a:	26 e0       	ldi	r18, 0x06	; 6
    477c:	40 e4       	ldi	r20, 0x40	; 64
    477e:	6a e0       	ldi	r22, 0x0A	; 10
    4780:	70 e0       	ldi	r23, 0x00	; 0
    4782:	88 81       	ld	r24, Y
    4784:	99 81       	ldd	r25, Y+1	; 0x01
    4786:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    478a:	b7 cf       	rjmp	.-146    	; 0x46fa <_ZN6SX127814setDataShapingEh+0x32>
    case RADIOLIB_SHAPING_1_0:
      return(this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_PA_RAMP, RADIOLIB_SX1278_FSK_GAUSSIAN_1_0, 6, 5));
    478c:	c7 5e       	subi	r28, 0xE7	; 231
    478e:	de 4f       	sbci	r29, 0xFE	; 254
    4790:	cc 24       	eor	r12, r12
    4792:	ca 94       	dec	r12
    4794:	68 94       	set
    4796:	ee 24       	eor	r14, r14
    4798:	e1 f8       	bld	r14, 1
    479a:	05 e0       	ldi	r16, 0x05	; 5
    479c:	26 e0       	ldi	r18, 0x06	; 6
    479e:	40 e2       	ldi	r20, 0x20	; 32
    47a0:	6a e0       	ldi	r22, 0x0A	; 10
    47a2:	70 e0       	ldi	r23, 0x00	; 0
    47a4:	88 81       	ld	r24, Y
    47a6:	99 81       	ldd	r25, Y+1	; 0x01
    47a8:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    47ac:	a6 cf       	rjmp	.-180    	; 0x46fa <_ZN6SX127814setDataShapingEh+0x32>
}

int16_t SX1278::setDataShaping(uint8_t sh) {
  // check active modem
  if(getActiveModem() != RADIOLIB_SX127X_FSK_OOK) {
    return(RADIOLIB_ERR_WRONG_MODEM);
    47ae:	8c ee       	ldi	r24, 0xEC	; 236
    47b0:	9f ef       	ldi	r25, 0xFF	; 255
    47b2:	a3 cf       	rjmp	.-186    	; 0x46fa <_ZN6SX127814setDataShapingEh+0x32>
    // we're in OOK mode, the only thing we can do is disable
    if(sh == RADIOLIB_SHAPING_NONE) {
      return(setDataShapingOOK(0));
    }

    return(RADIOLIB_ERR_INVALID_MODULATION);
    47b4:	85 e9       	ldi	r24, 0x95	; 149
    47b6:	9f ef       	ldi	r25, 0xFF	; 255
    47b8:	a0 cf       	rjmp	.-192    	; 0x46fa <_ZN6SX127814setDataShapingEh+0x32>

000047ba <_ZN6SX12787setGainEh>:
  }

  return(state);
}

int16_t SX1278::setGain(uint8_t gain) {
    47ba:	af 92       	push	r10
    47bc:	bf 92       	push	r11
    47be:	cf 92       	push	r12
    47c0:	ef 92       	push	r14
    47c2:	0f 93       	push	r16
    47c4:	1f 93       	push	r17
    47c6:	cf 93       	push	r28
    47c8:	df 93       	push	r29
  // check allowed range
  if(gain > 6) {
    47ca:	67 30       	cpi	r22, 0x07	; 7
    47cc:	08 f0       	brcs	.+2      	; 0x47d0 <_ZN6SX12787setGainEh+0x16>
    47ce:	85 c0       	rjmp	.+266    	; 0x48da <_ZN6SX12787setGainEh+0x120>
    47d0:	16 2f       	mov	r17, r22
    47d2:	ec 01       	movw	r28, r24
    return(RADIOLIB_ERR_INVALID_GAIN);
  }

  // set mode to standby
  int16_t state = SX127x::standby();
    47d4:	0e 94 82 1a 	call	0x3504	; 0x3504 <_ZN6SX127x7standbyEv>
    47d8:	5c 01       	movw	r10, r24

  // get modem
  int16_t modem = getActiveModem();
    47da:	ce 01       	movw	r24, r28
    47dc:	0e 94 ec 18 	call	0x31d8	; 0x31d8 <_ZN6SX127x14getActiveModemEv>
  if(modem == RADIOLIB_SX127X_LORA){
    47e0:	80 38       	cpi	r24, 0x80	; 128
    47e2:	91 05       	cpc	r25, r1
    47e4:	81 f1       	breq	.+96     	; 0x4846 <_ZN6SX12787setGainEh+0x8c>
    } else {
      state |= this->mod->SPIsetRegValue(RADIOLIB_SX1278_REG_MODEM_CONFIG_3, RADIOLIB_SX1278_AGC_AUTO_OFF, 2, 2);
      state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_LNA, (gain << 5) | RADIOLIB_SX127X_LNA_BOOST_ON);
    }

  } else if(modem == RADIOLIB_SX127X_FSK_OOK) {
    47e6:	89 2b       	or	r24, r25
    47e8:	21 f5       	brne	.+72     	; 0x4832 <_ZN6SX12787setGainEh+0x78>
    // set gain
    if(gain == 0) {
    47ea:	11 23       	and	r17, r17
    47ec:	09 f4       	brne	.+2      	; 0x47f0 <_ZN6SX12787setGainEh+0x36>
    47ee:	62 c0       	rjmp	.+196    	; 0x48b4 <_ZN6SX12787setGainEh+0xfa>
      // gain set to 0, enable AGC loop
      state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_RX_CONFIG, RADIOLIB_SX127X_AGC_AUTO_ON, 3, 3);
    } else {
      state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_RX_CONFIG, RADIOLIB_SX1278_AGC_AUTO_OFF, 3, 3);
    47f0:	c7 5e       	subi	r28, 0xE7	; 231
    47f2:	de 4f       	sbci	r29, 0xFE	; 254
    47f4:	cc 24       	eor	r12, r12
    47f6:	ca 94       	dec	r12
    47f8:	68 94       	set
    47fa:	ee 24       	eor	r14, r14
    47fc:	e1 f8       	bld	r14, 1
    47fe:	03 e0       	ldi	r16, 0x03	; 3
    4800:	23 e0       	ldi	r18, 0x03	; 3
    4802:	40 e0       	ldi	r20, 0x00	; 0
    4804:	6d e0       	ldi	r22, 0x0D	; 13
    4806:	70 e0       	ldi	r23, 0x00	; 0
    4808:	88 81       	ld	r24, Y
    480a:	99 81       	ldd	r25, Y+1	; 0x01
    480c:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    4810:	a8 2a       	or	r10, r24
    4812:	b9 2a       	or	r11, r25
      state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_LNA, (gain << 5) | RADIOLIB_SX127X_LNA_BOOST_ON);
    4814:	80 e2       	ldi	r24, 0x20	; 32
    4816:	18 9f       	mul	r17, r24
    4818:	a0 01       	movw	r20, r0
    481a:	11 24       	eor	r1, r1
    481c:	43 60       	ori	r20, 0x03	; 3
    481e:	00 e0       	ldi	r16, 0x00	; 0
    4820:	27 e0       	ldi	r18, 0x07	; 7
    4822:	6c e0       	ldi	r22, 0x0C	; 12
    4824:	70 e0       	ldi	r23, 0x00	; 0
    4826:	88 81       	ld	r24, Y
    4828:	99 81       	ldd	r25, Y+1	; 0x01
    482a:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    482e:	a8 2a       	or	r10, r24
    4830:	b9 2a       	or	r11, r25
    }

  }

  return(state);
}
    4832:	c5 01       	movw	r24, r10
    4834:	df 91       	pop	r29
    4836:	cf 91       	pop	r28
    4838:	1f 91       	pop	r17
    483a:	0f 91       	pop	r16
    483c:	ef 90       	pop	r14
    483e:	cf 90       	pop	r12
    4840:	bf 90       	pop	r11
    4842:	af 90       	pop	r10
    4844:	08 95       	ret

  // get modem
  int16_t modem = getActiveModem();
  if(modem == RADIOLIB_SX127X_LORA){
    // set gain
    if(gain == 0) {
    4846:	11 11       	cpse	r17, r1
    4848:	13 c0       	rjmp	.+38     	; 0x4870 <_ZN6SX12787setGainEh+0xb6>
      // gain set to 0, enable AGC loop
      state |= this->mod->SPIsetRegValue(RADIOLIB_SX1278_REG_MODEM_CONFIG_3, RADIOLIB_SX1278_AGC_AUTO_ON, 2, 2);
    484a:	c7 5e       	subi	r28, 0xE7	; 231
    484c:	de 4f       	sbci	r29, 0xFE	; 254
    484e:	cc 24       	eor	r12, r12
    4850:	ca 94       	dec	r12
    4852:	68 94       	set
    4854:	ee 24       	eor	r14, r14
    4856:	e1 f8       	bld	r14, 1
    4858:	02 e0       	ldi	r16, 0x02	; 2
    485a:	22 e0       	ldi	r18, 0x02	; 2
    485c:	44 e0       	ldi	r20, 0x04	; 4
    485e:	66 e2       	ldi	r22, 0x26	; 38
    4860:	70 e0       	ldi	r23, 0x00	; 0
    4862:	88 81       	ld	r24, Y
    4864:	99 81       	ldd	r25, Y+1	; 0x01
    4866:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    486a:	a8 2a       	or	r10, r24
    486c:	b9 2a       	or	r11, r25
    486e:	e1 cf       	rjmp	.-62     	; 0x4832 <_ZN6SX12787setGainEh+0x78>
    } else {
      state |= this->mod->SPIsetRegValue(RADIOLIB_SX1278_REG_MODEM_CONFIG_3, RADIOLIB_SX1278_AGC_AUTO_OFF, 2, 2);
    4870:	c7 5e       	subi	r28, 0xE7	; 231
    4872:	de 4f       	sbci	r29, 0xFE	; 254
    4874:	cc 24       	eor	r12, r12
    4876:	ca 94       	dec	r12
    4878:	68 94       	set
    487a:	ee 24       	eor	r14, r14
    487c:	e1 f8       	bld	r14, 1
    487e:	02 e0       	ldi	r16, 0x02	; 2
    4880:	22 e0       	ldi	r18, 0x02	; 2
    4882:	40 e0       	ldi	r20, 0x00	; 0
    4884:	66 e2       	ldi	r22, 0x26	; 38
    4886:	70 e0       	ldi	r23, 0x00	; 0
    4888:	88 81       	ld	r24, Y
    488a:	99 81       	ldd	r25, Y+1	; 0x01
    488c:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    4890:	a8 2a       	or	r10, r24
    4892:	b9 2a       	or	r11, r25
      state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_LNA, (gain << 5) | RADIOLIB_SX127X_LNA_BOOST_ON);
    4894:	80 e2       	ldi	r24, 0x20	; 32
    4896:	18 9f       	mul	r17, r24
    4898:	a0 01       	movw	r20, r0
    489a:	11 24       	eor	r1, r1
    489c:	43 60       	ori	r20, 0x03	; 3
    489e:	00 e0       	ldi	r16, 0x00	; 0
    48a0:	27 e0       	ldi	r18, 0x07	; 7
    48a2:	6c e0       	ldi	r22, 0x0C	; 12
    48a4:	70 e0       	ldi	r23, 0x00	; 0
    48a6:	88 81       	ld	r24, Y
    48a8:	99 81       	ldd	r25, Y+1	; 0x01
    48aa:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    48ae:	a8 2a       	or	r10, r24
    48b0:	b9 2a       	or	r11, r25
    48b2:	bf cf       	rjmp	.-130    	; 0x4832 <_ZN6SX12787setGainEh+0x78>

  } else if(modem == RADIOLIB_SX127X_FSK_OOK) {
    // set gain
    if(gain == 0) {
      // gain set to 0, enable AGC loop
      state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_RX_CONFIG, RADIOLIB_SX127X_AGC_AUTO_ON, 3, 3);
    48b4:	c7 5e       	subi	r28, 0xE7	; 231
    48b6:	de 4f       	sbci	r29, 0xFE	; 254
    48b8:	cc 24       	eor	r12, r12
    48ba:	ca 94       	dec	r12
    48bc:	68 94       	set
    48be:	ee 24       	eor	r14, r14
    48c0:	e1 f8       	bld	r14, 1
    48c2:	03 e0       	ldi	r16, 0x03	; 3
    48c4:	23 e0       	ldi	r18, 0x03	; 3
    48c6:	48 e0       	ldi	r20, 0x08	; 8
    48c8:	6d e0       	ldi	r22, 0x0D	; 13
    48ca:	70 e0       	ldi	r23, 0x00	; 0
    48cc:	88 81       	ld	r24, Y
    48ce:	99 81       	ldd	r25, Y+1	; 0x01
    48d0:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    48d4:	a8 2a       	or	r10, r24
    48d6:	b9 2a       	or	r11, r25
    48d8:	ac cf       	rjmp	.-168    	; 0x4832 <_ZN6SX12787setGainEh+0x78>
}

int16_t SX1278::setGain(uint8_t gain) {
  // check allowed range
  if(gain > 6) {
    return(RADIOLIB_ERR_INVALID_GAIN);
    48da:	0f 2e       	mov	r0, r31
    48dc:	fd ee       	ldi	r31, 0xED	; 237
    48de:	af 2e       	mov	r10, r31
    48e0:	bb 24       	eor	r11, r11
    48e2:	ba 94       	dec	r11
    48e4:	f0 2d       	mov	r31, r0
    48e6:	a5 cf       	rjmp	.-182    	; 0x4832 <_ZN6SX12787setGainEh+0x78>

000048e8 <_ZN6SX127813setCodingRateEh>:
    }
  }
  return(state);
}

int16_t SX1278::setCodingRate(uint8_t cr) {
    48e8:	0f 93       	push	r16
    48ea:	1f 93       	push	r17
    48ec:	cf 93       	push	r28
    48ee:	8c 01       	movw	r16, r24
    48f0:	c6 2f       	mov	r28, r22
  // check active modem
  if(getActiveModem() != RADIOLIB_SX127X_LORA) {
    48f2:	0e 94 ec 18 	call	0x31d8	; 0x31d8 <_ZN6SX127x14getActiveModemEv>
    48f6:	80 38       	cpi	r24, 0x80	; 128
    48f8:	91 05       	cpc	r25, r1
    48fa:	e9 f4       	brne	.+58     	; 0x4936 <_ZN6SX127813setCodingRateEh+0x4e>
  }

  uint8_t newCodingRate;

  // check allowed coding rate values
  switch(cr) {
    48fc:	c6 30       	cpi	r28, 0x06	; 6
    48fe:	c9 f0       	breq	.+50     	; 0x4932 <_ZN6SX127813setCodingRateEh+0x4a>
    4900:	30 f0       	brcs	.+12     	; 0x490e <_ZN6SX127813setCodingRateEh+0x26>
    4902:	c7 30       	cpi	r28, 0x07	; 7
    4904:	a1 f0       	breq	.+40     	; 0x492e <_ZN6SX127813setCodingRateEh+0x46>
    4906:	c8 30       	cpi	r28, 0x08	; 8
    4908:	c9 f4       	brne	.+50     	; 0x493c <_ZN6SX127813setCodingRateEh+0x54>
      break;
    case 7:
      newCodingRate = RADIOLIB_SX1278_CR_4_7;
      break;
    case 8:
      newCodingRate = RADIOLIB_SX1278_CR_4_8;
    490a:	6c 2f       	mov	r22, r28
    490c:	03 c0       	rjmp	.+6      	; 0x4914 <_ZN6SX127813setCodingRateEh+0x2c>
  }

  uint8_t newCodingRate;

  // check allowed coding rate values
  switch(cr) {
    490e:	c5 30       	cpi	r28, 0x05	; 5
    4910:	a9 f4       	brne	.+42     	; 0x493c <_ZN6SX127813setCodingRateEh+0x54>
    case 5:
      newCodingRate = RADIOLIB_SX1278_CR_4_5;
    4912:	62 e0       	ldi	r22, 0x02	; 2
    default:
      return(RADIOLIB_ERR_INVALID_CODING_RATE);
  }

  // set coding rate and if successful, save the new setting
  int16_t state = SX1278::setCodingRateRaw(newCodingRate);
    4914:	c8 01       	movw	r24, r16
    4916:	0e 94 fc 1a 	call	0x35f8	; 0x35f8 <_ZN6SX127816setCodingRateRawEh>
  if(state == RADIOLIB_ERR_NONE) {
    491a:	00 97       	sbiw	r24, 0x00	; 0
    491c:	21 f4       	brne	.+8      	; 0x4926 <_ZN6SX127813setCodingRateEh+0x3e>
    SX127x::codingRate = cr;
    491e:	f8 01       	movw	r30, r16
    4920:	ec 5d       	subi	r30, 0xDC	; 220
    4922:	fe 4f       	sbci	r31, 0xFE	; 254
    4924:	c0 83       	st	Z, r28
  }
  return(state);
}
    4926:	cf 91       	pop	r28
    4928:	1f 91       	pop	r17
    492a:	0f 91       	pop	r16
    492c:	08 95       	ret
      break;
    case 6:
      newCodingRate = RADIOLIB_SX1278_CR_4_6;
      break;
    case 7:
      newCodingRate = RADIOLIB_SX1278_CR_4_7;
    492e:	66 e0       	ldi	r22, 0x06	; 6
    4930:	f1 cf       	rjmp	.-30     	; 0x4914 <_ZN6SX127813setCodingRateEh+0x2c>
  switch(cr) {
    case 5:
      newCodingRate = RADIOLIB_SX1278_CR_4_5;
      break;
    case 6:
      newCodingRate = RADIOLIB_SX1278_CR_4_6;
    4932:	64 e0       	ldi	r22, 0x04	; 4
    4934:	ef cf       	rjmp	.-34     	; 0x4914 <_ZN6SX127813setCodingRateEh+0x2c>
}

int16_t SX1278::setCodingRate(uint8_t cr) {
  // check active modem
  if(getActiveModem() != RADIOLIB_SX127X_LORA) {
    return(RADIOLIB_ERR_WRONG_MODEM);
    4936:	8c ee       	ldi	r24, 0xEC	; 236
    4938:	9f ef       	ldi	r25, 0xFF	; 255
    493a:	f5 cf       	rjmp	.-22     	; 0x4926 <_ZN6SX127813setCodingRateEh+0x3e>
      break;
    case 8:
      newCodingRate = RADIOLIB_SX1278_CR_4_8;
      break;
    default:
      return(RADIOLIB_ERR_INVALID_CODING_RATE);
    493c:	86 ef       	ldi	r24, 0xF6	; 246
    493e:	9f ef       	ldi	r25, 0xFF	; 255
    4940:	f2 cf       	rjmp	.-28     	; 0x4926 <_ZN6SX127813setCodingRateEh+0x3e>

00004942 <_ZN6SX127818setSpreadingFactorEh>:
    }
  }
  return(state);
}

int16_t SX1278::setSpreadingFactor(uint8_t sf) {
    4942:	cf 92       	push	r12
    4944:	ef 92       	push	r14
    4946:	0f 93       	push	r16
    4948:	1f 93       	push	r17
    494a:	cf 93       	push	r28
    494c:	df 93       	push	r29
    494e:	ec 01       	movw	r28, r24
    4950:	16 2f       	mov	r17, r22
  // check active modem
  if(getActiveModem() != RADIOLIB_SX127X_LORA) {
    4952:	0e 94 ec 18 	call	0x31d8	; 0x31d8 <_ZN6SX127x14getActiveModemEv>
    4956:	80 38       	cpi	r24, 0x80	; 128
    4958:	91 05       	cpc	r25, r1
    495a:	09 f0       	breq	.+2      	; 0x495e <_ZN6SX127818setSpreadingFactorEh+0x1c>
    495c:	71 c0       	rjmp	.+226    	; 0x4a40 <_ZN6SX127818setSpreadingFactorEh+0xfe>
  }

  uint8_t newSpreadingFactor;

  // check allowed spreading factor values
  switch(sf) {
    495e:	ea ef       	ldi	r30, 0xFA	; 250
    4960:	e1 0f       	add	r30, r17
    4962:	e7 30       	cpi	r30, 0x07	; 7
    4964:	08 f0       	brcs	.+2      	; 0x4968 <_ZN6SX127818setSpreadingFactorEh+0x26>
    4966:	6f c0       	rjmp	.+222    	; 0x4a46 <_ZN6SX127818setSpreadingFactorEh+0x104>
    4968:	f0 e0       	ldi	r31, 0x00	; 0
    496a:	e7 54       	subi	r30, 0x47	; 71
    496c:	fb 4d       	sbci	r31, 0xDB	; 219
    496e:	0c 94 51 3b 	jmp	0x76a2	; 0x76a2 <__tablejump2__>
    4972:	c0 24       	eor	r12, r0
    4974:	cc 24       	eor	r12, r12
    4976:	c2 24       	eor	r12, r2
    4978:	c4 24       	eor	r12, r4
    497a:	c6 24       	eor	r12, r6
    497c:	c8 24       	eor	r12, r8
    497e:	ca 24       	eor	r12, r10
    case 6:
      newSpreadingFactor = RADIOLIB_SX127X_SF_6;
    4980:	60 e6       	ldi	r22, 0x60	; 96
    4982:	0b c0       	rjmp	.+22     	; 0x499a <_ZN6SX127818setSpreadingFactorEh+0x58>
      break;
    case 7:
      newSpreadingFactor = RADIOLIB_SX127X_SF_7;
      break;
    case 8:
      newSpreadingFactor = RADIOLIB_SX127X_SF_8;
    4984:	60 e8       	ldi	r22, 0x80	; 128
    4986:	09 c0       	rjmp	.+18     	; 0x499a <_ZN6SX127818setSpreadingFactorEh+0x58>
      break;
    case 9:
      newSpreadingFactor = RADIOLIB_SX127X_SF_9;
    4988:	60 e9       	ldi	r22, 0x90	; 144
    498a:	07 c0       	rjmp	.+14     	; 0x499a <_ZN6SX127818setSpreadingFactorEh+0x58>
      break;
    case 10:
      newSpreadingFactor = RADIOLIB_SX127X_SF_10;
    498c:	60 ea       	ldi	r22, 0xA0	; 160
    498e:	05 c0       	rjmp	.+10     	; 0x499a <_ZN6SX127818setSpreadingFactorEh+0x58>
      break;
    case 11:
      newSpreadingFactor = RADIOLIB_SX127X_SF_11;
    4990:	60 eb       	ldi	r22, 0xB0	; 176
    4992:	03 c0       	rjmp	.+6      	; 0x499a <_ZN6SX127818setSpreadingFactorEh+0x58>
      break;
    case 12:
      newSpreadingFactor = RADIOLIB_SX127X_SF_12;
    4994:	60 ec       	ldi	r22, 0xC0	; 192
    4996:	01 c0       	rjmp	.+2      	; 0x499a <_ZN6SX127818setSpreadingFactorEh+0x58>
  switch(sf) {
    case 6:
      newSpreadingFactor = RADIOLIB_SX127X_SF_6;
      break;
    case 7:
      newSpreadingFactor = RADIOLIB_SX127X_SF_7;
    4998:	60 e7       	ldi	r22, 0x70	; 112
    default:
      return(RADIOLIB_ERR_INVALID_SPREADING_FACTOR);
  }

  // set spreading factor and if successful, save the new setting
  int16_t state = SX1278::setSpreadingFactorRaw(newSpreadingFactor);
    499a:	ce 01       	movw	r24, r28
    499c:	0e 94 24 1b 	call	0x3648	; 0x3648 <_ZN6SX127821setSpreadingFactorRawEh>
  if(state == RADIOLIB_ERR_NONE) {
    49a0:	00 97       	sbiw	r24, 0x00	; 0
    49a2:	b1 f5       	brne	.+108    	; 0x4a10 <_ZN6SX127818setSpreadingFactorEh+0xce>
    SX127x::spreadingFactor = sf;
    49a4:	fe 01       	movw	r30, r28
    49a6:	ed 5d       	subi	r30, 0xDD	; 221
    49a8:	fe 4f       	sbci	r31, 0xFE	; 254
    49aa:	10 83       	st	Z, r17

    // calculate symbol length and set low data rate optimization, if auto-configuration is enabled
    if(this->ldroAuto) {
    49ac:	71 96       	adiw	r30, 0x11	; 17
    49ae:	20 81       	ld	r18, Z
    49b0:	22 23       	and	r18, r18
    49b2:	71 f1       	breq	.+92     	; 0x4a10 <_ZN6SX127818setSpreadingFactorEh+0xce>
      float symbolLength = (float)(uint32_t(1) << SX127x::spreadingFactor) / (float)SX127x::bandwidth;
    49b4:	61 e0       	ldi	r22, 0x01	; 1
    49b6:	70 e0       	ldi	r23, 0x00	; 0
    49b8:	80 e0       	ldi	r24, 0x00	; 0
    49ba:	90 e0       	ldi	r25, 0x00	; 0
    49bc:	04 c0       	rjmp	.+8      	; 0x49c6 <_ZN6SX127818setSpreadingFactorEh+0x84>
    49be:	66 0f       	add	r22, r22
    49c0:	77 1f       	adc	r23, r23
    49c2:	88 1f       	adc	r24, r24
    49c4:	99 1f       	adc	r25, r25
    49c6:	1a 95       	dec	r17
    49c8:	d2 f7       	brpl	.-12     	; 0x49be <_ZN6SX127818setSpreadingFactorEh+0x7c>
    49ca:	0e 94 76 39 	call	0x72ec	; 0x72ec <__floatunsisf>
    49ce:	fe 01       	movw	r30, r28
    49d0:	e1 5e       	subi	r30, 0xE1	; 225
    49d2:	fe 4f       	sbci	r31, 0xFE	; 254
    49d4:	20 81       	ld	r18, Z
    49d6:	31 81       	ldd	r19, Z+1	; 0x01
    49d8:	42 81       	ldd	r20, Z+2	; 0x02
    49da:	53 81       	ldd	r21, Z+3	; 0x03
    49dc:	0e 94 ef 3b 	call	0x77de	; 0x77de <__divsf3>
      if(symbolLength >= 16.0) {
    49e0:	20 e0       	ldi	r18, 0x00	; 0
    49e2:	30 e0       	ldi	r19, 0x00	; 0
    49e4:	40 e8       	ldi	r20, 0x80	; 128
    49e6:	51 e4       	ldi	r21, 0x41	; 65
    49e8:	0e 94 d1 3c 	call	0x79a2	; 0x79a2 <__gesf2>
    49ec:	88 23       	and	r24, r24
    49ee:	bc f4       	brge	.+46     	; 0x4a1e <_ZN6SX127818setSpreadingFactorEh+0xdc>
        state = this->mod->SPIsetRegValue(RADIOLIB_SX1278_REG_MODEM_CONFIG_3, RADIOLIB_SX1278_LOW_DATA_RATE_OPT_ON, 3, 3);
      } else {
        state = this->mod->SPIsetRegValue(RADIOLIB_SX1278_REG_MODEM_CONFIG_3, RADIOLIB_SX1278_LOW_DATA_RATE_OPT_OFF, 3, 3);
    49f0:	c7 5e       	subi	r28, 0xE7	; 231
    49f2:	de 4f       	sbci	r29, 0xFE	; 254
    49f4:	cc 24       	eor	r12, r12
    49f6:	ca 94       	dec	r12
    49f8:	68 94       	set
    49fa:	ee 24       	eor	r14, r14
    49fc:	e1 f8       	bld	r14, 1
    49fe:	03 e0       	ldi	r16, 0x03	; 3
    4a00:	23 e0       	ldi	r18, 0x03	; 3
    4a02:	40 e0       	ldi	r20, 0x00	; 0
    4a04:	66 e2       	ldi	r22, 0x26	; 38
    4a06:	70 e0       	ldi	r23, 0x00	; 0
    4a08:	88 81       	ld	r24, Y
    4a0a:	99 81       	ldd	r25, Y+1	; 0x01
    4a0c:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
      }
    }
  }
  return(state);
}
    4a10:	df 91       	pop	r29
    4a12:	cf 91       	pop	r28
    4a14:	1f 91       	pop	r17
    4a16:	0f 91       	pop	r16
    4a18:	ef 90       	pop	r14
    4a1a:	cf 90       	pop	r12
    4a1c:	08 95       	ret

    // calculate symbol length and set low data rate optimization, if auto-configuration is enabled
    if(this->ldroAuto) {
      float symbolLength = (float)(uint32_t(1) << SX127x::spreadingFactor) / (float)SX127x::bandwidth;
      if(symbolLength >= 16.0) {
        state = this->mod->SPIsetRegValue(RADIOLIB_SX1278_REG_MODEM_CONFIG_3, RADIOLIB_SX1278_LOW_DATA_RATE_OPT_ON, 3, 3);
    4a1e:	c7 5e       	subi	r28, 0xE7	; 231
    4a20:	de 4f       	sbci	r29, 0xFE	; 254
    4a22:	cc 24       	eor	r12, r12
    4a24:	ca 94       	dec	r12
    4a26:	68 94       	set
    4a28:	ee 24       	eor	r14, r14
    4a2a:	e1 f8       	bld	r14, 1
    4a2c:	03 e0       	ldi	r16, 0x03	; 3
    4a2e:	23 e0       	ldi	r18, 0x03	; 3
    4a30:	48 e0       	ldi	r20, 0x08	; 8
    4a32:	66 e2       	ldi	r22, 0x26	; 38
    4a34:	70 e0       	ldi	r23, 0x00	; 0
    4a36:	88 81       	ld	r24, Y
    4a38:	99 81       	ldd	r25, Y+1	; 0x01
    4a3a:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    4a3e:	e8 cf       	rjmp	.-48     	; 0x4a10 <_ZN6SX127818setSpreadingFactorEh+0xce>
}

int16_t SX1278::setSpreadingFactor(uint8_t sf) {
  // check active modem
  if(getActiveModem() != RADIOLIB_SX127X_LORA) {
    return(RADIOLIB_ERR_WRONG_MODEM);
    4a40:	8c ee       	ldi	r24, 0xEC	; 236
    4a42:	9f ef       	ldi	r25, 0xFF	; 255
    4a44:	e5 cf       	rjmp	.-54     	; 0x4a10 <_ZN6SX127818setSpreadingFactorEh+0xce>
      break;
    case 12:
      newSpreadingFactor = RADIOLIB_SX127X_SF_12;
      break;
    default:
      return(RADIOLIB_ERR_INVALID_SPREADING_FACTOR);
    4a46:	87 ef       	ldi	r24, 0xF7	; 247
    4a48:	9f ef       	ldi	r25, 0xFF	; 255
    4a4a:	e2 cf       	rjmp	.-60     	; 0x4a10 <_ZN6SX127818setSpreadingFactorEh+0xce>

00004a4c <_ZN6SX127812setBandwidthEf>:
    SX127x::frequency = freq;
  }
  return(state);
}

int16_t SX1278::setBandwidth(float bw) {
    4a4c:	cf 92       	push	r12
    4a4e:	df 92       	push	r13
    4a50:	ef 92       	push	r14
    4a52:	ff 92       	push	r15
    4a54:	0f 93       	push	r16
    4a56:	cf 93       	push	r28
    4a58:	df 93       	push	r29
    4a5a:	ec 01       	movw	r28, r24
    4a5c:	6a 01       	movw	r12, r20
    4a5e:	7b 01       	movw	r14, r22
  // check active modem
  if(getActiveModem() != RADIOLIB_SX127X_LORA) {
    4a60:	0e 94 ec 18 	call	0x31d8	; 0x31d8 <_ZN6SX127x14getActiveModemEv>
    4a64:	80 38       	cpi	r24, 0x80	; 128
    4a66:	91 05       	cpc	r25, r1
    4a68:	09 f0       	breq	.+2      	; 0x4a6c <_ZN6SX127812setBandwidthEf+0x20>
    4a6a:	1b c1       	rjmp	.+566    	; 0x4ca2 <_ZN6SX127812setBandwidthEf+0x256>
  }

  uint8_t newBandwidth;

  // check allowed bandwidth values
  if(fabs(bw - 7.8) <= 0.001) {
    4a6c:	2a e9       	ldi	r18, 0x9A	; 154
    4a6e:	39 e9       	ldi	r19, 0x99	; 153
    4a70:	49 ef       	ldi	r20, 0xF9	; 249
    4a72:	50 e4       	ldi	r21, 0x40	; 64
    4a74:	c7 01       	movw	r24, r14
    4a76:	b6 01       	movw	r22, r12
    4a78:	0e 94 6b 3b 	call	0x76d6	; 0x76d6 <__subsf3>
    4a7c:	9f 77       	andi	r25, 0x7F	; 127
    4a7e:	2f e6       	ldi	r18, 0x6F	; 111
    4a80:	32 e1       	ldi	r19, 0x12	; 18
    4a82:	43 e8       	ldi	r20, 0x83	; 131
    4a84:	5a e3       	ldi	r21, 0x3A	; 58
    4a86:	0e 94 71 39 	call	0x72e2	; 0x72e2 <__cmpsf2>
    4a8a:	18 16       	cp	r1, r24
    4a8c:	0c f0       	brlt	.+2      	; 0x4a90 <_ZN6SX127812setBandwidthEf+0x44>
    4a8e:	a4 c0       	rjmp	.+328    	; 0x4bd8 <_ZN6SX127812setBandwidthEf+0x18c>
    newBandwidth = RADIOLIB_SX1278_BW_7_80_KHZ;
  } else if(fabs(bw - 10.4) <= 0.001) {
    4a90:	26 e6       	ldi	r18, 0x66	; 102
    4a92:	36 e6       	ldi	r19, 0x66	; 102
    4a94:	46 e2       	ldi	r20, 0x26	; 38
    4a96:	51 e4       	ldi	r21, 0x41	; 65
    4a98:	c7 01       	movw	r24, r14
    4a9a:	b6 01       	movw	r22, r12
    4a9c:	0e 94 6b 3b 	call	0x76d6	; 0x76d6 <__subsf3>
    4aa0:	9f 77       	andi	r25, 0x7F	; 127
    4aa2:	2f e6       	ldi	r18, 0x6F	; 111
    4aa4:	32 e1       	ldi	r19, 0x12	; 18
    4aa6:	43 e8       	ldi	r20, 0x83	; 131
    4aa8:	5a e3       	ldi	r21, 0x3A	; 58
    4aaa:	0e 94 71 39 	call	0x72e2	; 0x72e2 <__cmpsf2>
    4aae:	18 16       	cp	r1, r24
    4ab0:	0c f0       	brlt	.+2      	; 0x4ab4 <_ZN6SX127812setBandwidthEf+0x68>
    4ab2:	94 c0       	rjmp	.+296    	; 0x4bdc <_ZN6SX127812setBandwidthEf+0x190>
    newBandwidth = RADIOLIB_SX1278_BW_10_40_KHZ;
  } else if(fabs(bw - 15.6) <= 0.001) {
    4ab4:	2a e9       	ldi	r18, 0x9A	; 154
    4ab6:	39 e9       	ldi	r19, 0x99	; 153
    4ab8:	49 e7       	ldi	r20, 0x79	; 121
    4aba:	51 e4       	ldi	r21, 0x41	; 65
    4abc:	c7 01       	movw	r24, r14
    4abe:	b6 01       	movw	r22, r12
    4ac0:	0e 94 6b 3b 	call	0x76d6	; 0x76d6 <__subsf3>
    4ac4:	9f 77       	andi	r25, 0x7F	; 127
    4ac6:	2f e6       	ldi	r18, 0x6F	; 111
    4ac8:	32 e1       	ldi	r19, 0x12	; 18
    4aca:	43 e8       	ldi	r20, 0x83	; 131
    4acc:	5a e3       	ldi	r21, 0x3A	; 58
    4ace:	0e 94 71 39 	call	0x72e2	; 0x72e2 <__cmpsf2>
    4ad2:	18 16       	cp	r1, r24
    4ad4:	0c f0       	brlt	.+2      	; 0x4ad8 <_ZN6SX127812setBandwidthEf+0x8c>
    4ad6:	c6 c0       	rjmp	.+396    	; 0x4c64 <_ZN6SX127812setBandwidthEf+0x218>
    newBandwidth = RADIOLIB_SX1278_BW_15_60_KHZ;
  } else if(fabs(bw - 20.8) <= 0.001) {
    4ad8:	26 e6       	ldi	r18, 0x66	; 102
    4ada:	36 e6       	ldi	r19, 0x66	; 102
    4adc:	46 ea       	ldi	r20, 0xA6	; 166
    4ade:	51 e4       	ldi	r21, 0x41	; 65
    4ae0:	c7 01       	movw	r24, r14
    4ae2:	b6 01       	movw	r22, r12
    4ae4:	0e 94 6b 3b 	call	0x76d6	; 0x76d6 <__subsf3>
    4ae8:	9f 77       	andi	r25, 0x7F	; 127
    4aea:	2f e6       	ldi	r18, 0x6F	; 111
    4aec:	32 e1       	ldi	r19, 0x12	; 18
    4aee:	43 e8       	ldi	r20, 0x83	; 131
    4af0:	5a e3       	ldi	r21, 0x3A	; 58
    4af2:	0e 94 71 39 	call	0x72e2	; 0x72e2 <__cmpsf2>
    4af6:	18 16       	cp	r1, r24
    4af8:	0c f0       	brlt	.+2      	; 0x4afc <_ZN6SX127812setBandwidthEf+0xb0>
    4afa:	b6 c0       	rjmp	.+364    	; 0x4c68 <_ZN6SX127812setBandwidthEf+0x21c>
    newBandwidth = RADIOLIB_SX1278_BW_20_80_KHZ;
  } else if(fabs(bw - 31.25) <= 0.001) {
    4afc:	20 e0       	ldi	r18, 0x00	; 0
    4afe:	30 e0       	ldi	r19, 0x00	; 0
    4b00:	4a ef       	ldi	r20, 0xFA	; 250
    4b02:	51 e4       	ldi	r21, 0x41	; 65
    4b04:	c7 01       	movw	r24, r14
    4b06:	b6 01       	movw	r22, r12
    4b08:	0e 94 6b 3b 	call	0x76d6	; 0x76d6 <__subsf3>
    4b0c:	9f 77       	andi	r25, 0x7F	; 127
    4b0e:	2f e6       	ldi	r18, 0x6F	; 111
    4b10:	32 e1       	ldi	r19, 0x12	; 18
    4b12:	43 e8       	ldi	r20, 0x83	; 131
    4b14:	5a e3       	ldi	r21, 0x3A	; 58
    4b16:	0e 94 71 39 	call	0x72e2	; 0x72e2 <__cmpsf2>
    4b1a:	18 16       	cp	r1, r24
    4b1c:	0c f0       	brlt	.+2      	; 0x4b20 <_ZN6SX127812setBandwidthEf+0xd4>
    4b1e:	a6 c0       	rjmp	.+332    	; 0x4c6c <_ZN6SX127812setBandwidthEf+0x220>
    newBandwidth = RADIOLIB_SX1278_BW_31_25_KHZ;
  } else if(fabs(bw - 41.7) <= 0.001) {
    4b20:	2d ec       	ldi	r18, 0xCD	; 205
    4b22:	3c ec       	ldi	r19, 0xCC	; 204
    4b24:	46 e2       	ldi	r20, 0x26	; 38
    4b26:	52 e4       	ldi	r21, 0x42	; 66
    4b28:	c7 01       	movw	r24, r14
    4b2a:	b6 01       	movw	r22, r12
    4b2c:	0e 94 6b 3b 	call	0x76d6	; 0x76d6 <__subsf3>
    4b30:	9f 77       	andi	r25, 0x7F	; 127
    4b32:	2f e6       	ldi	r18, 0x6F	; 111
    4b34:	32 e1       	ldi	r19, 0x12	; 18
    4b36:	43 e8       	ldi	r20, 0x83	; 131
    4b38:	5a e3       	ldi	r21, 0x3A	; 58
    4b3a:	0e 94 71 39 	call	0x72e2	; 0x72e2 <__cmpsf2>
    4b3e:	18 16       	cp	r1, r24
    4b40:	0c f0       	brlt	.+2      	; 0x4b44 <_ZN6SX127812setBandwidthEf+0xf8>
    4b42:	96 c0       	rjmp	.+300    	; 0x4c70 <_ZN6SX127812setBandwidthEf+0x224>
    newBandwidth = RADIOLIB_SX1278_BW_41_70_KHZ;
  } else if(fabs(bw - 62.5) <= 0.001) {
    4b44:	20 e0       	ldi	r18, 0x00	; 0
    4b46:	30 e0       	ldi	r19, 0x00	; 0
    4b48:	4a e7       	ldi	r20, 0x7A	; 122
    4b4a:	52 e4       	ldi	r21, 0x42	; 66
    4b4c:	c7 01       	movw	r24, r14
    4b4e:	b6 01       	movw	r22, r12
    4b50:	0e 94 6b 3b 	call	0x76d6	; 0x76d6 <__subsf3>
    4b54:	9f 77       	andi	r25, 0x7F	; 127
    4b56:	2f e6       	ldi	r18, 0x6F	; 111
    4b58:	32 e1       	ldi	r19, 0x12	; 18
    4b5a:	43 e8       	ldi	r20, 0x83	; 131
    4b5c:	5a e3       	ldi	r21, 0x3A	; 58
    4b5e:	0e 94 71 39 	call	0x72e2	; 0x72e2 <__cmpsf2>
    4b62:	18 16       	cp	r1, r24
    4b64:	0c f0       	brlt	.+2      	; 0x4b68 <_ZN6SX127812setBandwidthEf+0x11c>
    4b66:	86 c0       	rjmp	.+268    	; 0x4c74 <_ZN6SX127812setBandwidthEf+0x228>
    newBandwidth = RADIOLIB_SX1278_BW_62_50_KHZ;
  } else if(fabs(bw - 125.0) <= 0.001) {
    4b68:	20 e0       	ldi	r18, 0x00	; 0
    4b6a:	30 e0       	ldi	r19, 0x00	; 0
    4b6c:	4a ef       	ldi	r20, 0xFA	; 250
    4b6e:	52 e4       	ldi	r21, 0x42	; 66
    4b70:	c7 01       	movw	r24, r14
    4b72:	b6 01       	movw	r22, r12
    4b74:	0e 94 6b 3b 	call	0x76d6	; 0x76d6 <__subsf3>
    4b78:	9f 77       	andi	r25, 0x7F	; 127
    4b7a:	2f e6       	ldi	r18, 0x6F	; 111
    4b7c:	32 e1       	ldi	r19, 0x12	; 18
    4b7e:	43 e8       	ldi	r20, 0x83	; 131
    4b80:	5a e3       	ldi	r21, 0x3A	; 58
    4b82:	0e 94 71 39 	call	0x72e2	; 0x72e2 <__cmpsf2>
    4b86:	18 16       	cp	r1, r24
    4b88:	0c f0       	brlt	.+2      	; 0x4b8c <_ZN6SX127812setBandwidthEf+0x140>
    4b8a:	76 c0       	rjmp	.+236    	; 0x4c78 <_ZN6SX127812setBandwidthEf+0x22c>
    newBandwidth = RADIOLIB_SX1278_BW_125_00_KHZ;
  } else if(fabs(bw - 250.0) <= 0.001) {
    4b8c:	20 e0       	ldi	r18, 0x00	; 0
    4b8e:	30 e0       	ldi	r19, 0x00	; 0
    4b90:	4a e7       	ldi	r20, 0x7A	; 122
    4b92:	53 e4       	ldi	r21, 0x43	; 67
    4b94:	c7 01       	movw	r24, r14
    4b96:	b6 01       	movw	r22, r12
    4b98:	0e 94 6b 3b 	call	0x76d6	; 0x76d6 <__subsf3>
    4b9c:	9f 77       	andi	r25, 0x7F	; 127
    4b9e:	2f e6       	ldi	r18, 0x6F	; 111
    4ba0:	32 e1       	ldi	r19, 0x12	; 18
    4ba2:	43 e8       	ldi	r20, 0x83	; 131
    4ba4:	5a e3       	ldi	r21, 0x3A	; 58
    4ba6:	0e 94 71 39 	call	0x72e2	; 0x72e2 <__cmpsf2>
    4baa:	18 16       	cp	r1, r24
    4bac:	0c f0       	brlt	.+2      	; 0x4bb0 <_ZN6SX127812setBandwidthEf+0x164>
    4bae:	66 c0       	rjmp	.+204    	; 0x4c7c <_ZN6SX127812setBandwidthEf+0x230>
    newBandwidth = RADIOLIB_SX1278_BW_250_00_KHZ;
  } else if(fabs(bw - 500.0) <= 0.001) {
    4bb0:	20 e0       	ldi	r18, 0x00	; 0
    4bb2:	30 e0       	ldi	r19, 0x00	; 0
    4bb4:	4a ef       	ldi	r20, 0xFA	; 250
    4bb6:	53 e4       	ldi	r21, 0x43	; 67
    4bb8:	c7 01       	movw	r24, r14
    4bba:	b6 01       	movw	r22, r12
    4bbc:	0e 94 6b 3b 	call	0x76d6	; 0x76d6 <__subsf3>
    4bc0:	9f 77       	andi	r25, 0x7F	; 127
    4bc2:	2f e6       	ldi	r18, 0x6F	; 111
    4bc4:	32 e1       	ldi	r19, 0x12	; 18
    4bc6:	43 e8       	ldi	r20, 0x83	; 131
    4bc8:	5a e3       	ldi	r21, 0x3A	; 58
    4bca:	0e 94 71 39 	call	0x72e2	; 0x72e2 <__cmpsf2>
    4bce:	18 16       	cp	r1, r24
    4bd0:	0c f4       	brge	.+2      	; 0x4bd4 <_ZN6SX127812setBandwidthEf+0x188>
    4bd2:	6a c0       	rjmp	.+212    	; 0x4ca8 <_ZN6SX127812setBandwidthEf+0x25c>
    newBandwidth = RADIOLIB_SX1278_BW_500_00_KHZ;
    4bd4:	60 e9       	ldi	r22, 0x90	; 144
    4bd6:	03 c0       	rjmp	.+6      	; 0x4bde <_ZN6SX127812setBandwidthEf+0x192>

  uint8_t newBandwidth;

  // check allowed bandwidth values
  if(fabs(bw - 7.8) <= 0.001) {
    newBandwidth = RADIOLIB_SX1278_BW_7_80_KHZ;
    4bd8:	60 e0       	ldi	r22, 0x00	; 0
    4bda:	01 c0       	rjmp	.+2      	; 0x4bde <_ZN6SX127812setBandwidthEf+0x192>
  } else if(fabs(bw - 10.4) <= 0.001) {
    newBandwidth = RADIOLIB_SX1278_BW_10_40_KHZ;
    4bdc:	60 e1       	ldi	r22, 0x10	; 16
  } else {
    return(RADIOLIB_ERR_INVALID_BANDWIDTH);
  }

  // set bandwidth and if successful, save the new setting
  int16_t state = SX1278::setBandwidthRaw(newBandwidth);
    4bde:	ce 01       	movw	r24, r28
    4be0:	0e 94 ae 1b 	call	0x375c	; 0x375c <_ZN6SX127815setBandwidthRawEh>
  if(state == RADIOLIB_ERR_NONE) {
    4be4:	00 97       	sbiw	r24, 0x00	; 0
    4be6:	b1 f5       	brne	.+108    	; 0x4c54 <_ZN6SX127812setBandwidthEf+0x208>
    SX127x::bandwidth = bw;
    4be8:	fe 01       	movw	r30, r28
    4bea:	e1 5e       	subi	r30, 0xE1	; 225
    4bec:	fe 4f       	sbci	r31, 0xFE	; 254
    4bee:	c0 82       	st	Z, r12
    4bf0:	d1 82       	std	Z+1, r13	; 0x01
    4bf2:	e2 82       	std	Z+2, r14	; 0x02
    4bf4:	f3 82       	std	Z+3, r15	; 0x03

    // calculate symbol length and set low data rate optimization, if auto-configuration is enabled
    if(this->ldroAuto) {
    4bf6:	75 96       	adiw	r30, 0x15	; 21
    4bf8:	20 81       	ld	r18, Z
    4bfa:	22 23       	and	r18, r18
    4bfc:	59 f1       	breq	.+86     	; 0x4c54 <_ZN6SX127812setBandwidthEf+0x208>
      float symbolLength = (float)(uint32_t(1) << SX127x::spreadingFactor) / (float)SX127x::bandwidth;
    4bfe:	71 97       	sbiw	r30, 0x11	; 17
    4c00:	20 81       	ld	r18, Z
    4c02:	61 e0       	ldi	r22, 0x01	; 1
    4c04:	70 e0       	ldi	r23, 0x00	; 0
    4c06:	80 e0       	ldi	r24, 0x00	; 0
    4c08:	90 e0       	ldi	r25, 0x00	; 0
    4c0a:	04 c0       	rjmp	.+8      	; 0x4c14 <_ZN6SX127812setBandwidthEf+0x1c8>
    4c0c:	66 0f       	add	r22, r22
    4c0e:	77 1f       	adc	r23, r23
    4c10:	88 1f       	adc	r24, r24
    4c12:	99 1f       	adc	r25, r25
    4c14:	2a 95       	dec	r18
    4c16:	d2 f7       	brpl	.-12     	; 0x4c0c <_ZN6SX127812setBandwidthEf+0x1c0>
    4c18:	0e 94 76 39 	call	0x72ec	; 0x72ec <__floatunsisf>
    4c1c:	a7 01       	movw	r20, r14
    4c1e:	96 01       	movw	r18, r12
    4c20:	0e 94 ef 3b 	call	0x77de	; 0x77de <__divsf3>
      if(symbolLength >= 16.0) {
    4c24:	20 e0       	ldi	r18, 0x00	; 0
    4c26:	30 e0       	ldi	r19, 0x00	; 0
    4c28:	40 e8       	ldi	r20, 0x80	; 128
    4c2a:	51 e4       	ldi	r21, 0x41	; 65
    4c2c:	0e 94 d1 3c 	call	0x79a2	; 0x79a2 <__gesf2>
    4c30:	88 23       	and	r24, r24
    4c32:	34 f5       	brge	.+76     	; 0x4c80 <_ZN6SX127812setBandwidthEf+0x234>
        state = this->mod->SPIsetRegValue(RADIOLIB_SX1278_REG_MODEM_CONFIG_3, RADIOLIB_SX1278_LOW_DATA_RATE_OPT_ON, 3, 3);
      } else {
        state = this->mod->SPIsetRegValue(RADIOLIB_SX1278_REG_MODEM_CONFIG_3, RADIOLIB_SX1278_LOW_DATA_RATE_OPT_OFF, 3, 3);
    4c34:	c7 5e       	subi	r28, 0xE7	; 231
    4c36:	de 4f       	sbci	r29, 0xFE	; 254
    4c38:	cc 24       	eor	r12, r12
    4c3a:	ca 94       	dec	r12
    4c3c:	68 94       	set
    4c3e:	ee 24       	eor	r14, r14
    4c40:	e1 f8       	bld	r14, 1
    4c42:	03 e0       	ldi	r16, 0x03	; 3
    4c44:	23 e0       	ldi	r18, 0x03	; 3
    4c46:	40 e0       	ldi	r20, 0x00	; 0
    4c48:	66 e2       	ldi	r22, 0x26	; 38
    4c4a:	70 e0       	ldi	r23, 0x00	; 0
    4c4c:	88 81       	ld	r24, Y
    4c4e:	99 81       	ldd	r25, Y+1	; 0x01
    4c50:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
      }
    }
  }
  return(state);
}
    4c54:	df 91       	pop	r29
    4c56:	cf 91       	pop	r28
    4c58:	0f 91       	pop	r16
    4c5a:	ff 90       	pop	r15
    4c5c:	ef 90       	pop	r14
    4c5e:	df 90       	pop	r13
    4c60:	cf 90       	pop	r12
    4c62:	08 95       	ret
  if(fabs(bw - 7.8) <= 0.001) {
    newBandwidth = RADIOLIB_SX1278_BW_7_80_KHZ;
  } else if(fabs(bw - 10.4) <= 0.001) {
    newBandwidth = RADIOLIB_SX1278_BW_10_40_KHZ;
  } else if(fabs(bw - 15.6) <= 0.001) {
    newBandwidth = RADIOLIB_SX1278_BW_15_60_KHZ;
    4c64:	60 e2       	ldi	r22, 0x20	; 32
    4c66:	bb cf       	rjmp	.-138    	; 0x4bde <_ZN6SX127812setBandwidthEf+0x192>
  } else if(fabs(bw - 20.8) <= 0.001) {
    newBandwidth = RADIOLIB_SX1278_BW_20_80_KHZ;
    4c68:	60 e3       	ldi	r22, 0x30	; 48
    4c6a:	b9 cf       	rjmp	.-142    	; 0x4bde <_ZN6SX127812setBandwidthEf+0x192>
  } else if(fabs(bw - 31.25) <= 0.001) {
    newBandwidth = RADIOLIB_SX1278_BW_31_25_KHZ;
    4c6c:	60 e4       	ldi	r22, 0x40	; 64
    4c6e:	b7 cf       	rjmp	.-146    	; 0x4bde <_ZN6SX127812setBandwidthEf+0x192>
  } else if(fabs(bw - 41.7) <= 0.001) {
    newBandwidth = RADIOLIB_SX1278_BW_41_70_KHZ;
    4c70:	60 e5       	ldi	r22, 0x50	; 80
    4c72:	b5 cf       	rjmp	.-150    	; 0x4bde <_ZN6SX127812setBandwidthEf+0x192>
  } else if(fabs(bw - 62.5) <= 0.001) {
    newBandwidth = RADIOLIB_SX1278_BW_62_50_KHZ;
    4c74:	60 e6       	ldi	r22, 0x60	; 96
    4c76:	b3 cf       	rjmp	.-154    	; 0x4bde <_ZN6SX127812setBandwidthEf+0x192>
  } else if(fabs(bw - 125.0) <= 0.001) {
    newBandwidth = RADIOLIB_SX1278_BW_125_00_KHZ;
    4c78:	60 e7       	ldi	r22, 0x70	; 112
    4c7a:	b1 cf       	rjmp	.-158    	; 0x4bde <_ZN6SX127812setBandwidthEf+0x192>
  } else if(fabs(bw - 250.0) <= 0.001) {
    newBandwidth = RADIOLIB_SX1278_BW_250_00_KHZ;
    4c7c:	60 e8       	ldi	r22, 0x80	; 128
    4c7e:	af cf       	rjmp	.-162    	; 0x4bde <_ZN6SX127812setBandwidthEf+0x192>

    // calculate symbol length and set low data rate optimization, if auto-configuration is enabled
    if(this->ldroAuto) {
      float symbolLength = (float)(uint32_t(1) << SX127x::spreadingFactor) / (float)SX127x::bandwidth;
      if(symbolLength >= 16.0) {
        state = this->mod->SPIsetRegValue(RADIOLIB_SX1278_REG_MODEM_CONFIG_3, RADIOLIB_SX1278_LOW_DATA_RATE_OPT_ON, 3, 3);
    4c80:	c7 5e       	subi	r28, 0xE7	; 231
    4c82:	de 4f       	sbci	r29, 0xFE	; 254
    4c84:	cc 24       	eor	r12, r12
    4c86:	ca 94       	dec	r12
    4c88:	68 94       	set
    4c8a:	ee 24       	eor	r14, r14
    4c8c:	e1 f8       	bld	r14, 1
    4c8e:	03 e0       	ldi	r16, 0x03	; 3
    4c90:	23 e0       	ldi	r18, 0x03	; 3
    4c92:	48 e0       	ldi	r20, 0x08	; 8
    4c94:	66 e2       	ldi	r22, 0x26	; 38
    4c96:	70 e0       	ldi	r23, 0x00	; 0
    4c98:	88 81       	ld	r24, Y
    4c9a:	99 81       	ldd	r25, Y+1	; 0x01
    4c9c:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    4ca0:	d9 cf       	rjmp	.-78     	; 0x4c54 <_ZN6SX127812setBandwidthEf+0x208>
}

int16_t SX1278::setBandwidth(float bw) {
  // check active modem
  if(getActiveModem() != RADIOLIB_SX127X_LORA) {
    return(RADIOLIB_ERR_WRONG_MODEM);
    4ca2:	8c ee       	ldi	r24, 0xEC	; 236
    4ca4:	9f ef       	ldi	r25, 0xFF	; 255
    4ca6:	d6 cf       	rjmp	.-84     	; 0x4c54 <_ZN6SX127812setBandwidthEf+0x208>
  } else if(fabs(bw - 250.0) <= 0.001) {
    newBandwidth = RADIOLIB_SX1278_BW_250_00_KHZ;
  } else if(fabs(bw - 500.0) <= 0.001) {
    newBandwidth = RADIOLIB_SX1278_BW_500_00_KHZ;
  } else {
    return(RADIOLIB_ERR_INVALID_BANDWIDTH);
    4ca8:	88 ef       	ldi	r24, 0xF8	; 248
    4caa:	9f ef       	ldi	r25, 0xFF	; 255
    4cac:	d3 cf       	rjmp	.-90     	; 0x4c54 <_ZN6SX127812setBandwidthEf+0x208>

00004cae <_ZN6SX127811setDataRateE10DataRate_t>:

int16_t SX1278::setBitRate(float br) {
  return(SX127x::setBitRateCommon(br, RADIOLIB_SX1278_REG_BIT_RATE_FRAC));
}

int16_t SX1278::setDataRate(DataRate_t dr) {
    4cae:	ef 92       	push	r14
    4cb0:	ff 92       	push	r15
    4cb2:	0f 93       	push	r16
    4cb4:	1f 93       	push	r17
    4cb6:	cf 93       	push	r28
    4cb8:	df 93       	push	r29
    4cba:	cd b7       	in	r28, 0x3d	; 61
    4cbc:	de b7       	in	r29, 0x3e	; 62
    4cbe:	28 97       	sbiw	r28, 0x08	; 8
    4cc0:	0f b6       	in	r0, 0x3f	; 63
    4cc2:	f8 94       	cli
    4cc4:	de bf       	out	0x3e, r29	; 62
    4cc6:	0f be       	out	0x3f, r0	; 63
    4cc8:	cd bf       	out	0x3d, r28	; 61
    4cca:	7c 01       	movw	r14, r24
    4ccc:	09 83       	std	Y+1, r16	; 0x01
    4cce:	1a 83       	std	Y+2, r17	; 0x02
    4cd0:	2b 83       	std	Y+3, r18	; 0x03
    4cd2:	3c 83       	std	Y+4, r19	; 0x04
    4cd4:	4d 83       	std	Y+5, r20	; 0x05
    4cd6:	5e 83       	std	Y+6, r21	; 0x06
    4cd8:	6f 83       	std	Y+7, r22	; 0x07
    4cda:	78 87       	std	Y+8, r23	; 0x08
  int16_t state = RADIOLIB_ERR_UNKNOWN;

  // select interpretation based on active modem
  uint8_t modem = this->getActiveModem();
    4cdc:	0e 94 ec 18 	call	0x31d8	; 0x31d8 <_ZN6SX127x14getActiveModemEv>
  if(modem == RADIOLIB_SX127X_FSK_OOK) {
    4ce0:	81 11       	cpse	r24, r1
    4ce2:	27 c0       	rjmp	.+78     	; 0x4d32 <_ZN6SX127811setDataRateE10DataRate_t+0x84>
    // set the bit rate
    state = this->setBitRate(dr.fsk.bitRate);
    4ce4:	d7 01       	movw	r26, r14
    4ce6:	ed 91       	ld	r30, X+
    4ce8:	fc 91       	ld	r31, X
    4cea:	02 8c       	ldd	r0, Z+26	; 0x1a
    4cec:	f3 8d       	ldd	r31, Z+27	; 0x1b
    4cee:	e0 2d       	mov	r30, r0
    4cf0:	49 81       	ldd	r20, Y+1	; 0x01
    4cf2:	5a 81       	ldd	r21, Y+2	; 0x02
    4cf4:	6b 81       	ldd	r22, Y+3	; 0x03
    4cf6:	7c 81       	ldd	r23, Y+4	; 0x04
    4cf8:	c7 01       	movw	r24, r14
    4cfa:	09 95       	icall
    RADIOLIB_ASSERT(state);
    4cfc:	00 97       	sbiw	r24, 0x00	; 0
    4cfe:	61 f4       	brne	.+24     	; 0x4d18 <_ZN6SX127811setDataRateE10DataRate_t+0x6a>

    // set the frequency deviation
    state = this->setFrequencyDeviation(dr.fsk.freqDev);
    4d00:	d7 01       	movw	r26, r14
    4d02:	ed 91       	ld	r30, X+
    4d04:	fc 91       	ld	r31, X
    4d06:	04 8c       	ldd	r0, Z+28	; 0x1c
    4d08:	f5 8d       	ldd	r31, Z+29	; 0x1d
    4d0a:	e0 2d       	mov	r30, r0
    4d0c:	4d 81       	ldd	r20, Y+5	; 0x05
    4d0e:	5e 81       	ldd	r21, Y+6	; 0x06
    4d10:	6f 81       	ldd	r22, Y+7	; 0x07
    4d12:	78 85       	ldd	r23, Y+8	; 0x08
    4d14:	c7 01       	movw	r24, r14
    4d16:	09 95       	icall
    // set the coding rate
    state = this->setCodingRate(dr.lora.codingRate);
  }

  return(state);
}
    4d18:	28 96       	adiw	r28, 0x08	; 8
    4d1a:	0f b6       	in	r0, 0x3f	; 63
    4d1c:	f8 94       	cli
    4d1e:	de bf       	out	0x3e, r29	; 62
    4d20:	0f be       	out	0x3f, r0	; 63
    4d22:	cd bf       	out	0x3d, r28	; 61
    4d24:	df 91       	pop	r29
    4d26:	cf 91       	pop	r28
    4d28:	1f 91       	pop	r17
    4d2a:	0f 91       	pop	r16
    4d2c:	ff 90       	pop	r15
    4d2e:	ef 90       	pop	r14
    4d30:	08 95       	ret
    RADIOLIB_ASSERT(state);

    // set the frequency deviation
    state = this->setFrequencyDeviation(dr.fsk.freqDev);

  } else if(modem == RADIOLIB_SX127X_LORA) {
    4d32:	80 38       	cpi	r24, 0x80	; 128
    4d34:	a1 f4       	brne	.+40     	; 0x4d5e <_ZN6SX127811setDataRateE10DataRate_t+0xb0>
    // set the spreading factor
    state = this->setSpreadingFactor(dr.lora.spreadingFactor);
    4d36:	69 81       	ldd	r22, Y+1	; 0x01
    4d38:	c7 01       	movw	r24, r14
    4d3a:	0e 94 a1 24 	call	0x4942	; 0x4942 <_ZN6SX127818setSpreadingFactorEh>
    RADIOLIB_ASSERT(state);
    4d3e:	00 97       	sbiw	r24, 0x00	; 0
    4d40:	59 f7       	brne	.-42     	; 0x4d18 <_ZN6SX127811setDataRateE10DataRate_t+0x6a>

    // set the bandwidth
    state = this->setBandwidth(dr.lora.bandwidth);
    4d42:	4a 81       	ldd	r20, Y+2	; 0x02
    4d44:	5b 81       	ldd	r21, Y+3	; 0x03
    4d46:	6c 81       	ldd	r22, Y+4	; 0x04
    4d48:	7d 81       	ldd	r23, Y+5	; 0x05
    4d4a:	c7 01       	movw	r24, r14
    4d4c:	0e 94 26 25 	call	0x4a4c	; 0x4a4c <_ZN6SX127812setBandwidthEf>
    RADIOLIB_ASSERT(state);
    4d50:	00 97       	sbiw	r24, 0x00	; 0
    4d52:	11 f7       	brne	.-60     	; 0x4d18 <_ZN6SX127811setDataRateE10DataRate_t+0x6a>

    // set the coding rate
    state = this->setCodingRate(dr.lora.codingRate);
    4d54:	6e 81       	ldd	r22, Y+6	; 0x06
    4d56:	c7 01       	movw	r24, r14
    4d58:	0e 94 74 24 	call	0x48e8	; 0x48e8 <_ZN6SX127813setCodingRateEh>
    4d5c:	dd cf       	rjmp	.-70     	; 0x4d18 <_ZN6SX127811setDataRateE10DataRate_t+0x6a>
int16_t SX1278::setBitRate(float br) {
  return(SX127x::setBitRateCommon(br, RADIOLIB_SX1278_REG_BIT_RATE_FRAC));
}

int16_t SX1278::setDataRate(DataRate_t dr) {
  int16_t state = RADIOLIB_ERR_UNKNOWN;
    4d5e:	8f ef       	ldi	r24, 0xFF	; 255
    4d60:	9f ef       	ldi	r25, 0xFF	; 255
    4d62:	da cf       	rjmp	.-76     	; 0x4d18 <_ZN6SX127811setDataRateE10DataRate_t+0x6a>

00004d64 <_ZN6SX127x14getChipVersionEv>:

  return(randByte);
}

int16_t SX127x::getChipVersion() {
  return(this->mod->SPIgetRegValue(RADIOLIB_SX127X_REG_VERSION));
    4d64:	87 5e       	subi	r24, 0xE7	; 231
    4d66:	9e 4f       	sbci	r25, 0xFE	; 254
    4d68:	20 e0       	ldi	r18, 0x00	; 0
    4d6a:	47 e0       	ldi	r20, 0x07	; 7
    4d6c:	62 e4       	ldi	r22, 0x42	; 66
    4d6e:	70 e0       	ldi	r23, 0x00	; 0
    4d70:	fc 01       	movw	r30, r24
    4d72:	80 81       	ld	r24, Z
    4d74:	91 81       	ldd	r25, Z+1	; 0x01
    4d76:	0e 94 c0 18 	call	0x3180	; 0x3180 <_ZN6Module14SPIgetRegValueEjhh>
}
    4d7a:	08 95       	ret

00004d7c <_ZN6SX127x8findChipEh>:
  // update cached value
  this->packetLengthConfig = mode;
  return(state);
}

bool SX127x::findChip(uint8_t ver) {
    4d7c:	ff 92       	push	r15
    4d7e:	0f 93       	push	r16
    4d80:	1f 93       	push	r17
    4d82:	cf 93       	push	r28
    4d84:	df 93       	push	r29
    4d86:	ec 01       	movw	r28, r24
    4d88:	f6 2e       	mov	r15, r22
  uint8_t i = 0;
  bool flagFound = false;
    4d8a:	00 e0       	ldi	r16, 0x00	; 0
  this->packetLengthConfig = mode;
  return(state);
}

bool SX127x::findChip(uint8_t ver) {
  uint8_t i = 0;
    4d8c:	10 e0       	ldi	r17, 0x00	; 0
    4d8e:	01 c0       	rjmp	.+2      	; 0x4d92 <_ZN6SX127x8findChipEh+0x16>
    reset();

    // check version register
    int16_t version = getChipVersion();
    if(version == ver) {
      flagFound = true;
    4d90:	01 e0       	ldi	r16, 0x01	; 1
}

bool SX127x::findChip(uint8_t ver) {
  uint8_t i = 0;
  bool flagFound = false;
  while((i < 10) && !flagFound) {
    4d92:	1a 30       	cpi	r17, 0x0A	; 10
    4d94:	30 f5       	brcc	.+76     	; 0x4de2 <_ZN6SX127x8findChipEh+0x66>
    4d96:	01 11       	cpse	r16, r1
    4d98:	24 c0       	rjmp	.+72     	; 0x4de2 <_ZN6SX127x8findChipEh+0x66>
    // reset the module
    reset();
    4d9a:	e8 81       	ld	r30, Y
    4d9c:	f9 81       	ldd	r31, Y+1	; 0x01
    4d9e:	e0 5b       	subi	r30, 0xB0	; 176
    4da0:	ff 4f       	sbci	r31, 0xFF	; 255
    4da2:	01 90       	ld	r0, Z+
    4da4:	f0 81       	ld	r31, Z
    4da6:	e0 2d       	mov	r30, r0
    4da8:	ce 01       	movw	r24, r28
    4daa:	09 95       	icall

    // check version register
    int16_t version = getChipVersion();
    4dac:	ce 01       	movw	r24, r28
    4dae:	0e 94 b2 26 	call	0x4d64	; 0x4d64 <_ZN6SX127x14getChipVersionEv>
    if(version == ver) {
    4db2:	f8 16       	cp	r15, r24
    4db4:	19 06       	cpc	r1, r25
    4db6:	61 f3       	breq	.-40     	; 0x4d90 <_ZN6SX127x8findChipEh+0x14>
      flagFound = true;
    } else {
      RADIOLIB_DEBUG_PRINTLN("SX127x not found! (%d of 10 tries) RADIOLIB_SX127X_REG_VERSION == 0x%04X, expected 0x00%X", i + 1, version, ver);
      this->mod->hal->delay(10);
    4db8:	fe 01       	movw	r30, r28
    4dba:	e7 5e       	subi	r30, 0xE7	; 231
    4dbc:	fe 4f       	sbci	r31, 0xFE	; 254
    4dbe:	01 90       	ld	r0, Z+
    4dc0:	f0 81       	ld	r31, Z
    4dc2:	e0 2d       	mov	r30, r0
    4dc4:	80 81       	ld	r24, Z
    4dc6:	91 81       	ldd	r25, Z+1	; 0x01
    4dc8:	dc 01       	movw	r26, r24
    4dca:	ed 91       	ld	r30, X+
    4dcc:	fc 91       	ld	r31, X
    4dce:	02 84       	ldd	r0, Z+10	; 0x0a
    4dd0:	f3 85       	ldd	r31, Z+11	; 0x0b
    4dd2:	e0 2d       	mov	r30, r0
    4dd4:	4a e0       	ldi	r20, 0x0A	; 10
    4dd6:	50 e0       	ldi	r21, 0x00	; 0
    4dd8:	60 e0       	ldi	r22, 0x00	; 0
    4dda:	70 e0       	ldi	r23, 0x00	; 0
    4ddc:	09 95       	icall
      i++;
    4dde:	1f 5f       	subi	r17, 0xFF	; 255
    4de0:	d8 cf       	rjmp	.-80     	; 0x4d92 <_ZN6SX127x8findChipEh+0x16>
    }
  }

  return(flagFound);
}
    4de2:	80 2f       	mov	r24, r16
    4de4:	df 91       	pop	r29
    4de6:	cf 91       	pop	r28
    4de8:	1f 91       	pop	r17
    4dea:	0f 91       	pop	r16
    4dec:	ff 90       	pop	r15
    4dee:	08 95       	ret

00004df0 <_ZN6SX127x5beginEhhj>:

Module* SX127x::getMod() {
  return(this->mod);
}

int16_t SX127x::begin(uint8_t chipVersion, uint8_t syncWord, uint16_t preambleLength) {
    4df0:	8f 92       	push	r8
    4df2:	9f 92       	push	r9
    4df4:	af 92       	push	r10
    4df6:	bf 92       	push	r11
    4df8:	cf 92       	push	r12
    4dfa:	df 92       	push	r13
    4dfc:	ef 92       	push	r14
    4dfe:	ff 92       	push	r15
    4e00:	0f 93       	push	r16
    4e02:	1f 93       	push	r17
    4e04:	cf 93       	push	r28
    4e06:	df 93       	push	r29
    4e08:	ec 01       	movw	r28, r24
    4e0a:	b6 2e       	mov	r11, r22
    4e0c:	a4 2e       	mov	r10, r20
    4e0e:	69 01       	movw	r12, r18
  // set module properties
  this->mod->init();
    4e10:	7c 01       	movw	r14, r24
    4e12:	87 ee       	ldi	r24, 0xE7	; 231
    4e14:	e8 1a       	sub	r14, r24
    4e16:	8e ef       	ldi	r24, 0xFE	; 254
    4e18:	f8 0a       	sbc	r15, r24
    4e1a:	f7 01       	movw	r30, r14
    4e1c:	80 81       	ld	r24, Z
    4e1e:	91 81       	ldd	r25, Z+1	; 0x01
    4e20:	0e 94 56 0a 	call	0x14ac	; 0x14ac <_ZN6Module4initEv>
  this->mod->hal->pinMode(this->mod->getIrq(), this->mod->hal->GpioModeInput);
    4e24:	f7 01       	movw	r30, r14
    4e26:	a0 81       	ld	r26, Z
    4e28:	b1 81       	ldd	r27, Z+1	; 0x01
    4e2a:	8d 91       	ld	r24, X+
    4e2c:	9c 91       	ld	r25, X
    4e2e:	11 97       	sbiw	r26, 0x01	; 1
    4e30:	fc 01       	movw	r30, r24
    4e32:	20 81       	ld	r18, Z
    4e34:	31 81       	ldd	r19, Z+1	; 0x01
    4e36:	f9 01       	movw	r30, r18
    4e38:	80 80       	ld	r8, Z
    4e3a:	91 80       	ldd	r9, Z+1	; 0x01
    4e3c:	fc 01       	movw	r30, r24
    4e3e:	02 81       	ldd	r16, Z+2	; 0x02
    4e40:	13 81       	ldd	r17, Z+3	; 0x03
    4e42:	24 81       	ldd	r18, Z+4	; 0x04
    4e44:	35 81       	ldd	r19, Z+5	; 0x05
    4e46:	50 96       	adiw	r26, 0x10	; 16
    4e48:	4d 91       	ld	r20, X+
    4e4a:	5d 91       	ld	r21, X+
    4e4c:	6d 91       	ld	r22, X+
    4e4e:	7c 91       	ld	r23, X
    4e50:	53 97       	sbiw	r26, 0x13	; 19
    4e52:	f4 01       	movw	r30, r8
    4e54:	09 95       	icall
  this->mod->hal->pinMode(this->mod->getGpio(), this->mod->hal->GpioModeInput);
    4e56:	f7 01       	movw	r30, r14
    4e58:	a0 81       	ld	r26, Z
    4e5a:	b1 81       	ldd	r27, Z+1	; 0x01
    4e5c:	8d 91       	ld	r24, X+
    4e5e:	9c 91       	ld	r25, X
    4e60:	11 97       	sbiw	r26, 0x01	; 1
    4e62:	fc 01       	movw	r30, r24
    4e64:	20 81       	ld	r18, Z
    4e66:	31 81       	ldd	r19, Z+1	; 0x01
    4e68:	f9 01       	movw	r30, r18
    4e6a:	e0 80       	ld	r14, Z
    4e6c:	f1 80       	ldd	r15, Z+1	; 0x01
    4e6e:	fc 01       	movw	r30, r24
    4e70:	02 81       	ldd	r16, Z+2	; 0x02
    4e72:	13 81       	ldd	r17, Z+3	; 0x03
    4e74:	24 81       	ldd	r18, Z+4	; 0x04
    4e76:	35 81       	ldd	r19, Z+5	; 0x05

    /*!
      \brief Access method to get the pin number of second interrupt/GPIO.
      \returns Pin number of second interrupt/GPIO configured in the constructor.
    */
    uint32_t getGpio() const { return(gpioPin); }
    4e78:	58 96       	adiw	r26, 0x18	; 24
    4e7a:	4d 91       	ld	r20, X+
    4e7c:	5d 91       	ld	r21, X+
    4e7e:	6d 91       	ld	r22, X+
    4e80:	7c 91       	ld	r23, X
    4e82:	5b 97       	sbiw	r26, 0x1b	; 27
    4e84:	f7 01       	movw	r30, r14
    4e86:	09 95       	icall

  // try to find the SX127x chip
  if(!SX127x::findChip(chipVersion)) {
    4e88:	6b 2d       	mov	r22, r11
    4e8a:	ce 01       	movw	r24, r28
    4e8c:	0e 94 be 26 	call	0x4d7c	; 0x4d7c <_ZN6SX127x8findChipEh>
    4e90:	88 23       	and	r24, r24
    4e92:	b1 f0       	breq	.+44     	; 0x4ec0 <_ZN6SX127x5beginEhhj+0xd0>
    return(RADIOLIB_ERR_CHIP_NOT_FOUND);
  }
  RADIOLIB_DEBUG_PRINTLN("M\tSX127x");

  // set mode to standby
  int16_t state = standby();
    4e94:	e8 81       	ld	r30, Y
    4e96:	f9 81       	ldd	r31, Y+1	; 0x01
    4e98:	04 80       	ldd	r0, Z+4	; 0x04
    4e9a:	f5 81       	ldd	r31, Z+5	; 0x05
    4e9c:	e0 2d       	mov	r30, r0
    4e9e:	ce 01       	movw	r24, r28
    4ea0:	09 95       	icall
  RADIOLIB_ASSERT(state);
    4ea2:	00 97       	sbiw	r24, 0x00	; 0
    4ea4:	b1 f0       	breq	.+44     	; 0x4ed2 <_ZN6SX127x5beginEhhj+0xe2>

  // initialize internal variables
  this->dataRate = 0.0;

  return(state);
}
    4ea6:	df 91       	pop	r29
    4ea8:	cf 91       	pop	r28
    4eaa:	1f 91       	pop	r17
    4eac:	0f 91       	pop	r16
    4eae:	ff 90       	pop	r15
    4eb0:	ef 90       	pop	r14
    4eb2:	df 90       	pop	r13
    4eb4:	cf 90       	pop	r12
    4eb6:	bf 90       	pop	r11
    4eb8:	af 90       	pop	r10
    4eba:	9f 90       	pop	r9
    4ebc:	8f 90       	pop	r8
    4ebe:	08 95       	ret
  this->mod->hal->pinMode(this->mod->getGpio(), this->mod->hal->GpioModeInput);

  // try to find the SX127x chip
  if(!SX127x::findChip(chipVersion)) {
    RADIOLIB_DEBUG_PRINTLN("No SX127x found!");
    this->mod->term();
    4ec0:	c7 5e       	subi	r28, 0xE7	; 231
    4ec2:	de 4f       	sbci	r29, 0xFE	; 254
    4ec4:	88 81       	ld	r24, Y
    4ec6:	99 81       	ldd	r25, Y+1	; 0x01
    4ec8:	0e 94 4b 0a 	call	0x1496	; 0x1496 <_ZN6Module4termEv>
    return(RADIOLIB_ERR_CHIP_NOT_FOUND);
    4ecc:	8e ef       	ldi	r24, 0xFE	; 254
    4ece:	9f ef       	ldi	r25, 0xFF	; 255
    4ed0:	ea cf       	rjmp	.-44     	; 0x4ea6 <_ZN6SX127x5beginEhhj+0xb6>
  // set mode to standby
  int16_t state = standby();
  RADIOLIB_ASSERT(state);

  // configure settings not accessible by API
  state = config();
    4ed2:	ce 01       	movw	r24, r28
    4ed4:	0e 94 a8 18 	call	0x3150	; 0x3150 <_ZN6SX127x6configEv>
  RADIOLIB_ASSERT(state);
    4ed8:	00 97       	sbiw	r24, 0x00	; 0
    4eda:	29 f7       	brne	.-54     	; 0x4ea6 <_ZN6SX127x5beginEhhj+0xb6>

  // check active modem
  if(getActiveModem() != RADIOLIB_SX127X_LORA) {
    4edc:	ce 01       	movw	r24, r28
    4ede:	0e 94 ec 18 	call	0x31d8	; 0x31d8 <_ZN6SX127x14getActiveModemEv>
    4ee2:	80 38       	cpi	r24, 0x80	; 128
    4ee4:	91 05       	cpc	r25, r1
    4ee6:	31 f0       	breq	.+12     	; 0x4ef4 <_ZN6SX127x5beginEhhj+0x104>
    // set LoRa mode
    state = setActiveModem(RADIOLIB_SX127X_LORA);
    4ee8:	60 e8       	ldi	r22, 0x80	; 128
    4eea:	ce 01       	movw	r24, r28
    4eec:	0e 94 da 19 	call	0x33b4	; 0x33b4 <_ZN6SX127x14setActiveModemEh>
    RADIOLIB_ASSERT(state);
    4ef0:	00 97       	sbiw	r24, 0x00	; 0
    4ef2:	c9 f6       	brne	.-78     	; 0x4ea6 <_ZN6SX127x5beginEhhj+0xb6>
  }

  // set LoRa sync word
  state = SX127x::setSyncWord(syncWord);
    4ef4:	6a 2d       	mov	r22, r10
    4ef6:	ce 01       	movw	r24, r28
    4ef8:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN6SX127x11setSyncWordEh>
  RADIOLIB_ASSERT(state);
    4efc:	00 97       	sbiw	r24, 0x00	; 0
    4efe:	99 f6       	brne	.-90     	; 0x4ea6 <_ZN6SX127x5beginEhhj+0xb6>

  // set over current protection
  state = SX127x::setCurrentLimit(60);
    4f00:	6c e3       	ldi	r22, 0x3C	; 60
    4f02:	ce 01       	movw	r24, r28
    4f04:	0e 94 0b 1a 	call	0x3416	; 0x3416 <_ZN6SX127x15setCurrentLimitEh>
  RADIOLIB_ASSERT(state);
    4f08:	00 97       	sbiw	r24, 0x00	; 0
    4f0a:	69 f6       	brne	.-102    	; 0x4ea6 <_ZN6SX127x5beginEhhj+0xb6>

  // set preamble length
  state = SX127x::setPreambleLength(preambleLength);
    4f0c:	b6 01       	movw	r22, r12
    4f0e:	ce 01       	movw	r24, r28
    4f10:	0e 94 f3 1e 	call	0x3de6	; 0x3de6 <_ZN6SX127x17setPreambleLengthEj>
  RADIOLIB_ASSERT(state);
    4f14:	00 97       	sbiw	r24, 0x00	; 0
    4f16:	39 f6       	brne	.-114    	; 0x4ea6 <_ZN6SX127x5beginEhhj+0xb6>

  // disable IQ inversion
  state = SX127x::invertIQ(false);
    4f18:	60 e0       	ldi	r22, 0x00	; 0
    4f1a:	ce 01       	movw	r24, r28
    4f1c:	0e 94 f8 18 	call	0x31f0	; 0x31f0 <_ZN6SX127x8invertIQEb>
  RADIOLIB_ASSERT(state);
    4f20:	00 97       	sbiw	r24, 0x00	; 0
    4f22:	09 f6       	brne	.-126    	; 0x4ea6 <_ZN6SX127x5beginEhhj+0xb6>

  // initialize internal variables
  this->dataRate = 0.0;
    4f24:	c2 5d       	subi	r28, 0xD2	; 210
    4f26:	de 4f       	sbci	r29, 0xFE	; 254
    4f28:	18 82       	st	Y, r1
    4f2a:	19 82       	std	Y+1, r1	; 0x01
    4f2c:	1a 82       	std	Y+2, r1	; 0x02
    4f2e:	1b 82       	std	Y+3, r1	; 0x03
    4f30:	ba cf       	rjmp	.-140    	; 0x4ea6 <_ZN6SX127x5beginEhhj+0xb6>

00004f32 <_ZN6SX12785beginEffhhhajh>:

SX1278::SX1278(Module* mod) : SX127x(mod) {

}

int16_t SX1278::begin(float freq, float bw, uint8_t sf, uint8_t cr, uint8_t syncWord, int8_t power, uint16_t preambleLength, uint8_t gain) {
    4f32:	6f 92       	push	r6
    4f34:	7f 92       	push	r7
    4f36:	8f 92       	push	r8
    4f38:	af 92       	push	r10
    4f3a:	cf 92       	push	r12
    4f3c:	ef 92       	push	r14
    4f3e:	0f 93       	push	r16
    4f40:	1f 93       	push	r17
    4f42:	cf 93       	push	r28
    4f44:	df 93       	push	r29
    4f46:	cd b7       	in	r28, 0x3d	; 61
    4f48:	de b7       	in	r29, 0x3e	; 62
    4f4a:	28 97       	sbiw	r28, 0x08	; 8
    4f4c:	0f b6       	in	r0, 0x3f	; 63
    4f4e:	f8 94       	cli
    4f50:	de bf       	out	0x3e, r29	; 62
    4f52:	0f be       	out	0x3f, r0	; 63
    4f54:	cd bf       	out	0x3d, r28	; 61
    4f56:	3c 01       	movw	r6, r24
    4f58:	4d 83       	std	Y+5, r20	; 0x05
    4f5a:	5e 83       	std	Y+6, r21	; 0x06
    4f5c:	6f 83       	std	Y+7, r22	; 0x07
    4f5e:	78 87       	std	Y+8, r23	; 0x08
    4f60:	09 83       	std	Y+1, r16	; 0x01
    4f62:	1a 83       	std	Y+2, r17	; 0x02
    4f64:	2b 83       	std	Y+3, r18	; 0x03
    4f66:	3c 83       	std	Y+4, r19	; 0x04
    4f68:	4a 2d       	mov	r20, r10
  // execute common part
  int16_t state = SX127x::begin(RADIOLIB_SX1278_CHIP_VERSION, syncWord, preambleLength);
    4f6a:	2d 89       	ldd	r18, Y+21	; 0x15
    4f6c:	3e 89       	ldd	r19, Y+22	; 0x16
    4f6e:	62 e1       	ldi	r22, 0x12	; 18
    4f70:	0e 94 f8 26 	call	0x4df0	; 0x4df0 <_ZN6SX127x5beginEhhj>
  RADIOLIB_ASSERT(state);
    4f74:	00 97       	sbiw	r24, 0x00	; 0
    4f76:	89 f0       	breq	.+34     	; 0x4f9a <_ZN6SX12785beginEffhhhajh+0x68>
  // set publicly accessible settings that are not a part of begin method
  state = setCRC(true);
  RADIOLIB_ASSERT(state);

  return(state);
}
    4f78:	28 96       	adiw	r28, 0x08	; 8
    4f7a:	0f b6       	in	r0, 0x3f	; 63
    4f7c:	f8 94       	cli
    4f7e:	de bf       	out	0x3e, r29	; 62
    4f80:	0f be       	out	0x3f, r0	; 63
    4f82:	cd bf       	out	0x3d, r28	; 61
    4f84:	df 91       	pop	r29
    4f86:	cf 91       	pop	r28
    4f88:	1f 91       	pop	r17
    4f8a:	0f 91       	pop	r16
    4f8c:	ef 90       	pop	r14
    4f8e:	cf 90       	pop	r12
    4f90:	af 90       	pop	r10
    4f92:	8f 90       	pop	r8
    4f94:	7f 90       	pop	r7
    4f96:	6f 90       	pop	r6
    4f98:	08 95       	ret
  // execute common part
  int16_t state = SX127x::begin(RADIOLIB_SX1278_CHIP_VERSION, syncWord, preambleLength);
  RADIOLIB_ASSERT(state);

  // configure publicly accessible settings
  state = setBandwidth(bw);
    4f9a:	49 81       	ldd	r20, Y+1	; 0x01
    4f9c:	5a 81       	ldd	r21, Y+2	; 0x02
    4f9e:	6b 81       	ldd	r22, Y+3	; 0x03
    4fa0:	7c 81       	ldd	r23, Y+4	; 0x04
    4fa2:	c3 01       	movw	r24, r6
    4fa4:	0e 94 26 25 	call	0x4a4c	; 0x4a4c <_ZN6SX127812setBandwidthEf>
  RADIOLIB_ASSERT(state);
    4fa8:	00 97       	sbiw	r24, 0x00	; 0
    4faa:	31 f7       	brne	.-52     	; 0x4f78 <_ZN6SX12785beginEffhhhajh+0x46>

  state = setFrequency(freq);
    4fac:	d3 01       	movw	r26, r6
    4fae:	ed 91       	ld	r30, X+
    4fb0:	fc 91       	ld	r31, X
    4fb2:	00 8c       	ldd	r0, Z+24	; 0x18
    4fb4:	f1 8d       	ldd	r31, Z+25	; 0x19
    4fb6:	e0 2d       	mov	r30, r0
    4fb8:	4d 81       	ldd	r20, Y+5	; 0x05
    4fba:	5e 81       	ldd	r21, Y+6	; 0x06
    4fbc:	6f 81       	ldd	r22, Y+7	; 0x07
    4fbe:	78 85       	ldd	r23, Y+8	; 0x08
    4fc0:	c3 01       	movw	r24, r6
    4fc2:	09 95       	icall
  RADIOLIB_ASSERT(state);
    4fc4:	00 97       	sbiw	r24, 0x00	; 0
    4fc6:	c1 f6       	brne	.-80     	; 0x4f78 <_ZN6SX12785beginEffhhhajh+0x46>

  state = setSpreadingFactor(sf);
    4fc8:	6e 2d       	mov	r22, r14
    4fca:	c3 01       	movw	r24, r6
    4fcc:	0e 94 a1 24 	call	0x4942	; 0x4942 <_ZN6SX127818setSpreadingFactorEh>
  RADIOLIB_ASSERT(state);
    4fd0:	00 97       	sbiw	r24, 0x00	; 0
    4fd2:	91 f6       	brne	.-92     	; 0x4f78 <_ZN6SX12785beginEffhhhajh+0x46>

  state = setCodingRate(cr);
    4fd4:	6c 2d       	mov	r22, r12
    4fd6:	c3 01       	movw	r24, r6
    4fd8:	0e 94 74 24 	call	0x48e8	; 0x48e8 <_ZN6SX127813setCodingRateEh>
  RADIOLIB_ASSERT(state);
    4fdc:	00 97       	sbiw	r24, 0x00	; 0
    4fde:	61 f6       	brne	.-104    	; 0x4f78 <_ZN6SX12785beginEffhhhajh+0x46>

  state = setOutputPower(power);
    4fe0:	d3 01       	movw	r26, r6
    4fe2:	ed 91       	ld	r30, X+
    4fe4:	fc 91       	ld	r31, X
    4fe6:	04 a0       	ldd	r0, Z+36	; 0x24
    4fe8:	f5 a1       	ldd	r31, Z+37	; 0x25
    4fea:	e0 2d       	mov	r30, r0
    4fec:	68 2d       	mov	r22, r8
    4fee:	c3 01       	movw	r24, r6
    4ff0:	09 95       	icall
  RADIOLIB_ASSERT(state);
    4ff2:	00 97       	sbiw	r24, 0x00	; 0
    4ff4:	09 f6       	brne	.-126    	; 0x4f78 <_ZN6SX12785beginEffhhhajh+0x46>

  state = setGain(gain);
    4ff6:	6f 89       	ldd	r22, Y+23	; 0x17
    4ff8:	c3 01       	movw	r24, r6
    4ffa:	0e 94 dd 23 	call	0x47ba	; 0x47ba <_ZN6SX12787setGainEh>
  RADIOLIB_ASSERT(state);
    4ffe:	00 97       	sbiw	r24, 0x00	; 0
    5000:	09 f0       	breq	.+2      	; 0x5004 <_ZN6SX12785beginEffhhhajh+0xd2>
    5002:	ba cf       	rjmp	.-140    	; 0x4f78 <_ZN6SX12785beginEffhhhajh+0x46>

  // set publicly accessible settings that are not a part of begin method
  state = setCRC(true);
    5004:	40 e0       	ldi	r20, 0x00	; 0
    5006:	61 e0       	ldi	r22, 0x01	; 1
    5008:	c3 01       	movw	r24, r6
    500a:	0e 94 71 22 	call	0x44e2	; 0x44e2 <_ZN6SX12786setCRCEbb>
    500e:	b4 cf       	rjmp	.-152    	; 0x4f78 <_ZN6SX12785beginEffhhhajh+0x46>

00005010 <_ZN3gel5Radio5beginENS_9RadioPinsENS_11RadioConfigE>:

uint8_t Radio::numInstances = 0;
Radio* Radio::instances[RADIO_MAX_INSTANCES] = {};

Error Radio::begin(RadioPins pins, RadioConfig config)
{
    5010:	2f 92       	push	r2
    5012:	3f 92       	push	r3
    5014:	4f 92       	push	r4
    5016:	5f 92       	push	r5
    5018:	6f 92       	push	r6
    501a:	7f 92       	push	r7
    501c:	8f 92       	push	r8
    501e:	9f 92       	push	r9
    5020:	af 92       	push	r10
    5022:	bf 92       	push	r11
    5024:	cf 92       	push	r12
    5026:	df 92       	push	r13
    5028:	ef 92       	push	r14
    502a:	ff 92       	push	r15
    502c:	0f 93       	push	r16
    502e:	1f 93       	push	r17
    5030:	cf 93       	push	r28
    5032:	df 93       	push	r29
    5034:	cd b7       	in	r28, 0x3d	; 61
    5036:	de b7       	in	r29, 0x3e	; 62
    5038:	cc 53       	subi	r28, 0x3C	; 60
    503a:	d1 40       	sbci	r29, 0x01	; 1
    503c:	0f b6       	in	r0, 0x3f	; 63
    503e:	f8 94       	cli
    5040:	de bf       	out	0x3e, r29	; 62
    5042:	0f be       	out	0x3f, r0	; 63
    5044:	cd bf       	out	0x3d, r28	; 61
    5046:	c5 5c       	subi	r28, 0xC5	; 197
    5048:	de 4f       	sbci	r29, 0xFE	; 254
    504a:	99 83       	std	Y+1, r25	; 0x01
    504c:	88 83       	st	Y, r24
    504e:	cb 53       	subi	r28, 0x3B	; 59
    5050:	d1 40       	sbci	r29, 0x01	; 1
    5052:	2b 01       	movw	r4, r22
    5054:	3a 01       	movw	r6, r20
    5056:	19 01       	movw	r2, r18
    if (numInstances == RADIO_MAX_INSTANCES)
    5058:	80 91 db 06 	lds	r24, 0x06DB	; 0x8006db <_ZN3gel5Radio12numInstancesE>
    505c:	82 30       	cpi	r24, 0x02	; 2
    505e:	09 f4       	brne	.+2      	; 0x5062 <_ZN3gel5Radio5beginENS_9RadioPinsENS_11RadioConfigE+0x52>
    5060:	e9 c0       	rjmp	.+466    	; 0x5234 <_ZN3gel5Radio5beginENS_9RadioPinsENS_11RadioConfigE+0x224>
        return Error::CapacityFull;

    this->pins = pins;
    5062:	fb 01       	movw	r30, r22
    5064:	31 96       	adiw	r30, 0x01	; 1
    optional<size_t> payloadLength = nullopt;               // Must be specified for "fixed length" modes
    ModulationType modType = ModulationType::LoRa;
    ModulationConfig modConfig{};
};

struct RadioPins
    5066:	da 01       	movw	r26, r20
    5068:	8c 91       	ld	r24, X
    506a:	db 01       	movw	r26, r22
    506c:	11 96       	adiw	r26, 0x01	; 1
    506e:	8c 93       	st	X, r24
    5070:	da 01       	movw	r26, r20
    5072:	11 96       	adiw	r26, 0x01	; 1
    5074:	8c 91       	ld	r24, X
    5076:	11 97       	sbiw	r26, 0x01	; 1
    5078:	81 83       	std	Z+1, r24	; 0x01
    507a:	12 96       	adiw	r26, 0x02	; 2
    507c:	8c 91       	ld	r24, X
    507e:	12 97       	sbiw	r26, 0x02	; 2
    5080:	82 83       	std	Z+2, r24	; 0x02
    //***************************************************************************
    /// Assignment operator from optional.
    //***************************************************************************
    ETL_CONSTEXPR14 optional& operator =(const optional& other)
    {
      if (this != &other)
    5082:	e4 17       	cp	r30, r20
    5084:	f5 07       	cpc	r31, r21
    5086:	39 f0       	breq	.+14     	; 0x5096 <_ZN3gel5Radio5beginENS_9RadioPinsENS_11RadioConfigE+0x86>
      {
        storage.value = other.storage.value;
    5088:	14 96       	adiw	r26, 0x04	; 4
    508a:	8c 91       	ld	r24, X
    508c:	14 97       	sbiw	r26, 0x04	; 4
    508e:	84 83       	std	Z+4, r24	; 0x04
        valid = other.valid;
    5090:	13 96       	adiw	r26, 0x03	; 3
    5092:	8c 91       	ld	r24, X
    5094:	83 83       	std	Z+3, r24	; 0x03
    //***************************************************************************
    /// Assignment operator from optional.
    //***************************************************************************
    ETL_CONSTEXPR14 optional& operator =(const optional& other)
    {
      if (this != &other)
    5096:	e6 15       	cp	r30, r6
    5098:	f7 05       	cpc	r31, r7
    509a:	41 f0       	breq	.+16     	; 0x50ac <_ZN3gel5Radio5beginENS_9RadioPinsENS_11RadioConfigE+0x9c>
      {
        storage.value = other.storage.value;
    509c:	d3 01       	movw	r26, r6
    509e:	16 96       	adiw	r26, 0x06	; 6
    50a0:	8c 91       	ld	r24, X
    50a2:	16 97       	sbiw	r26, 0x06	; 6
    50a4:	86 83       	std	Z+6, r24	; 0x06
        valid = other.valid;
    50a6:	15 96       	adiw	r26, 0x05	; 5
    50a8:	8c 91       	ld	r24, X
    50aa:	85 83       	std	Z+5, r24	; 0x05
    //***************************************************************************
    /// Assignment operator from optional.
    //***************************************************************************
    ETL_CONSTEXPR14 optional& operator =(const optional& other)
    {
      if (this != &other)
    50ac:	e6 15       	cp	r30, r6
    50ae:	f7 05       	cpc	r31, r7
    50b0:	41 f0       	breq	.+16     	; 0x50c2 <_ZN3gel5Radio5beginENS_9RadioPinsENS_11RadioConfigE+0xb2>
      {
        storage.value = other.storage.value;
    50b2:	d3 01       	movw	r26, r6
    50b4:	18 96       	adiw	r26, 0x08	; 8
    50b6:	8c 91       	ld	r24, X
    50b8:	18 97       	sbiw	r26, 0x08	; 8
    50ba:	80 87       	std	Z+8, r24	; 0x08
        valid = other.valid;
    50bc:	17 96       	adiw	r26, 0x07	; 7
    50be:	8c 91       	ld	r24, X
    50c0:	87 83       	std	Z+7, r24	; 0x07
    //***************************************************************************
    /// Assignment operator from optional.
    //***************************************************************************
    ETL_CONSTEXPR14 optional& operator =(const optional& other)
    {
      if (this != &other)
    50c2:	e6 15       	cp	r30, r6
    50c4:	f7 05       	cpc	r31, r7
    50c6:	41 f0       	breq	.+16     	; 0x50d8 <_ZN3gel5Radio5beginENS_9RadioPinsENS_11RadioConfigE+0xc8>
      {
        storage.value = other.storage.value;
    50c8:	d3 01       	movw	r26, r6
    50ca:	1a 96       	adiw	r26, 0x0a	; 10
    50cc:	8c 91       	ld	r24, X
    50ce:	1a 97       	sbiw	r26, 0x0a	; 10
    50d0:	82 87       	std	Z+10, r24	; 0x0a
        valid = other.valid;
    50d2:	19 96       	adiw	r26, 0x09	; 9
    50d4:	8c 91       	ld	r24, X
    50d6:	81 87       	std	Z+9, r24	; 0x09
    //***************************************************************************
    /// Assignment operator from optional.
    //***************************************************************************
    ETL_CONSTEXPR14 optional& operator =(const optional& other)
    {
      if (this != &other)
    50d8:	e6 15       	cp	r30, r6
    50da:	f7 05       	cpc	r31, r7
    50dc:	51 f0       	breq	.+20     	; 0x50f2 <_ZN3gel5Radio5beginENS_9RadioPinsENS_11RadioConfigE+0xe2>
      {
        storage.value = other.storage.value;
    50de:	d3 01       	movw	r26, r6
    50e0:	1c 96       	adiw	r26, 0x0c	; 12
    50e2:	8d 91       	ld	r24, X+
    50e4:	9c 91       	ld	r25, X
    50e6:	1d 97       	sbiw	r26, 0x0d	; 13
    50e8:	95 87       	std	Z+13, r25	; 0x0d
    50ea:	84 87       	std	Z+12, r24	; 0x0c
        valid = other.valid;
    50ec:	1b 96       	adiw	r26, 0x0b	; 11
    50ee:	8c 91       	ld	r24, X
    50f0:	83 87       	std	Z+11, r24	; 0x0b
{   
    LoRaConfig lora;
    FSKConfig fsk;
};

struct RadioConfig
    50f2:	f1 01       	movw	r30, r2
    50f4:	80 81       	ld	r24, Z
    50f6:	91 81       	ldd	r25, Z+1	; 0x01
    50f8:	a2 81       	ldd	r26, Z+2	; 0x02
    50fa:	b3 81       	ldd	r27, Z+3	; 0x03
    50fc:	f2 01       	movw	r30, r4
    50fe:	87 87       	std	Z+15, r24	; 0x0f
    5100:	90 8b       	std	Z+16, r25	; 0x10
    5102:	a1 8b       	std	Z+17, r26	; 0x11
    5104:	b2 8b       	std	Z+18, r27	; 0x12
    5106:	f1 01       	movw	r30, r2
    5108:	84 81       	ldd	r24, Z+4	; 0x04
    510a:	95 81       	ldd	r25, Z+5	; 0x05
    510c:	a6 81       	ldd	r26, Z+6	; 0x06
    510e:	b7 81       	ldd	r27, Z+7	; 0x07
    5110:	f2 01       	movw	r30, r4
    5112:	83 8b       	std	Z+19, r24	; 0x13
    5114:	94 8b       	std	Z+20, r25	; 0x14
    5116:	a5 8b       	std	Z+21, r26	; 0x15
    5118:	b6 8b       	std	Z+22, r27	; 0x16
    511a:	d1 01       	movw	r26, r2
    511c:	18 96       	adiw	r26, 0x08	; 8
    511e:	8c 91       	ld	r24, X
    5120:	18 97       	sbiw	r26, 0x08	; 8
    5122:	87 8b       	std	Z+23, r24	; 0x17
    5124:	19 96       	adiw	r26, 0x09	; 9
    5126:	8c 91       	ld	r24, X
    5128:	19 97       	sbiw	r26, 0x09	; 9
    512a:	80 8f       	std	Z+24, r24	; 0x18
    //***************************************************************************
    /// Assignment operator from optional.
    //***************************************************************************
    ETL_CONSTEXPR14 optional& operator =(const optional& other)
    {
      if (this != &other)
    512c:	c2 01       	movw	r24, r4
    512e:	0f 96       	adiw	r24, 0x0f	; 15
    5130:	82 15       	cp	r24, r2
    5132:	93 05       	cpc	r25, r3
    5134:	49 f0       	breq	.+18     	; 0x5148 <_ZN3gel5Radio5beginENS_9RadioPinsENS_11RadioConfigE+0x138>
      {
        storage.value = other.storage.value;
    5136:	1b 96       	adiw	r26, 0x0b	; 11
    5138:	8d 91       	ld	r24, X+
    513a:	9c 91       	ld	r25, X
    513c:	1c 97       	sbiw	r26, 0x0c	; 12
    513e:	93 8f       	std	Z+27, r25	; 0x1b
    5140:	82 8f       	std	Z+26, r24	; 0x1a
        valid = other.valid;
    5142:	1a 96       	adiw	r26, 0x0a	; 10
    5144:	8c 91       	ld	r24, X
    5146:	81 8f       	std	Z+25, r24	; 0x19
    5148:	f1 01       	movw	r30, r2
    514a:	85 85       	ldd	r24, Z+13	; 0x0d
    514c:	96 85       	ldd	r25, Z+14	; 0x0e
    514e:	d2 01       	movw	r26, r4
    5150:	5d 96       	adiw	r26, 0x1d	; 29
    5152:	9c 93       	st	X, r25
    5154:	8e 93       	st	-X, r24
    5156:	5c 97       	sbiw	r26, 0x1c	; 28
    5158:	80 e1       	ldi	r24, 0x10	; 16
    515a:	3f 96       	adiw	r30, 0x0f	; 15
    515c:	5e 96       	adiw	r26, 0x1e	; 30
    515e:	01 90       	ld	r0, Z+
    5160:	0d 92       	st	X+, r0
    5162:	8a 95       	dec	r24
    5164:	e1 f7       	brne	.-8      	; 0x515e <_ZN3gel5Radio5beginENS_9RadioPinsENS_11RadioConfigE+0x14e>
    //***************************************************************************
    // Check whether optional contains value
    //***************************************************************************
    ETL_CONSTEXPR14 bool has_value() const ETL_NOEXCEPT
    {
      return valid;
    5166:	f3 01       	movw	r30, r6
    5168:	83 81       	ldd	r24, Z+3	; 0x03
    this->config = config;
    
    if (pins.dio1.has_value())
    516a:	88 23       	and	r24, r24
    516c:	09 f4       	brne	.+2      	; 0x5170 <_ZN3gel5Radio5beginENS_9RadioPinsENS_11RadioConfigE+0x160>
    516e:	97 c0       	rjmp	.+302    	; 0x529e <_ZN3gel5Radio5beginENS_9RadioPinsENS_11RadioConfigE+0x28e>
        radio = new Module(pins.nss, pins.dio0, pins.reset, pins.dio1.value());
    5170:	84 80       	ldd	r8, Z+4	; 0x04
    5172:	91 2c       	mov	r9, r1
    5174:	b1 2c       	mov	r11, r1
    5176:	a1 2c       	mov	r10, r1
    5178:	8a e2       	ldi	r24, 0x2A	; 42
    517a:	90 e0       	ldi	r25, 0x00	; 0
    517c:	0e 94 22 0f 	call	0x1e44	; 0x1e44 <_Znwj>
    5180:	c9 5c       	subi	r28, 0xC9	; 201
    5182:	de 4f       	sbci	r29, 0xFE	; 254
    5184:	99 83       	std	Y+1, r25	; 0x01
    5186:	88 83       	st	Y, r24
    5188:	c7 53       	subi	r28, 0x37	; 55
    518a:	d1 40       	sbci	r29, 0x01	; 1
    518c:	d3 01       	movw	r26, r6
    518e:	11 96       	adiw	r26, 0x01	; 1
    5190:	cc 90       	ld	r12, X
    5192:	11 97       	sbiw	r26, 0x01	; 1
    5194:	12 96       	adiw	r26, 0x02	; 2
    5196:	0c 91       	ld	r16, X
    5198:	12 97       	sbiw	r26, 0x02	; 2
    519a:	4c 91       	ld	r20, X
    519c:	d1 2c       	mov	r13, r1
    519e:	f1 2c       	mov	r15, r1
    51a0:	e1 2c       	mov	r14, r1
    51a2:	10 e0       	ldi	r17, 0x00	; 0
    51a4:	30 e0       	ldi	r19, 0x00	; 0
    51a6:	20 e0       	ldi	r18, 0x00	; 0
    51a8:	50 e0       	ldi	r21, 0x00	; 0
    51aa:	70 e0       	ldi	r23, 0x00	; 0
    51ac:	60 e0       	ldi	r22, 0x00	; 0
    51ae:	0e 94 25 0f 	call	0x1e4a	; 0x1e4a <_ZN6ModuleC1Emmmm>
    51b2:	c9 5c       	subi	r28, 0xC9	; 201
    51b4:	de 4f       	sbci	r29, 0xFE	; 254
    51b6:	68 81       	ld	r22, Y
    51b8:	79 81       	ldd	r23, Y+1	; 0x01
    51ba:	c7 53       	subi	r28, 0x37	; 55
    51bc:	d1 40       	sbci	r29, 0x01	; 1
    51be:	ce 01       	movw	r24, r28
    51c0:	01 96       	adiw	r24, 0x01	; 1
    51c2:	0e 94 c9 0d 	call	0x1b92	; 0x1b92 <_ZN6SX1278C1EP6Module>
/*!
  \class SX1278
  \brief Derived class for %SX1278 modules. Also used as base class for SX1276, SX1277, SX1279, RFM95 and RFM96.
  All of these modules use the same basic hardware and only differ in parameter ranges (and names).
*/
class SX1278: public SX127x {
    51c6:	be 01       	movw	r22, r28
    51c8:	6f 5f       	subi	r22, 0xFF	; 255
    51ca:	7f 4f       	sbci	r23, 0xFF	; 255
    51cc:	c2 01       	movw	r24, r4
    51ce:	c4 96       	adiw	r24, 0x34	; 52
    51d0:	0e 94 02 07 	call	0xe04	; 0xe04 <_ZN6SX127xaSEOS_>
    51d4:	cb 5c       	subi	r28, 0xCB	; 203
    51d6:	de 4f       	sbci	r29, 0xFE	; 254
    51d8:	88 81       	ld	r24, Y
    51da:	c5 53       	subi	r28, 0x35	; 53
    51dc:	d1 40       	sbci	r29, 0x01	; 1
    51de:	f2 01       	movw	r30, r4
    51e0:	e8 59       	subi	r30, 0x98	; 152
    51e2:	fe 4f       	sbci	r31, 0xFE	; 254
    51e4:	80 83       	st	Z, r24
    51e6:	ca 5c       	subi	r28, 0xCA	; 202
    51e8:	de 4f       	sbci	r29, 0xFE	; 254
    51ea:	88 81       	ld	r24, Y
    51ec:	c6 53       	subi	r28, 0x36	; 54
    51ee:	d1 40       	sbci	r29, 0x01	; 1
    51f0:	31 96       	adiw	r30, 0x01	; 1
    51f2:	80 83       	st	Z, r24
    51f4:	d3 01       	movw	r26, r6
    51f6:	1b 96       	adiw	r26, 0x0b	; 11
    51f8:	8c 91       	ld	r24, X
    else
        radio = new Module(pins.nss, pins.dio0, pins.reset);

    if (pins.SPI.has_value())
    51fa:	81 11       	cpse	r24, r1
    51fc:	8f c0       	rjmp	.+286    	; 0x531c <_ZN3gel5Radio5beginENS_9RadioPinsENS_11RadioConfigE+0x30c>
        return Error::NotImplemented;

    int err = Error::None;
    switch (config.modType)
    51fe:	d1 01       	movw	r26, r2
    5200:	1d 96       	adiw	r26, 0x0d	; 13
    5202:	8d 91       	ld	r24, X+
    5204:	9c 91       	ld	r25, X
    5206:	00 97       	sbiw	r24, 0x00	; 0
    5208:	09 f4       	brne	.+2      	; 0x520c <_ZN3gel5Radio5beginENS_9RadioPinsENS_11RadioConfigE+0x1fc>
    520a:	99 c0       	rjmp	.+306    	; 0x533e <_ZN3gel5Radio5beginENS_9RadioPinsENS_11RadioConfigE+0x32e>
    520c:	01 97       	sbiw	r24, 0x01	; 1
    520e:	09 f4       	brne	.+2      	; 0x5212 <_ZN3gel5Radio5beginENS_9RadioPinsENS_11RadioConfigE+0x202>
    5210:	f5 c0       	rjmp	.+490    	; 0x53fc <_ZN3gel5Radio5beginENS_9RadioPinsENS_11RadioConfigE+0x3ec>
    5212:	8c e8       	ldi	r24, 0x8C	; 140
    5214:	92 e0       	ldi	r25, 0x02	; 2
    5216:	c5 5c       	subi	r28, 0xC5	; 197
    5218:	de 4f       	sbci	r29, 0xFE	; 254
    521a:	e8 81       	ld	r30, Y
    521c:	f9 81       	ldd	r31, Y+1	; 0x01
    521e:	cb 53       	subi	r28, 0x3B	; 59
    5220:	d1 40       	sbci	r29, 0x01	; 1
    5222:	91 83       	std	Z+1, r25	; 0x01
    5224:	80 83       	st	Z, r24
    5226:	83 e0       	ldi	r24, 0x03	; 3
    5228:	90 e0       	ldi	r25, 0x00	; 0
    522a:	93 83       	std	Z+3, r25	; 0x03
    522c:	82 83       	std	Z+2, r24	; 0x02
    522e:	15 82       	std	Z+5, r1	; 0x05
    5230:	14 82       	std	Z+4, r1	; 0x04
    5232:	15 c0       	rjmp	.+42     	; 0x525e <_ZN3gel5Radio5beginENS_9RadioPinsENS_11RadioConfigE+0x24e>
    5234:	8c e8       	ldi	r24, 0x8C	; 140
    5236:	92 e0       	ldi	r25, 0x02	; 2
    5238:	c5 5c       	subi	r28, 0xC5	; 197
    523a:	de 4f       	sbci	r29, 0xFE	; 254
    523c:	a8 81       	ld	r26, Y
    523e:	b9 81       	ldd	r27, Y+1	; 0x01
    5240:	cb 53       	subi	r28, 0x3B	; 59
    5242:	d1 40       	sbci	r29, 0x01	; 1
    5244:	11 96       	adiw	r26, 0x01	; 1
    5246:	9c 93       	st	X, r25
    5248:	8e 93       	st	-X, r24
    524a:	88 e0       	ldi	r24, 0x08	; 8
    524c:	90 e0       	ldi	r25, 0x00	; 0
    524e:	13 96       	adiw	r26, 0x03	; 3
    5250:	9c 93       	st	X, r25
    5252:	8e 93       	st	-X, r24
    5254:	12 97       	sbiw	r26, 0x02	; 2
    5256:	15 96       	adiw	r26, 0x05	; 5
    5258:	1c 92       	st	X, r1
    525a:	1e 92       	st	-X, r1
    525c:	14 97       	sbiw	r26, 0x04	; 4
        case 1: radio.setDio0Action(callback1, RISING); break;
    }
    
    initialized = true;
    return standby();
}
    525e:	c5 5c       	subi	r28, 0xC5	; 197
    5260:	de 4f       	sbci	r29, 0xFE	; 254
    5262:	88 81       	ld	r24, Y
    5264:	99 81       	ldd	r25, Y+1	; 0x01
    5266:	cb 53       	subi	r28, 0x3B	; 59
    5268:	d1 40       	sbci	r29, 0x01	; 1
    526a:	c4 5c       	subi	r28, 0xC4	; 196
    526c:	de 4f       	sbci	r29, 0xFE	; 254
    526e:	0f b6       	in	r0, 0x3f	; 63
    5270:	f8 94       	cli
    5272:	de bf       	out	0x3e, r29	; 62
    5274:	0f be       	out	0x3f, r0	; 63
    5276:	cd bf       	out	0x3d, r28	; 61
    5278:	df 91       	pop	r29
    527a:	cf 91       	pop	r28
    527c:	1f 91       	pop	r17
    527e:	0f 91       	pop	r16
    5280:	ff 90       	pop	r15
    5282:	ef 90       	pop	r14
    5284:	df 90       	pop	r13
    5286:	cf 90       	pop	r12
    5288:	bf 90       	pop	r11
    528a:	af 90       	pop	r10
    528c:	9f 90       	pop	r9
    528e:	8f 90       	pop	r8
    5290:	7f 90       	pop	r7
    5292:	6f 90       	pop	r6
    5294:	5f 90       	pop	r5
    5296:	4f 90       	pop	r4
    5298:	3f 90       	pop	r3
    529a:	2f 90       	pop	r2
    529c:	08 95       	ret
    this->config = config;
    
    if (pins.dio1.has_value())
        radio = new Module(pins.nss, pins.dio0, pins.reset, pins.dio1.value());
    else
        radio = new Module(pins.nss, pins.dio0, pins.reset);
    529e:	8a e2       	ldi	r24, 0x2A	; 42
    52a0:	90 e0       	ldi	r25, 0x00	; 0
    52a2:	0e 94 22 0f 	call	0x1e44	; 0x1e44 <_Znwj>
    52a6:	c9 5c       	subi	r28, 0xC9	; 201
    52a8:	de 4f       	sbci	r29, 0xFE	; 254
    52aa:	99 83       	std	Y+1, r25	; 0x01
    52ac:	88 83       	st	Y, r24
    52ae:	c7 53       	subi	r28, 0x37	; 55
    52b0:	d1 40       	sbci	r29, 0x01	; 1
    52b2:	f3 01       	movw	r30, r6
    52b4:	c1 80       	ldd	r12, Z+1	; 0x01
    52b6:	02 81       	ldd	r16, Z+2	; 0x02
    52b8:	40 81       	ld	r20, Z
    52ba:	d1 2c       	mov	r13, r1
    52bc:	f1 2c       	mov	r15, r1
    52be:	e1 2c       	mov	r14, r1
    52c0:	10 e0       	ldi	r17, 0x00	; 0
    52c2:	30 e0       	ldi	r19, 0x00	; 0
    52c4:	20 e0       	ldi	r18, 0x00	; 0
    52c6:	50 e0       	ldi	r21, 0x00	; 0
    52c8:	70 e0       	ldi	r23, 0x00	; 0
    52ca:	60 e0       	ldi	r22, 0x00	; 0
    52cc:	88 24       	eor	r8, r8
    52ce:	8a 94       	dec	r8
    52d0:	98 2c       	mov	r9, r8
    52d2:	54 01       	movw	r10, r8
    52d4:	0e 94 25 0f 	call	0x1e4a	; 0x1e4a <_ZN6ModuleC1Emmmm>
    52d8:	c9 5c       	subi	r28, 0xC9	; 201
    52da:	de 4f       	sbci	r29, 0xFE	; 254
    52dc:	68 81       	ld	r22, Y
    52de:	79 81       	ldd	r23, Y+1	; 0x01
    52e0:	c7 53       	subi	r28, 0x37	; 55
    52e2:	d1 40       	sbci	r29, 0x01	; 1
    52e4:	ce 01       	movw	r24, r28
    52e6:	01 96       	adiw	r24, 0x01	; 1
    52e8:	0e 94 c9 0d 	call	0x1b92	; 0x1b92 <_ZN6SX1278C1EP6Module>
    52ec:	be 01       	movw	r22, r28
    52ee:	6f 5f       	subi	r22, 0xFF	; 255
    52f0:	7f 4f       	sbci	r23, 0xFF	; 255
    52f2:	c2 01       	movw	r24, r4
    52f4:	c4 96       	adiw	r24, 0x34	; 52
    52f6:	0e 94 02 07 	call	0xe04	; 0xe04 <_ZN6SX127xaSEOS_>
    52fa:	cb 5c       	subi	r28, 0xCB	; 203
    52fc:	de 4f       	sbci	r29, 0xFE	; 254
    52fe:	88 81       	ld	r24, Y
    5300:	c5 53       	subi	r28, 0x35	; 53
    5302:	d1 40       	sbci	r29, 0x01	; 1
    5304:	f2 01       	movw	r30, r4
    5306:	e8 59       	subi	r30, 0x98	; 152
    5308:	fe 4f       	sbci	r31, 0xFE	; 254
    530a:	80 83       	st	Z, r24
    530c:	ca 5c       	subi	r28, 0xCA	; 202
    530e:	de 4f       	sbci	r29, 0xFE	; 254
    5310:	88 81       	ld	r24, Y
    5312:	c6 53       	subi	r28, 0x36	; 54
    5314:	d1 40       	sbci	r29, 0x01	; 1
    5316:	31 96       	adiw	r30, 0x01	; 1
    5318:	80 83       	st	Z, r24
    531a:	6c cf       	rjmp	.-296    	; 0x51f4 <_ZN3gel5Radio5beginENS_9RadioPinsENS_11RadioConfigE+0x1e4>
    531c:	8c e8       	ldi	r24, 0x8C	; 140
    531e:	92 e0       	ldi	r25, 0x02	; 2
    5320:	c5 5c       	subi	r28, 0xC5	; 197
    5322:	de 4f       	sbci	r29, 0xFE	; 254
    5324:	e8 81       	ld	r30, Y
    5326:	f9 81       	ldd	r31, Y+1	; 0x01
    5328:	cb 53       	subi	r28, 0x3B	; 59
    532a:	d1 40       	sbci	r29, 0x01	; 1
    532c:	91 83       	std	Z+1, r25	; 0x01
    532e:	80 83       	st	Z, r24
    5330:	89 e0       	ldi	r24, 0x09	; 9
    5332:	90 e0       	ldi	r25, 0x00	; 0
    5334:	93 83       	std	Z+3, r25	; 0x03
    5336:	82 83       	std	Z+2, r24	; 0x02
    5338:	15 82       	std	Z+5, r1	; 0x05
    533a:	14 82       	std	Z+4, r1	; 0x04
    533c:	90 cf       	rjmp	.-224    	; 0x525e <_ZN3gel5Radio5beginENS_9RadioPinsENS_11RadioConfigE+0x24e>
    {
        case ModulationType::LoRa:
        {
            LoRaConfig& loraConfig = config.modConfig.lora;

            err = radio.begin(config.frequency * 1.0e-6,
    533e:	32 01       	movw	r6, r4
    5340:	b4 e3       	ldi	r27, 0x34	; 52
    5342:	6b 0e       	add	r6, r27
    5344:	71 1c       	adc	r7, r1
                              loraConfig.bandwidth * 1.0e-3,
                              loraConfig.spreadingFactor,
                              loraConfig.codeRate,
                              config.syncWord,
                              config.outputPower,
                              config.preambleLength);
    5346:	f1 01       	movw	r30, r2
    5348:	11 85       	ldd	r17, Z+9	; 0x09
            err = radio.begin(config.frequency * 1.0e-6,
                              loraConfig.bandwidth * 1.0e-3,
                              loraConfig.spreadingFactor,
                              loraConfig.codeRate,
                              config.syncWord,
                              config.outputPower,
    534a:	80 84       	ldd	r8, Z+8	; 0x08

            err = radio.begin(config.frequency * 1.0e-6,
                              loraConfig.bandwidth * 1.0e-3,
                              loraConfig.spreadingFactor,
                              loraConfig.codeRate,
                              config.syncWord,
    534c:	a4 80       	ldd	r10, Z+4	; 0x04
    {
        case ModulationType::LoRa:
        {
            LoRaConfig& loraConfig = config.modConfig.lora;

            err = radio.begin(config.frequency * 1.0e-6,
    534e:	c0 88       	ldd	r12, Z+16	; 0x10
    5350:	e7 84       	ldd	r14, Z+15	; 0x0f
                              loraConfig.bandwidth * 1.0e-3,
    5352:	61 89       	ldd	r22, Z+17	; 0x11
    5354:	72 89       	ldd	r23, Z+18	; 0x12
    5356:	83 89       	ldd	r24, Z+19	; 0x13
    5358:	94 89       	ldd	r25, Z+20	; 0x14
    535a:	2f e6       	ldi	r18, 0x6F	; 111
    535c:	32 e1       	ldi	r19, 0x12	; 18
    535e:	43 e8       	ldi	r20, 0x83	; 131
    5360:	5a e3       	ldi	r21, 0x3A	; 58
    5362:	0e 94 d7 39 	call	0x73ae	; 0x73ae <__mulsf3>
    5366:	c9 5c       	subi	r28, 0xC9	; 201
    5368:	de 4f       	sbci	r29, 0xFE	; 254
    536a:	68 83       	st	Y, r22
    536c:	79 83       	std	Y+1, r23	; 0x01
    536e:	8a 83       	std	Y+2, r24	; 0x02
    5370:	9b 83       	std	Y+3, r25	; 0x03
    5372:	c7 53       	subi	r28, 0x37	; 55
    5374:	d1 40       	sbci	r29, 0x01	; 1
    {
        case ModulationType::LoRa:
        {
            LoRaConfig& loraConfig = config.modConfig.lora;

            err = radio.begin(config.frequency * 1.0e-6,
    5376:	d1 01       	movw	r26, r2
    5378:	6d 91       	ld	r22, X+
    537a:	7d 91       	ld	r23, X+
    537c:	8d 91       	ld	r24, X+
    537e:	9c 91       	ld	r25, X
    5380:	2d eb       	ldi	r18, 0xBD	; 189
    5382:	37 e3       	ldi	r19, 0x37	; 55
    5384:	46 e8       	ldi	r20, 0x86	; 134
    5386:	55 e3       	ldi	r21, 0x35	; 53
    5388:	0e 94 d7 39 	call	0x73ae	; 0x73ae <__mulsf3>
    538c:	ab 01       	movw	r20, r22
    538e:	bc 01       	movw	r22, r24
    5390:	1f 92       	push	r1
    5392:	1f 92       	push	r1
    5394:	1f 93       	push	r17
    5396:	c9 5c       	subi	r28, 0xC9	; 201
    5398:	de 4f       	sbci	r29, 0xFE	; 254
    539a:	08 81       	ld	r16, Y
    539c:	19 81       	ldd	r17, Y+1	; 0x01
    539e:	2a 81       	ldd	r18, Y+2	; 0x02
    53a0:	3b 81       	ldd	r19, Y+3	; 0x03
    53a2:	c7 53       	subi	r28, 0x37	; 55
    53a4:	d1 40       	sbci	r29, 0x01	; 1
    53a6:	c3 01       	movw	r24, r6
    53a8:	0e 94 99 27 	call	0x4f32	; 0x4f32 <_ZN6SX12785beginEffhhhajh>
    53ac:	8c 01       	movw	r16, r24
                              loraConfig.codeRate,
                              config.syncWord,
                              config.outputPower,
                              config.preambleLength);

            if (loraConfig.implicitHeader)
    53ae:	f1 01       	movw	r30, r2
    53b0:	85 89       	ldd	r24, Z+21	; 0x15
    53b2:	0f 90       	pop	r0
    53b4:	0f 90       	pop	r0
    53b6:	0f 90       	pop	r0
    53b8:	88 23       	and	r24, r24
    53ba:	f1 f0       	breq	.+60     	; 0x53f8 <_ZN3gel5Radio5beginENS_9RadioPinsENS_11RadioConfigE+0x3e8>
    53bc:	82 85       	ldd	r24, Z+10	; 0x0a
            {
                if (config.payloadLength.has_value())
    53be:	81 11       	cpse	r24, r1
    53c0:	16 c0       	rjmp	.+44     	; 0x53ee <_ZN3gel5Radio5beginENS_9RadioPinsENS_11RadioConfigE+0x3de>
    53c2:	8c e8       	ldi	r24, 0x8C	; 140
    53c4:	92 e0       	ldi	r25, 0x02	; 2
    53c6:	c5 5c       	subi	r28, 0xC5	; 197
    53c8:	de 4f       	sbci	r29, 0xFE	; 254
    53ca:	a8 81       	ld	r26, Y
    53cc:	b9 81       	ldd	r27, Y+1	; 0x01
    53ce:	cb 53       	subi	r28, 0x3B	; 59
    53d0:	d1 40       	sbci	r29, 0x01	; 1
    53d2:	11 96       	adiw	r26, 0x01	; 1
    53d4:	9c 93       	st	X, r25
    53d6:	8e 93       	st	-X, r24
    53d8:	83 e0       	ldi	r24, 0x03	; 3
    53da:	90 e0       	ldi	r25, 0x00	; 0
    53dc:	13 96       	adiw	r26, 0x03	; 3
    53de:	9c 93       	st	X, r25
    53e0:	8e 93       	st	-X, r24
    53e2:	12 97       	sbiw	r26, 0x02	; 2
    53e4:	15 96       	adiw	r26, 0x05	; 5
    53e6:	1c 92       	st	X, r1
    53e8:	1e 92       	st	-X, r1
    53ea:	14 97       	sbiw	r26, 0x04	; 4
    53ec:	38 cf       	rjmp	.-400    	; 0x525e <_ZN3gel5Radio5beginENS_9RadioPinsENS_11RadioConfigE+0x24e>
                    radio.implicitHeader(config.payloadLength.value());
    53ee:	63 85       	ldd	r22, Z+11	; 0x0b
    53f0:	74 85       	ldd	r23, Z+12	; 0x0c
    53f2:	c3 01       	movw	r24, r6
    53f4:	0e 94 6c 22 	call	0x44d8	; 0x44d8 <_ZN6SX127814implicitHeaderEj>

        default:
            return Error::BadParameter;
    }

    if (err != RADIOLIB_ERR_NONE)
    53f8:	01 2b       	or	r16, r17
    53fa:	19 f5       	brne	.+70     	; 0x5442 <_ZN3gel5Radio5beginENS_9RadioPinsENS_11RadioConfigE+0x432>
        return Error::Internal;

    instanceIdx = numInstances;
    53fc:	80 91 db 06 	lds	r24, 0x06DB	; 0x8006db <_ZN3gel5Radio12numInstancesE>
    5400:	f2 01       	movw	r30, r4
    5402:	e6 59       	subi	r30, 0x96	; 150
    5404:	fe 4f       	sbci	r31, 0xFE	; 254
    5406:	80 83       	st	Z, r24
    instances[instanceIdx] = this;
    5408:	e8 2f       	mov	r30, r24
    540a:	f0 e0       	ldi	r31, 0x00	; 0
    540c:	ee 0f       	add	r30, r30
    540e:	ff 1f       	adc	r31, r31
    5410:	e4 52       	subi	r30, 0x24	; 36
    5412:	f9 4f       	sbci	r31, 0xF9	; 249
    5414:	51 82       	std	Z+1, r5	; 0x01
    5416:	40 82       	st	Z, r4
    numInstances++;
    5418:	91 e0       	ldi	r25, 0x01	; 1
    541a:	98 0f       	add	r25, r24
    541c:	90 93 db 06 	sts	0x06DB, r25	; 0x8006db <_ZN3gel5Radio12numInstancesE>

    switch (instanceIdx)
    5420:	88 23       	and	r24, r24
    5422:	29 f1       	breq	.+74     	; 0x546e <_ZN3gel5Radio5beginENS_9RadioPinsENS_11RadioConfigE+0x45e>
    5424:	81 30       	cpi	r24, 0x01	; 1
    5426:	71 f1       	breq	.+92     	; 0x5484 <_ZN3gel5Radio5beginENS_9RadioPinsENS_11RadioConfigE+0x474>
    {
        case 0: radio.setDio0Action(callback0, RISING); break;
        case 1: radio.setDio0Action(callback1, RISING); break;
    }
    
    initialized = true;
    5428:	81 e0       	ldi	r24, 0x01	; 1
    542a:	f2 01       	movw	r30, r4
    542c:	80 83       	st	Z, r24
    return standby();
    542e:	b2 01       	movw	r22, r4
    5430:	c5 5c       	subi	r28, 0xC5	; 197
    5432:	de 4f       	sbci	r29, 0xFE	; 254
    5434:	88 81       	ld	r24, Y
    5436:	99 81       	ldd	r25, Y+1	; 0x01
    5438:	cb 53       	subi	r28, 0x3B	; 59
    543a:	d1 40       	sbci	r29, 0x01	; 1
    543c:	0e 94 94 1a 	call	0x3528	; 0x3528 <_ZN3gel5Radio7standbyEv>
    5440:	0e cf       	rjmp	.-484    	; 0x525e <_ZN3gel5Radio5beginENS_9RadioPinsENS_11RadioConfigE+0x24e>
    5442:	8c e8       	ldi	r24, 0x8C	; 140
    5444:	92 e0       	ldi	r25, 0x02	; 2
    5446:	c5 5c       	subi	r28, 0xC5	; 197
    5448:	de 4f       	sbci	r29, 0xFE	; 254
    544a:	a8 81       	ld	r26, Y
    544c:	b9 81       	ldd	r27, Y+1	; 0x01
    544e:	cb 53       	subi	r28, 0x3B	; 59
    5450:	d1 40       	sbci	r29, 0x01	; 1
    5452:	11 96       	adiw	r26, 0x01	; 1
    5454:	9c 93       	st	X, r25
    5456:	8e 93       	st	-X, r24
    5458:	87 e0       	ldi	r24, 0x07	; 7
    545a:	90 e0       	ldi	r25, 0x00	; 0
    545c:	13 96       	adiw	r26, 0x03	; 3
    545e:	9c 93       	st	X, r25
    5460:	8e 93       	st	-X, r24
    5462:	12 97       	sbiw	r26, 0x02	; 2
    5464:	15 96       	adiw	r26, 0x05	; 5
    5466:	1c 92       	st	X, r1
    5468:	1e 92       	st	-X, r1
    546a:	14 97       	sbiw	r26, 0x04	; 4
    546c:	f8 ce       	rjmp	.-528    	; 0x525e <_ZN3gel5Radio5beginENS_9RadioPinsENS_11RadioConfigE+0x24e>
    instances[instanceIdx] = this;
    numInstances++;

    switch (instanceIdx)
    {
        case 0: radio.setDio0Action(callback0, RISING); break;
    546e:	23 e0       	ldi	r18, 0x03	; 3
    5470:	30 e0       	ldi	r19, 0x00	; 0
    5472:	40 e0       	ldi	r20, 0x00	; 0
    5474:	50 e0       	ldi	r21, 0x00	; 0
    5476:	60 ef       	ldi	r22, 0xF0	; 240
    5478:	7a e1       	ldi	r23, 0x1A	; 26
    547a:	c2 01       	movw	r24, r4
    547c:	c4 96       	adiw	r24, 0x34	; 52
    547e:	0e 94 3c 0c 	call	0x1878	; 0x1878 <_ZN6SX127x13setDio0ActionEPFvvEm>
    5482:	d2 cf       	rjmp	.-92     	; 0x5428 <_ZN3gel5Radio5beginENS_9RadioPinsENS_11RadioConfigE+0x418>
        case 1: radio.setDio0Action(callback1, RISING); break;
    5484:	23 e0       	ldi	r18, 0x03	; 3
    5486:	30 e0       	ldi	r19, 0x00	; 0
    5488:	40 e0       	ldi	r20, 0x00	; 0
    548a:	50 e0       	ldi	r21, 0x00	; 0
    548c:	66 ef       	ldi	r22, 0xF6	; 246
    548e:	7a e1       	ldi	r23, 0x1A	; 26
    5490:	c2 01       	movw	r24, r4
    5492:	c4 96       	adiw	r24, 0x34	; 52
    5494:	0e 94 3c 0c 	call	0x1878	; 0x1878 <_ZN6SX127x13setDio0ActionEPFvvEm>
    5498:	c7 cf       	rjmp	.-114    	; 0x5428 <_ZN3gel5Radio5beginENS_9RadioPinsENS_11RadioConfigE+0x418>

0000549a <_Z10setupRadiov>:

    while (1);
}

gel::Error setupRadio()
{
    549a:	0f 93       	push	r16
    549c:	1f 93       	push	r17
    549e:	cf 93       	push	r28
    54a0:	df 93       	push	r29
    54a2:	cd b7       	in	r28, 0x3d	; 61
    54a4:	de b7       	in	r29, 0x3e	; 62
    54a6:	c1 56       	subi	r28, 0x61	; 97
    54a8:	d1 09       	sbc	r29, r1
    54aa:	0f b6       	in	r0, 0x3f	; 63
    54ac:	f8 94       	cli
    54ae:	de bf       	out	0x3e, r29	; 62
    54b0:	0f be       	out	0x3f, r0	; 63
    54b2:	cd bf       	out	0x3d, r28	; 61
    54b4:	8c 01       	movw	r16, r24
    54b6:	8a e0       	ldi	r24, 0x0A	; 10
    54b8:	e3 e4       	ldi	r30, 0x43	; 67
    54ba:	f0 e0       	ldi	r31, 0x00	; 0
    54bc:	ec 0f       	add	r30, r28
    54be:	fd 1f       	adc	r31, r29
    54c0:	75 96       	adiw	r30, 0x15	; 21
    54c2:	df 01       	movw	r26, r30
    54c4:	98 2f       	mov	r25, r24
    54c6:	1d 92       	st	X+, r1
    54c8:	9a 95       	dec	r25
    54ca:	e9 f7       	brne	.-6      	; 0x54c6 <_Z10setupRadiov+0x2c>
{
    LoRa,
    FSK,
};

struct LoRaConfig
    54cc:	99 e0       	ldi	r25, 0x09	; 9
    54ce:	9e a7       	std	Y+46, r25	; 0x2e
    54d0:	27 e0       	ldi	r18, 0x07	; 7
    54d2:	2f a7       	std	Y+47, r18	; 0x2f
    54d4:	40 e0       	ldi	r20, 0x00	; 0
    54d6:	54 e2       	ldi	r21, 0x24	; 36
    54d8:	64 ef       	ldi	r22, 0xF4	; 244
    54da:	77 e4       	ldi	r23, 0x47	; 71
    54dc:	48 ab       	std	Y+48, r20	; 0x30
    54de:	59 ab       	std	Y+49, r21	; 0x31
    54e0:	6a ab       	std	Y+50, r22	; 0x32
    54e2:	7b ab       	std	Y+51, r23	; 0x33
    54e4:	21 e0       	ldi	r18, 0x01	; 1
    54e6:	2c ab       	std	Y+52, r18	; 0x34

    pins.nss = 10;
    pins.dio0 = 2;
    pins.reset = 9;

    config.modConfig.lora = gel::LoRaConfig{};
    54e8:	27 e0       	ldi	r18, 0x07	; 7
    54ea:	fe 01       	movw	r30, r28
    54ec:	be 96       	adiw	r30, 0x2e	; 46
    54ee:	a3 e4       	ldi	r26, 0x43	; 67
    54f0:	b0 e0       	ldi	r27, 0x00	; 0
    54f2:	ac 0f       	add	r26, r28
    54f4:	bd 1f       	adc	r27, r29
    54f6:	1f 96       	adiw	r26, 0x0f	; 15
    54f8:	01 90       	ld	r0, Z+
    54fa:	0d 92       	st	X+, r0
    54fc:	2a 95       	dec	r18
    54fe:	e1 f7       	brne	.-8      	; 0x54f8 <_Z10setupRadiov+0x5e>
{   
    LoRaConfig lora;
    FSKConfig fsk;
};

struct RadioConfig
    5500:	44 e8       	ldi	r20, 0x84	; 132
    5502:	52 ef       	ldi	r21, 0xF2	; 242
    5504:	6e ec       	ldi	r22, 0xCE	; 206
    5506:	7d e4       	ldi	r23, 0x4D	; 77
    5508:	4f 87       	std	Y+15, r20	; 0x0f
    550a:	58 8b       	std	Y+16, r21	; 0x10
    550c:	69 8b       	std	Y+17, r22	; 0x11
    550e:	7a 8b       	std	Y+18, r23	; 0x12
    5510:	42 e1       	ldi	r20, 0x12	; 18
    5512:	50 e0       	ldi	r21, 0x00	; 0
    5514:	60 e0       	ldi	r22, 0x00	; 0
    5516:	70 e0       	ldi	r23, 0x00	; 0
    5518:	4b 8b       	std	Y+19, r20	; 0x13
    551a:	5c 8b       	std	Y+20, r21	; 0x14
    551c:	6d 8b       	std	Y+21, r22	; 0x15
    551e:	7e 8b       	std	Y+22, r23	; 0x16
    5520:	8f 8b       	std	Y+23, r24	; 0x17
    5522:	88 8f       	std	Y+24, r24	; 0x18
    //***************************************************************************
    /// Copy constructor.
    //***************************************************************************
    ETL_CONSTEXPR14 optional(const optional& other)
      : valid(bool(other))
      , storage(other.storage)
    5524:	19 8e       	std	Y+25, r1	; 0x19
    5526:	60 96       	adiw	r28, 0x10	; 16
    5528:	2e ad       	ldd	r18, Y+62	; 0x3e
    552a:	3f ad       	ldd	r19, Y+63	; 0x3f
    552c:	60 97       	sbiw	r28, 0x10	; 16
    552e:	3b 8f       	std	Y+27, r19	; 0x1b
    5530:	2a 8f       	std	Y+26, r18	; 0x1a
    5532:	1d 8e       	std	Y+29, r1	; 0x1d
    5534:	1c 8e       	std	Y+28, r1	; 0x1c
    5536:	20 e1       	ldi	r18, 0x10	; 16
    5538:	e3 e4       	ldi	r30, 0x43	; 67
    553a:	f0 e0       	ldi	r31, 0x00	; 0
    553c:	ec 0f       	add	r30, r28
    553e:	fd 1f       	adc	r31, r29
    5540:	3f 96       	adiw	r30, 0x0f	; 15
    5542:	de 01       	movw	r26, r28
    5544:	5e 96       	adiw	r26, 0x1e	; 30
    5546:	01 90       	ld	r0, Z+
    5548:	0d 92       	st	X+, r0
    554a:	2a 95       	dec	r18
    554c:	e1 f7       	brne	.-8      	; 0x5546 <_Z10setupRadiov+0xac>
    optional<size_t> payloadLength = nullopt;               // Must be specified for "fixed length" modes
    ModulationType modType = ModulationType::LoRa;
    ModulationConfig modConfig{};
};

struct RadioPins
    554e:	89 83       	std	Y+1, r24	; 0x01
    5550:	9a 83       	std	Y+2, r25	; 0x02
    5552:	82 e0       	ldi	r24, 0x02	; 2
    5554:	8b 83       	std	Y+3, r24	; 0x03
    5556:	1c 82       	std	Y+4, r1	; 0x04
    5558:	89 ad       	ldd	r24, Y+57	; 0x39
    555a:	8d 83       	std	Y+5, r24	; 0x05
    555c:	1e 82       	std	Y+6, r1	; 0x06
    555e:	8b ad       	ldd	r24, Y+59	; 0x3b
    5560:	8f 83       	std	Y+7, r24	; 0x07
    5562:	18 86       	std	Y+8, r1	; 0x08
    5564:	8d ad       	ldd	r24, Y+61	; 0x3d
    5566:	89 87       	std	Y+9, r24	; 0x09
    5568:	1a 86       	std	Y+10, r1	; 0x0a
    556a:	8f ad       	ldd	r24, Y+63	; 0x3f
    556c:	8b 87       	std	Y+11, r24	; 0x0b
    556e:	1c 86       	std	Y+12, r1	; 0x0c
    5570:	23 96       	adiw	r28, 0x03	; 3
    5572:	8e ad       	ldd	r24, Y+62	; 0x3e
    5574:	9f ad       	ldd	r25, Y+63	; 0x3f
    5576:	23 97       	sbiw	r28, 0x03	; 3
    5578:	9e 87       	std	Y+14, r25	; 0x0e
    557a:	8d 87       	std	Y+13, r24	; 0x0d
    config.modType = gel::ModulationType::LoRa;

    return radio.begin(pins, config);
    557c:	9e 01       	movw	r18, r28
    557e:	21 5f       	subi	r18, 0xF1	; 241
    5580:	3f 4f       	sbci	r19, 0xFF	; 255
    5582:	ae 01       	movw	r20, r28
    5584:	4f 5f       	subi	r20, 0xFF	; 255
    5586:	5f 4f       	sbci	r21, 0xFF	; 255
    5588:	69 e6       	ldi	r22, 0x69	; 105
    558a:	75 e0       	ldi	r23, 0x05	; 5
    558c:	c8 01       	movw	r24, r16
    558e:	0e 94 08 28 	call	0x5010	; 0x5010 <_ZN3gel5Radio5beginENS_9RadioPinsENS_11RadioConfigE>
}
    5592:	c8 01       	movw	r24, r16
    5594:	cf 59       	subi	r28, 0x9F	; 159
    5596:	df 4f       	sbci	r29, 0xFF	; 255
    5598:	0f b6       	in	r0, 0x3f	; 63
    559a:	f8 94       	cli
    559c:	de bf       	out	0x3e, r29	; 62
    559e:	0f be       	out	0x3f, r0	; 63
    55a0:	cd bf       	out	0x3d, r28	; 61
    55a2:	df 91       	pop	r29
    55a4:	cf 91       	pop	r28
    55a6:	1f 91       	pop	r17
    55a8:	0f 91       	pop	r16
    55aa:	08 95       	ret

000055ac <setup>:
//     gpsSerial.begin(9600);
//     return gps.begin(&gpsSerial);
// }

void setup()
{
    55ac:	cf 93       	push	r28
    55ae:	df 93       	push	r29
    55b0:	cd b7       	in	r28, 0x3d	; 61
    55b2:	de b7       	in	r29, 0x3e	; 62
    55b4:	62 97       	sbiw	r28, 0x12	; 18
    55b6:	0f b6       	in	r0, 0x3f	; 63
    55b8:	f8 94       	cli
    55ba:	de bf       	out	0x3e, r29	; 62
    55bc:	0f be       	out	0x3f, r0	; 63
    55be:	cd bf       	out	0x3d, r28	; 61
  public:
    inline HardwareSerial(
      volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
      volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
      volatile uint8_t *ucsrc, volatile uint8_t *udr);
    void begin(unsigned long baud) { begin(baud, SERIAL_8N1); }
    55c0:	26 e0       	ldi	r18, 0x06	; 6
    55c2:	40 e0       	ldi	r20, 0x00	; 0
    55c4:	52 ec       	ldi	r21, 0xC2	; 194
    55c6:	61 e0       	ldi	r22, 0x01	; 1
    55c8:	70 e0       	ldi	r23, 0x00	; 0
    55ca:	80 ee       	ldi	r24, 0xE0	; 224
    55cc:	96 e0       	ldi	r25, 0x06	; 6
    55ce:	0e 94 bd 05 	call	0xb7a	; 0xb7a <_ZN14HardwareSerial5beginEmh>
    Serial.begin(115200);
    delay(1000);
    55d2:	68 ee       	ldi	r22, 0xE8	; 232
    55d4:	73 e0       	ldi	r23, 0x03	; 3
    55d6:	80 e0       	ldi	r24, 0x00	; 0
    55d8:	90 e0       	ldi	r25, 0x00	; 0
    55da:	0e 94 22 02 	call	0x444	; 0x444 <delay>

    // Initialize radio
    if (gel::Error err = setupRadio())
    55de:	ce 01       	movw	r24, r28
    55e0:	0d 96       	adiw	r24, 0x0d	; 13
    55e2:	0e 94 4d 2a 	call	0x549a	; 0x549a <_Z10setupRadiov>

    // Methods
    explicit operator bool() { return code != Error::None; }
    55e6:	8f 85       	ldd	r24, Y+15	; 0x0f
    55e8:	98 89       	ldd	r25, Y+16	; 0x10
    55ea:	00 97       	sbiw	r24, 0x00	; 0
    55ec:	e9 f4       	brne	.+58     	; 0x5628 <setup+0x7c>
        handleError(err, "Could not initialize radio.", true);
    else
        Serial.println("Radio initialized.");
    55ee:	66 ef       	ldi	r22, 0xF6	; 246
    55f0:	72 e0       	ldi	r23, 0x02	; 2
    55f2:	80 ee       	ldi	r24, 0xE0	; 224
    55f4:	96 e0       	ldi	r25, 0x06	; 6
    55f6:	0e 94 33 10 	call	0x2066	; 0x2066 <_ZN5Print7printlnEPKc>
    
    // Initialize link
    if (gel::Error err = setupLink())
    55fa:	ce 01       	movw	r24, r28
    55fc:	0d 96       	adiw	r24, 0x0d	; 13
    55fe:	0e 94 57 0e 	call	0x1cae	; 0x1cae <_Z9setupLinkv>
    5602:	8f 85       	ldd	r24, Y+15	; 0x0f
    5604:	98 89       	ldd	r25, Y+16	; 0x10
    5606:	00 97       	sbiw	r24, 0x00	; 0
    5608:	01 f5       	brne	.+64     	; 0x564a <setup+0x9e>
        handleError(err, "Could not setup communication link.", true);
    else
        Serial.println("Link initialized.");
    560a:	6d e2       	ldi	r22, 0x2D	; 45
    560c:	73 e0       	ldi	r23, 0x03	; 3
    560e:	80 ee       	ldi	r24, 0xE0	; 224
    5610:	96 e0       	ldi	r25, 0x06	; 6
    5612:	0e 94 33 10 	call	0x2066	; 0x2066 <_ZN5Print7printlnEPKc>
    // Initialize GPS
    // if (gel::Error err = setupGps())
        // handleError(err, "Could not initialize GPS.");
    // else
        // Serial.println("GPS initialized.");
}
    5616:	62 96       	adiw	r28, 0x12	; 18
    5618:	0f b6       	in	r0, 0x3f	; 63
    561a:	f8 94       	cli
    561c:	de bf       	out	0x3e, r29	; 62
    561e:	0f be       	out	0x3f, r0	; 63
    5620:	cd bf       	out	0x3d, r28	; 61
    5622:	df 91       	pop	r29
    5624:	cf 91       	pop	r28
    5626:	08 95       	ret
#include <gel/Core.h>

namespace gel
{

struct Error : Printable
    5628:	2c e8       	ldi	r18, 0x8C	; 140
    562a:	32 e0       	ldi	r19, 0x02	; 2
    562c:	38 87       	std	Y+8, r19	; 0x08
    562e:	2f 83       	std	Y+7, r18	; 0x07
    5630:	9a 87       	std	Y+10, r25	; 0x0a
    5632:	89 87       	std	Y+9, r24	; 0x09
    5634:	89 89       	ldd	r24, Y+17	; 0x11
    5636:	9a 89       	ldd	r25, Y+18	; 0x12
    5638:	9c 87       	std	Y+12, r25	; 0x0c
    563a:	8b 87       	std	Y+11, r24	; 0x0b
    Serial.begin(115200);
    delay(1000);

    // Initialize radio
    if (gel::Error err = setupRadio())
        handleError(err, "Could not initialize radio.", true);
    563c:	41 e0       	ldi	r20, 0x01	; 1
    563e:	6a ed       	ldi	r22, 0xDA	; 218
    5640:	72 e0       	ldi	r23, 0x02	; 2
    5642:	ce 01       	movw	r24, r28
    5644:	07 96       	adiw	r24, 0x07	; 7
    5646:	0e 94 70 10 	call	0x20e0	; 0x20e0 <_Z11handleErrorN3gel5ErrorEPKcb>
    564a:	2c e8       	ldi	r18, 0x8C	; 140
    564c:	32 e0       	ldi	r19, 0x02	; 2
    564e:	3a 83       	std	Y+2, r19	; 0x02
    5650:	29 83       	std	Y+1, r18	; 0x01
    5652:	9c 83       	std	Y+4, r25	; 0x04
    5654:	8b 83       	std	Y+3, r24	; 0x03
    5656:	89 89       	ldd	r24, Y+17	; 0x11
    5658:	9a 89       	ldd	r25, Y+18	; 0x12
    565a:	9e 83       	std	Y+6, r25	; 0x06
    565c:	8d 83       	std	Y+5, r24	; 0x05
    else
        Serial.println("Radio initialized.");
    
    // Initialize link
    if (gel::Error err = setupLink())
        handleError(err, "Could not setup communication link.", true);
    565e:	41 e0       	ldi	r20, 0x01	; 1
    5660:	69 e0       	ldi	r22, 0x09	; 9
    5662:	73 e0       	ldi	r23, 0x03	; 3
    5664:	ce 01       	movw	r24, r28
    5666:	01 96       	adiw	r24, 0x01	; 1
    5668:	0e 94 70 10 	call	0x20e0	; 0x20e0 <_Z11handleErrorN3gel5ErrorEPKcb>

0000566c <_ZN6SX127x15setFrequencyRawEf>:
  }

  return(state);
}

int16_t SX127x::setFrequencyRaw(float newFreq) {
    566c:	4f 92       	push	r4
    566e:	5f 92       	push	r5
    5670:	6f 92       	push	r6
    5672:	7f 92       	push	r7
    5674:	af 92       	push	r10
    5676:	bf 92       	push	r11
    5678:	cf 92       	push	r12
    567a:	ef 92       	push	r14
    567c:	0f 93       	push	r16
    567e:	cf 93       	push	r28
    5680:	df 93       	push	r29
    5682:	ec 01       	movw	r28, r24
    5684:	2a 01       	movw	r4, r20
    5686:	3b 01       	movw	r6, r22
  int16_t state = RADIOLIB_ERR_NONE;

  // set mode to standby if not FHSS
  if(this->mod->SPIgetRegValue(RADIOLIB_SX127X_REG_HOP_PERIOD) == RADIOLIB_SX127X_HOP_PERIOD_OFF) {
    5688:	fc 01       	movw	r30, r24
    568a:	e7 5e       	subi	r30, 0xE7	; 231
    568c:	fe 4f       	sbci	r31, 0xFE	; 254
    568e:	20 e0       	ldi	r18, 0x00	; 0
    5690:	47 e0       	ldi	r20, 0x07	; 7
    5692:	64 e2       	ldi	r22, 0x24	; 36
    5694:	70 e0       	ldi	r23, 0x00	; 0
    5696:	80 81       	ld	r24, Z
    5698:	91 81       	ldd	r25, Z+1	; 0x01
    569a:	0e 94 c0 18 	call	0x3180	; 0x3180 <_ZN6Module14SPIgetRegValueEjhh>
    569e:	89 2b       	or	r24, r25
    56a0:	09 f4       	brne	.+2      	; 0x56a4 <_ZN6SX127x15setFrequencyRawEf+0x38>
    56a2:	4b c0       	rjmp	.+150    	; 0x573a <_ZN6SX127x15setFrequencyRawEf+0xce>

  return(state);
}

int16_t SX127x::setFrequencyRaw(float newFreq) {
  int16_t state = RADIOLIB_ERR_NONE;
    56a4:	b1 2c       	mov	r11, r1
    56a6:	a1 2c       	mov	r10, r1
  if(this->mod->SPIgetRegValue(RADIOLIB_SX127X_REG_HOP_PERIOD) == RADIOLIB_SX127X_HOP_PERIOD_OFF) {
    state = setMode(RADIOLIB_SX127X_STANDBY);
  }

  // calculate register values
  uint32_t FRF = (newFreq * (uint32_t(1) << RADIOLIB_SX127X_DIV_EXPONENT)) / RADIOLIB_SX127X_CRYSTAL_FREQ;
    56a8:	20 e0       	ldi	r18, 0x00	; 0
    56aa:	30 e0       	ldi	r19, 0x00	; 0
    56ac:	40 e0       	ldi	r20, 0x00	; 0
    56ae:	59 e4       	ldi	r21, 0x49	; 73
    56b0:	c3 01       	movw	r24, r6
    56b2:	b2 01       	movw	r22, r4
    56b4:	0e 94 d7 39 	call	0x73ae	; 0x73ae <__mulsf3>
    56b8:	20 e0       	ldi	r18, 0x00	; 0
    56ba:	30 e0       	ldi	r19, 0x00	; 0
    56bc:	40 e0       	ldi	r20, 0x00	; 0
    56be:	5d e3       	ldi	r21, 0x3D	; 61
    56c0:	0e 94 d7 39 	call	0x73ae	; 0x73ae <__mulsf3>
    56c4:	0e 94 61 3c 	call	0x78c2	; 0x78c2 <__fixunssfsi>
    56c8:	2b 01       	movw	r4, r22
    56ca:	3c 01       	movw	r6, r24

  // write registers
  state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_FRF_MSB, (FRF & 0xFF0000) >> 16);
    56cc:	c7 5e       	subi	r28, 0xE7	; 231
    56ce:	de 4f       	sbci	r29, 0xFE	; 254
    56d0:	a3 01       	movw	r20, r6
    56d2:	66 27       	eor	r22, r22
    56d4:	77 27       	eor	r23, r23
    56d6:	cc 24       	eor	r12, r12
    56d8:	ca 94       	dec	r12
    56da:	68 94       	set
    56dc:	ee 24       	eor	r14, r14
    56de:	e1 f8       	bld	r14, 1
    56e0:	00 e0       	ldi	r16, 0x00	; 0
    56e2:	27 e0       	ldi	r18, 0x07	; 7
    56e4:	66 e0       	ldi	r22, 0x06	; 6
    56e6:	70 e0       	ldi	r23, 0x00	; 0
    56e8:	88 81       	ld	r24, Y
    56ea:	99 81       	ldd	r25, Y+1	; 0x01
    56ec:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    56f0:	a8 2a       	or	r10, r24
    56f2:	b9 2a       	or	r11, r25
  state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_FRF_MID, (FRF & 0x00FF00) >> 8);
    56f4:	77 27       	eor	r23, r23
    56f6:	67 2d       	mov	r22, r7
    56f8:	56 2d       	mov	r21, r6
    56fa:	45 2d       	mov	r20, r5
    56fc:	27 e0       	ldi	r18, 0x07	; 7
    56fe:	67 e0       	ldi	r22, 0x07	; 7
    5700:	70 e0       	ldi	r23, 0x00	; 0
    5702:	88 81       	ld	r24, Y
    5704:	99 81       	ldd	r25, Y+1	; 0x01
    5706:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    570a:	a8 2a       	or	r10, r24
    570c:	b9 2a       	or	r11, r25
  state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_FRF_LSB, FRF & 0x0000FF);
    570e:	27 e0       	ldi	r18, 0x07	; 7
    5710:	44 2d       	mov	r20, r4
    5712:	68 e0       	ldi	r22, 0x08	; 8
    5714:	70 e0       	ldi	r23, 0x00	; 0
    5716:	88 81       	ld	r24, Y
    5718:	99 81       	ldd	r25, Y+1	; 0x01
    571a:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
  return(state);
}
    571e:	8a 29       	or	r24, r10
    5720:	9b 29       	or	r25, r11
    5722:	df 91       	pop	r29
    5724:	cf 91       	pop	r28
    5726:	0f 91       	pop	r16
    5728:	ef 90       	pop	r14
    572a:	cf 90       	pop	r12
    572c:	bf 90       	pop	r11
    572e:	af 90       	pop	r10
    5730:	7f 90       	pop	r7
    5732:	6f 90       	pop	r6
    5734:	5f 90       	pop	r5
    5736:	4f 90       	pop	r4
    5738:	08 95       	ret
int16_t SX127x::setFrequencyRaw(float newFreq) {
  int16_t state = RADIOLIB_ERR_NONE;

  // set mode to standby if not FHSS
  if(this->mod->SPIgetRegValue(RADIOLIB_SX127X_REG_HOP_PERIOD) == RADIOLIB_SX127X_HOP_PERIOD_OFF) {
    state = setMode(RADIOLIB_SX127X_STANDBY);
    573a:	61 e0       	ldi	r22, 0x01	; 1
    573c:	ce 01       	movw	r24, r28
    573e:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN6SX127x7setModeEh>
    5742:	5c 01       	movw	r10, r24
    5744:	b1 cf       	rjmp	.-158    	; 0x56a8 <_ZN6SX127x15setFrequencyRawEf+0x3c>

00005746 <_ZN6SX127812setFrequencyEf>:
  this->mod->hal->delay(1);
  this->mod->hal->digitalWrite(this->mod->getRst(), this->mod->hal->GpioLevelHigh);
  this->mod->hal->delay(5);
}

int16_t SX1278::setFrequency(float freq) {
    5746:	cf 92       	push	r12
    5748:	df 92       	push	r13
    574a:	ef 92       	push	r14
    574c:	ff 92       	push	r15
    574e:	cf 93       	push	r28
    5750:	df 93       	push	r29
    5752:	ec 01       	movw	r28, r24
    5754:	6a 01       	movw	r12, r20
    5756:	7b 01       	movw	r14, r22
  RADIOLIB_CHECK_RANGE(freq, 137.0, 525.0, RADIOLIB_ERR_INVALID_FREQUENCY);
    5758:	20 e0       	ldi	r18, 0x00	; 0
    575a:	30 e0       	ldi	r19, 0x00	; 0
    575c:	49 e0       	ldi	r20, 0x09	; 9
    575e:	53 e4       	ldi	r21, 0x43	; 67
    5760:	cb 01       	movw	r24, r22
    5762:	b6 01       	movw	r22, r12
    5764:	0e 94 d1 3c 	call	0x79a2	; 0x79a2 <__gesf2>
    5768:	88 23       	and	r24, r24
    576a:	f4 f0       	brlt	.+60     	; 0x57a8 <_ZN6SX127812setFrequencyEf+0x62>
    576c:	20 e0       	ldi	r18, 0x00	; 0
    576e:	30 e4       	ldi	r19, 0x40	; 64
    5770:	43 e0       	ldi	r20, 0x03	; 3
    5772:	54 e4       	ldi	r21, 0x44	; 68
    5774:	c7 01       	movw	r24, r14
    5776:	b6 01       	movw	r22, r12
    5778:	0e 94 71 39 	call	0x72e2	; 0x72e2 <__cmpsf2>
    577c:	18 16       	cp	r1, r24
    577e:	bc f0       	brlt	.+46     	; 0x57ae <_ZN6SX127812setFrequencyEf+0x68>

  // set frequency and if successful, save the new setting
  int16_t state = SX127x::setFrequencyRaw(freq);
    5780:	b7 01       	movw	r22, r14
    5782:	a6 01       	movw	r20, r12
    5784:	ce 01       	movw	r24, r28
    5786:	0e 94 36 2b 	call	0x566c	; 0x566c <_ZN6SX127x15setFrequencyRawEf>
  if(state == RADIOLIB_ERR_NONE) {
    578a:	00 97       	sbiw	r24, 0x00	; 0
    578c:	31 f4       	brne	.+12     	; 0x579a <_ZN6SX127812setFrequencyEf+0x54>
    SX127x::frequency = freq;
    578e:	c5 5e       	subi	r28, 0xE5	; 229
    5790:	de 4f       	sbci	r29, 0xFE	; 254
    5792:	c8 82       	st	Y, r12
    5794:	d9 82       	std	Y+1, r13	; 0x01
    5796:	ea 82       	std	Y+2, r14	; 0x02
    5798:	fb 82       	std	Y+3, r15	; 0x03
  }
  return(state);
}
    579a:	df 91       	pop	r29
    579c:	cf 91       	pop	r28
    579e:	ff 90       	pop	r15
    57a0:	ef 90       	pop	r14
    57a2:	df 90       	pop	r13
    57a4:	cf 90       	pop	r12
    57a6:	08 95       	ret
  this->mod->hal->digitalWrite(this->mod->getRst(), this->mod->hal->GpioLevelHigh);
  this->mod->hal->delay(5);
}

int16_t SX1278::setFrequency(float freq) {
  RADIOLIB_CHECK_RANGE(freq, 137.0, 525.0, RADIOLIB_ERR_INVALID_FREQUENCY);
    57a8:	84 ef       	ldi	r24, 0xF4	; 244
    57aa:	9f ef       	ldi	r25, 0xFF	; 255
    57ac:	f6 cf       	rjmp	.-20     	; 0x579a <_ZN6SX127812setFrequencyEf+0x54>
    57ae:	84 ef       	ldi	r24, 0xF4	; 244
    57b0:	9f ef       	ldi	r25, 0xFF	; 255
    57b2:	f3 cf       	rjmp	.-26     	; 0x579a <_ZN6SX127812setFrequencyEf+0x54>

000057b4 <_ZN6SX127x6getSNREv>:

  uint32_t base = 1;
  return raw * (32000000.0 / (float)(base << 19));
}

float SX127x::getSNR() {
    57b4:	cf 93       	push	r28
    57b6:	df 93       	push	r29
    57b8:	ec 01       	movw	r28, r24
  // check active modem
  if(getActiveModem() != RADIOLIB_SX127X_LORA) {
    57ba:	0e 94 ec 18 	call	0x31d8	; 0x31d8 <_ZN6SX127x14getActiveModemEv>
    57be:	80 38       	cpi	r24, 0x80	; 128
    57c0:	91 05       	cpc	r25, r1
    57c2:	31 f0       	breq	.+12     	; 0x57d0 <_ZN6SX127x6getSNREv+0x1c>
    return(0);
    57c4:	60 e0       	ldi	r22, 0x00	; 0
    57c6:	70 e0       	ldi	r23, 0x00	; 0
    57c8:	cb 01       	movw	r24, r22
  }

  // get SNR value
  int8_t rawSNR = (int8_t)this->mod->SPIgetRegValue(RADIOLIB_SX127X_REG_PKT_SNR_VALUE);
  return(rawSNR / 4.0);
}
    57ca:	df 91       	pop	r29
    57cc:	cf 91       	pop	r28
    57ce:	08 95       	ret
  if(getActiveModem() != RADIOLIB_SX127X_LORA) {
    return(0);
  }

  // get SNR value
  int8_t rawSNR = (int8_t)this->mod->SPIgetRegValue(RADIOLIB_SX127X_REG_PKT_SNR_VALUE);
    57d0:	c7 5e       	subi	r28, 0xE7	; 231
    57d2:	de 4f       	sbci	r29, 0xFE	; 254
    57d4:	20 e0       	ldi	r18, 0x00	; 0
    57d6:	47 e0       	ldi	r20, 0x07	; 7
    57d8:	69 e1       	ldi	r22, 0x19	; 25
    57da:	70 e0       	ldi	r23, 0x00	; 0
    57dc:	88 81       	ld	r24, Y
    57de:	99 81       	ldd	r25, Y+1	; 0x01
    57e0:	0e 94 c0 18 	call	0x3180	; 0x3180 <_ZN6Module14SPIgetRegValueEjhh>
  return(rawSNR / 4.0);
    57e4:	68 2f       	mov	r22, r24
    57e6:	88 0f       	add	r24, r24
    57e8:	77 0b       	sbc	r23, r23
    57ea:	88 0b       	sbc	r24, r24
    57ec:	99 0b       	sbc	r25, r25
    57ee:	0e 94 78 39 	call	0x72f0	; 0x72f0 <__floatsisf>
    57f2:	20 e0       	ldi	r18, 0x00	; 0
    57f4:	30 e0       	ldi	r19, 0x00	; 0
    57f6:	40 e8       	ldi	r20, 0x80	; 128
    57f8:	5e e3       	ldi	r21, 0x3E	; 62
    57fa:	0e 94 d7 39 	call	0x73ae	; 0x73ae <__mulsf3>
    57fe:	e5 cf       	rjmp	.-54     	; 0x57ca <_ZN6SX127x6getSNREv+0x16>

00005800 <_ZN6SX127x13startTransmitEPhjh>:
    return(true);
  }
  return(false);
}

int16_t SX127x::startTransmit(uint8_t* data, size_t len, uint8_t addr) {
    5800:	2f 92       	push	r2
    5802:	3f 92       	push	r3
    5804:	4f 92       	push	r4
    5806:	5f 92       	push	r5
    5808:	6f 92       	push	r6
    580a:	7f 92       	push	r7
    580c:	8f 92       	push	r8
    580e:	9f 92       	push	r9
    5810:	af 92       	push	r10
    5812:	bf 92       	push	r11
    5814:	cf 92       	push	r12
    5816:	ef 92       	push	r14
    5818:	0f 93       	push	r16
    581a:	cf 93       	push	r28
    581c:	df 93       	push	r29
    581e:	ec 01       	movw	r28, r24
    5820:	2b 01       	movw	r4, r22
    5822:	3a 01       	movw	r6, r20
    5824:	32 2e       	mov	r3, r18
  // set mode to standby
  int16_t state = setMode(RADIOLIB_SX127X_STANDBY);
    5826:	61 e0       	ldi	r22, 0x01	; 1
    5828:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN6SX127x7setModeEh>
    582c:	5c 01       	movw	r10, r24

  int16_t modem = getActiveModem();
    582e:	ce 01       	movw	r24, r28
    5830:	0e 94 ec 18 	call	0x31d8	; 0x31d8 <_ZN6SX127x14getActiveModemEv>
    5834:	4c 01       	movw	r8, r24
  if(modem == RADIOLIB_SX127X_LORA) {
    5836:	80 e8       	ldi	r24, 0x80	; 128
    5838:	88 16       	cp	r8, r24
    583a:	91 04       	cpc	r9, r1
    583c:	a9 f1       	breq	.+106    	; 0x58a8 <_ZN6SX127x13startTransmitEPhjh+0xa8>

    // set FIFO pointers
    state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_FIFO_TX_BASE_ADDR, RADIOLIB_SX127X_FIFO_TX_BASE_ADDR_MAX);
    state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_FIFO_ADDR_PTR, RADIOLIB_SX127X_FIFO_TX_BASE_ADDR_MAX);

  } else if(modem == RADIOLIB_SX127X_FSK_OOK) {
    583e:	81 14       	cp	r8, r1
    5840:	91 04       	cpc	r9, r1
    5842:	09 f4       	brne	.+2      	; 0x5846 <_ZN6SX127x13startTransmitEPhjh+0x46>
    5844:	99 c0       	rjmp	.+306    	; 0x5978 <_ZN6SX127x13startTransmitEPhjh+0x178>
    }
  }

  // write packet to FIFO
  size_t packetLen = len;
  if((modem == RADIOLIB_SX127X_FSK_OOK) && (len > RADIOLIB_SX127X_MAX_PACKET_LENGTH_FSK)) {
    5846:	89 28       	or	r8, r9
    5848:	29 f4       	brne	.+10     	; 0x5854 <_ZN6SX127x13startTransmitEPhjh+0x54>
    584a:	81 e4       	ldi	r24, 0x41	; 65
    584c:	68 16       	cp	r6, r24
    584e:	71 04       	cpc	r7, r1
    5850:	08 f0       	brcs	.+2      	; 0x5854 <_ZN6SX127x13startTransmitEPhjh+0x54>
    5852:	e6 c0       	rjmp	.+460    	; 0x5a20 <_ZN6SX127x13startTransmitEPhjh+0x220>
    packetLen = RADIOLIB_SX127X_FIFO_THRESH - 1;
    this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_FIFO_THRESH, RADIOLIB_SX127X_TX_START_FIFO_NOT_EMPTY, 7, 7);
  }
  this->mod->SPIwriteRegisterBurst(RADIOLIB_SX127X_REG_FIFO, data, packetLen);
    5854:	4e 01       	movw	r8, r28
    5856:	e7 ee       	ldi	r30, 0xE7	; 231
    5858:	8e 1a       	sub	r8, r30
    585a:	ee ef       	ldi	r30, 0xFE	; 254
    585c:	9e 0a       	sbc	r9, r30
    585e:	93 01       	movw	r18, r6
    5860:	a2 01       	movw	r20, r4
    5862:	70 e0       	ldi	r23, 0x00	; 0
    5864:	60 e0       	ldi	r22, 0x00	; 0
    5866:	f4 01       	movw	r30, r8
    5868:	80 81       	ld	r24, Z
    586a:	91 81       	ldd	r25, Z+1	; 0x01
    586c:	0e 94 3b 17 	call	0x2e76	; 0x2e76 <_ZN6Module21SPIwriteRegisterBurstEjPhj>

  // set RF switch (if present)
  this->mod->setRfSwitchState(Module::MODE_TX);
    5870:	63 e0       	ldi	r22, 0x03	; 3
    5872:	f4 01       	movw	r30, r8
    5874:	80 81       	ld	r24, Z
    5876:	91 81       	ldd	r25, Z+1	; 0x01
    5878:	0e 94 c3 09 	call	0x1386	; 0x1386 <_ZN6Module16setRfSwitchStateEh>

  // start transmission
  state |= setMode(RADIOLIB_SX127X_TX);
    587c:	63 e0       	ldi	r22, 0x03	; 3
    587e:	ce 01       	movw	r24, r28
    5880:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN6SX127x7setModeEh>
    5884:	8a 29       	or	r24, r10
    5886:	9b 29       	or	r25, r11
  RADIOLIB_ASSERT(state);

  return(RADIOLIB_ERR_NONE);
}
    5888:	df 91       	pop	r29
    588a:	cf 91       	pop	r28
    588c:	0f 91       	pop	r16
    588e:	ef 90       	pop	r14
    5890:	cf 90       	pop	r12
    5892:	bf 90       	pop	r11
    5894:	af 90       	pop	r10
    5896:	9f 90       	pop	r9
    5898:	8f 90       	pop	r8
    589a:	7f 90       	pop	r7
    589c:	6f 90       	pop	r6
    589e:	5f 90       	pop	r5
    58a0:	4f 90       	pop	r4
    58a2:	3f 90       	pop	r3
    58a4:	2f 90       	pop	r2
    58a6:	08 95       	ret
  int16_t state = setMode(RADIOLIB_SX127X_STANDBY);

  int16_t modem = getActiveModem();
  if(modem == RADIOLIB_SX127X_LORA) {
    // check packet length
    if(len > RADIOLIB_SX127X_MAX_PACKET_LENGTH) {
    58a8:	ef ef       	ldi	r30, 0xFF	; 255
    58aa:	6e 16       	cp	r6, r30
    58ac:	71 04       	cpc	r7, r1
    58ae:	11 f0       	breq	.+4      	; 0x58b4 <_ZN6SX127x13startTransmitEPhjh+0xb4>
    58b0:	08 f0       	brcs	.+2      	; 0x58b4 <_ZN6SX127x13startTransmitEPhjh+0xb4>
    58b2:	cd c0       	rjmp	.+410    	; 0x5a4e <_ZN6SX127x13startTransmitEPhjh+0x24e>
      return(RADIOLIB_ERR_PACKET_TOO_LONG);
    }

    // set DIO mapping
    if(this->mod->SPIgetRegValue(RADIOLIB_SX127X_REG_HOP_PERIOD) > RADIOLIB_SX127X_HOP_PERIOD_OFF) {
    58b4:	20 e0       	ldi	r18, 0x00	; 0
    58b6:	47 e0       	ldi	r20, 0x07	; 7
    58b8:	64 e2       	ldi	r22, 0x24	; 36
    58ba:	70 e0       	ldi	r23, 0x00	; 0
    58bc:	fe 01       	movw	r30, r28
    58be:	e7 5e       	subi	r30, 0xE7	; 231
    58c0:	fe 4f       	sbci	r31, 0xFE	; 254
    58c2:	80 81       	ld	r24, Z
    58c4:	91 81       	ldd	r25, Z+1	; 0x01
    58c6:	0e 94 c0 18 	call	0x3180	; 0x3180 <_ZN6Module14SPIgetRegValueEjhh>
    58ca:	18 16       	cp	r1, r24
    58cc:	19 06       	cpc	r1, r25
    58ce:	0c f0       	brlt	.+2      	; 0x58d2 <_ZN6SX127x13startTransmitEPhjh+0xd2>
    58d0:	41 c0       	rjmp	.+130    	; 0x5954 <_ZN6SX127x13startTransmitEPhjh+0x154>
      this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_DIO_MAPPING_1, RADIOLIB_SX127X_DIO0_LORA_TX_DONE | RADIOLIB_SX127X_DIO1_LORA_FHSS_CHANGE_CHANNEL, 7, 4);
    58d2:	cc 24       	eor	r12, r12
    58d4:	ca 94       	dec	r12
    58d6:	68 94       	set
    58d8:	ee 24       	eor	r14, r14
    58da:	e1 f8       	bld	r14, 1
    58dc:	04 e0       	ldi	r16, 0x04	; 4
    58de:	27 e0       	ldi	r18, 0x07	; 7
    58e0:	40 e5       	ldi	r20, 0x50	; 80
    58e2:	60 e4       	ldi	r22, 0x40	; 64
    58e4:	70 e0       	ldi	r23, 0x00	; 0
    58e6:	fe 01       	movw	r30, r28
    58e8:	e7 5e       	subi	r30, 0xE7	; 231
    58ea:	fe 4f       	sbci	r31, 0xFE	; 254
    58ec:	80 81       	ld	r24, Z
    58ee:	91 81       	ldd	r25, Z+1	; 0x01
    58f0:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>

    // apply fixes to errata
    RADIOLIB_ERRATA_SX127X(false);

    // clear interrupt flags
    clearIRQFlags();
    58f4:	ce 01       	movw	r24, r28
    58f6:	0e 94 61 19 	call	0x32c2	; 0x32c2 <_ZN6SX127x13clearIRQFlagsEv>

    // set packet length
    state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_PAYLOAD_LENGTH, len);
    58fa:	cc 24       	eor	r12, r12
    58fc:	ca 94       	dec	r12
    58fe:	68 94       	set
    5900:	ee 24       	eor	r14, r14
    5902:	e1 f8       	bld	r14, 1
    5904:	00 e0       	ldi	r16, 0x00	; 0
    5906:	27 e0       	ldi	r18, 0x07	; 7
    5908:	46 2d       	mov	r20, r6
    590a:	62 e2       	ldi	r22, 0x22	; 34
    590c:	70 e0       	ldi	r23, 0x00	; 0
    590e:	1e 01       	movw	r2, r28
    5910:	f7 ee       	ldi	r31, 0xE7	; 231
    5912:	2f 1a       	sub	r2, r31
    5914:	fe ef       	ldi	r31, 0xFE	; 254
    5916:	3f 0a       	sbc	r3, r31
    5918:	f1 01       	movw	r30, r2
    591a:	80 81       	ld	r24, Z
    591c:	91 81       	ldd	r25, Z+1	; 0x01
    591e:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    5922:	a8 2a       	or	r10, r24
    5924:	b9 2a       	or	r11, r25

    // set FIFO pointers
    state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_FIFO_TX_BASE_ADDR, RADIOLIB_SX127X_FIFO_TX_BASE_ADDR_MAX);
    5926:	27 e0       	ldi	r18, 0x07	; 7
    5928:	40 e0       	ldi	r20, 0x00	; 0
    592a:	6e e0       	ldi	r22, 0x0E	; 14
    592c:	70 e0       	ldi	r23, 0x00	; 0
    592e:	f1 01       	movw	r30, r2
    5930:	80 81       	ld	r24, Z
    5932:	91 81       	ldd	r25, Z+1	; 0x01
    5934:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    5938:	a8 2a       	or	r10, r24
    593a:	b9 2a       	or	r11, r25
    state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_FIFO_ADDR_PTR, RADIOLIB_SX127X_FIFO_TX_BASE_ADDR_MAX);
    593c:	27 e0       	ldi	r18, 0x07	; 7
    593e:	40 e0       	ldi	r20, 0x00	; 0
    5940:	6d e0       	ldi	r22, 0x0D	; 13
    5942:	70 e0       	ldi	r23, 0x00	; 0
    5944:	f1 01       	movw	r30, r2
    5946:	80 81       	ld	r24, Z
    5948:	91 81       	ldd	r25, Z+1	; 0x01
    594a:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    594e:	a8 2a       	or	r10, r24
    5950:	b9 2a       	or	r11, r25
    5952:	79 cf       	rjmp	.-270    	; 0x5846 <_ZN6SX127x13startTransmitEPhjh+0x46>

    // set DIO mapping
    if(this->mod->SPIgetRegValue(RADIOLIB_SX127X_REG_HOP_PERIOD) > RADIOLIB_SX127X_HOP_PERIOD_OFF) {
      this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_DIO_MAPPING_1, RADIOLIB_SX127X_DIO0_LORA_TX_DONE | RADIOLIB_SX127X_DIO1_LORA_FHSS_CHANGE_CHANNEL, 7, 4);
    } else {
      this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_DIO_MAPPING_1, RADIOLIB_SX127X_DIO0_LORA_TX_DONE, 7, 6);
    5954:	cc 24       	eor	r12, r12
    5956:	ca 94       	dec	r12
    5958:	68 94       	set
    595a:	ee 24       	eor	r14, r14
    595c:	e1 f8       	bld	r14, 1
    595e:	06 e0       	ldi	r16, 0x06	; 6
    5960:	27 e0       	ldi	r18, 0x07	; 7
    5962:	40 e4       	ldi	r20, 0x40	; 64
    5964:	60 e4       	ldi	r22, 0x40	; 64
    5966:	70 e0       	ldi	r23, 0x00	; 0
    5968:	fe 01       	movw	r30, r28
    596a:	e7 5e       	subi	r30, 0xE7	; 231
    596c:	fe 4f       	sbci	r31, 0xFE	; 254
    596e:	80 81       	ld	r24, Z
    5970:	91 81       	ldd	r25, Z+1	; 0x01
    5972:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    5976:	be cf       	rjmp	.-132    	; 0x58f4 <_ZN6SX127x13startTransmitEPhjh+0xf4>
    state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_FIFO_TX_BASE_ADDR, RADIOLIB_SX127X_FIFO_TX_BASE_ADDR_MAX);
    state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_FIFO_ADDR_PTR, RADIOLIB_SX127X_FIFO_TX_BASE_ADDR_MAX);

  } else if(modem == RADIOLIB_SX127X_FSK_OOK) {
    // clear interrupt flags
    clearIRQFlags();
    5978:	ce 01       	movw	r24, r28
    597a:	0e 94 61 19 	call	0x32c2	; 0x32c2 <_ZN6SX127x13clearIRQFlagsEv>

    // set DIO mapping
    if(len > RADIOLIB_SX127X_MAX_PACKET_LENGTH_FSK) {
    597e:	f1 e4       	ldi	r31, 0x41	; 65
    5980:	6f 16       	cp	r6, r31
    5982:	71 04       	cpc	r7, r1
    5984:	90 f1       	brcs	.+100    	; 0x59ea <_ZN6SX127x13startTransmitEPhjh+0x1ea>
      this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_DIO_MAPPING_1, RADIOLIB_SX127X_DIO1_PACK_FIFO_EMPTY, 5, 4);
    5986:	cc 24       	eor	r12, r12
    5988:	ca 94       	dec	r12
    598a:	68 94       	set
    598c:	ee 24       	eor	r14, r14
    598e:	e1 f8       	bld	r14, 1
    5990:	04 e0       	ldi	r16, 0x04	; 4
    5992:	25 e0       	ldi	r18, 0x05	; 5
    5994:	40 e1       	ldi	r20, 0x10	; 16
    5996:	60 e4       	ldi	r22, 0x40	; 64
    5998:	70 e0       	ldi	r23, 0x00	; 0
    599a:	fe 01       	movw	r30, r28
    599c:	e7 5e       	subi	r30, 0xE7	; 231
    599e:	fe 4f       	sbci	r31, 0xFE	; 254
    59a0:	80 81       	ld	r24, Z
    59a2:	91 81       	ldd	r25, Z+1	; 0x01
    59a4:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    } else {
      this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_DIO_MAPPING_1, RADIOLIB_SX127X_DIO0_PACK_PACKET_SENT, 7, 6);
    }

    // set packet length
    if (this->packetLengthConfig == RADIOLIB_SX127X_PACKET_VARIABLE) {
    59a8:	fe 01       	movw	r30, r28
    59aa:	ed 5c       	subi	r30, 0xCD	; 205
    59ac:	fe 4f       	sbci	r31, 0xFE	; 254
    59ae:	80 81       	ld	r24, Z
    59b0:	80 38       	cpi	r24, 0x80	; 128
    59b2:	69 f1       	breq	.+90     	; 0x5a0e <_ZN6SX127x13startTransmitEPhjh+0x20e>
      this->mod->SPIwriteRegister(RADIOLIB_SX127X_REG_FIFO, len);
    }

    // check address filtering
    uint8_t filter = this->mod->SPIgetRegValue(RADIOLIB_SX127X_REG_PACKET_CONFIG_1, 2, 1);
    59b4:	21 e0       	ldi	r18, 0x01	; 1
    59b6:	42 e0       	ldi	r20, 0x02	; 2
    59b8:	60 e3       	ldi	r22, 0x30	; 48
    59ba:	70 e0       	ldi	r23, 0x00	; 0
    59bc:	fe 01       	movw	r30, r28
    59be:	e7 5e       	subi	r30, 0xE7	; 231
    59c0:	fe 4f       	sbci	r31, 0xFE	; 254
    59c2:	80 81       	ld	r24, Z
    59c4:	91 81       	ldd	r25, Z+1	; 0x01
    59c6:	0e 94 c0 18 	call	0x3180	; 0x3180 <_ZN6Module14SPIgetRegValueEjhh>
    if((filter == RADIOLIB_SX127X_ADDRESS_FILTERING_NODE) || (filter == RADIOLIB_SX127X_ADDRESS_FILTERING_NODE_BROADCAST)) {
    59ca:	82 30       	cpi	r24, 0x02	; 2
    59cc:	19 f0       	breq	.+6      	; 0x59d4 <_ZN6SX127x13startTransmitEPhjh+0x1d4>
    59ce:	84 30       	cpi	r24, 0x04	; 4
    59d0:	09 f0       	breq	.+2      	; 0x59d4 <_ZN6SX127x13startTransmitEPhjh+0x1d4>
    59d2:	39 cf       	rjmp	.-398    	; 0x5846 <_ZN6SX127x13startTransmitEPhjh+0x46>
      this->mod->SPIwriteRegister(RADIOLIB_SX127X_REG_FIFO, addr);
    59d4:	43 2d       	mov	r20, r3
    59d6:	70 e0       	ldi	r23, 0x00	; 0
    59d8:	60 e0       	ldi	r22, 0x00	; 0
    59da:	fe 01       	movw	r30, r28
    59dc:	e7 5e       	subi	r30, 0xE7	; 231
    59de:	fe 4f       	sbci	r31, 0xFE	; 254
    59e0:	80 81       	ld	r24, Z
    59e2:	91 81       	ldd	r25, Z+1	; 0x01
    59e4:	0e 94 ee 16 	call	0x2ddc	; 0x2ddc <_ZN6Module16SPIwriteRegisterEjh>
    59e8:	2e cf       	rjmp	.-420    	; 0x5846 <_ZN6SX127x13startTransmitEPhjh+0x46>

    // set DIO mapping
    if(len > RADIOLIB_SX127X_MAX_PACKET_LENGTH_FSK) {
      this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_DIO_MAPPING_1, RADIOLIB_SX127X_DIO1_PACK_FIFO_EMPTY, 5, 4);
    } else {
      this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_DIO_MAPPING_1, RADIOLIB_SX127X_DIO0_PACK_PACKET_SENT, 7, 6);
    59ea:	cc 24       	eor	r12, r12
    59ec:	ca 94       	dec	r12
    59ee:	68 94       	set
    59f0:	ee 24       	eor	r14, r14
    59f2:	e1 f8       	bld	r14, 1
    59f4:	06 e0       	ldi	r16, 0x06	; 6
    59f6:	27 e0       	ldi	r18, 0x07	; 7
    59f8:	40 e0       	ldi	r20, 0x00	; 0
    59fa:	60 e4       	ldi	r22, 0x40	; 64
    59fc:	70 e0       	ldi	r23, 0x00	; 0
    59fe:	fe 01       	movw	r30, r28
    5a00:	e7 5e       	subi	r30, 0xE7	; 231
    5a02:	fe 4f       	sbci	r31, 0xFE	; 254
    5a04:	80 81       	ld	r24, Z
    5a06:	91 81       	ldd	r25, Z+1	; 0x01
    5a08:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    5a0c:	cd cf       	rjmp	.-102    	; 0x59a8 <_ZN6SX127x13startTransmitEPhjh+0x1a8>
    }

    // set packet length
    if (this->packetLengthConfig == RADIOLIB_SX127X_PACKET_VARIABLE) {
      this->mod->SPIwriteRegister(RADIOLIB_SX127X_REG_FIFO, len);
    5a0e:	46 2d       	mov	r20, r6
    5a10:	70 e0       	ldi	r23, 0x00	; 0
    5a12:	60 e0       	ldi	r22, 0x00	; 0
    5a14:	7a 97       	sbiw	r30, 0x1a	; 26
    5a16:	80 81       	ld	r24, Z
    5a18:	91 81       	ldd	r25, Z+1	; 0x01
    5a1a:	0e 94 ee 16 	call	0x2ddc	; 0x2ddc <_ZN6Module16SPIwriteRegisterEjh>
    5a1e:	ca cf       	rjmp	.-108    	; 0x59b4 <_ZN6SX127x13startTransmitEPhjh+0x1b4>

  // write packet to FIFO
  size_t packetLen = len;
  if((modem == RADIOLIB_SX127X_FSK_OOK) && (len > RADIOLIB_SX127X_MAX_PACKET_LENGTH_FSK)) {
    packetLen = RADIOLIB_SX127X_FIFO_THRESH - 1;
    this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_FIFO_THRESH, RADIOLIB_SX127X_TX_START_FIFO_NOT_EMPTY, 7, 7);
    5a20:	cc 24       	eor	r12, r12
    5a22:	ca 94       	dec	r12
    5a24:	68 94       	set
    5a26:	ee 24       	eor	r14, r14
    5a28:	e1 f8       	bld	r14, 1
    5a2a:	07 e0       	ldi	r16, 0x07	; 7
    5a2c:	27 e0       	ldi	r18, 0x07	; 7
    5a2e:	40 e8       	ldi	r20, 0x80	; 128
    5a30:	65 e3       	ldi	r22, 0x35	; 53
    5a32:	70 e0       	ldi	r23, 0x00	; 0
    5a34:	fe 01       	movw	r30, r28
    5a36:	e7 5e       	subi	r30, 0xE7	; 231
    5a38:	fe 4f       	sbci	r31, 0xFE	; 254
    5a3a:	80 81       	ld	r24, Z
    5a3c:	91 81       	ldd	r25, Z+1	; 0x01
    5a3e:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
  }

  // write packet to FIFO
  size_t packetLen = len;
  if((modem == RADIOLIB_SX127X_FSK_OOK) && (len > RADIOLIB_SX127X_MAX_PACKET_LENGTH_FSK)) {
    packetLen = RADIOLIB_SX127X_FIFO_THRESH - 1;
    5a42:	0f 2e       	mov	r0, r31
    5a44:	fe e1       	ldi	r31, 0x1E	; 30
    5a46:	6f 2e       	mov	r6, r31
    5a48:	71 2c       	mov	r7, r1
    5a4a:	f0 2d       	mov	r31, r0
    5a4c:	03 cf       	rjmp	.-506    	; 0x5854 <_ZN6SX127x13startTransmitEPhjh+0x54>

  int16_t modem = getActiveModem();
  if(modem == RADIOLIB_SX127X_LORA) {
    // check packet length
    if(len > RADIOLIB_SX127X_MAX_PACKET_LENGTH) {
      return(RADIOLIB_ERR_PACKET_TOO_LONG);
    5a4e:	8c ef       	ldi	r24, 0xFC	; 252
    5a50:	9f ef       	ldi	r25, 0xFF	; 255
    5a52:	1a cf       	rjmp	.-460    	; 0x5888 <_ZN6SX127x13startTransmitEPhjh+0x88>

00005a54 <_ZN3gel5Radio13startTransmitEN3etl4spanIhLj65535EEE>:
    setState(Receiving);
    return Error::None;
}

Error Radio::startTransmit(span<uint8_t> msg)
{
    5a54:	0f 93       	push	r16
    5a56:	1f 93       	push	r17
    5a58:	cf 93       	push	r28
    5a5a:	df 93       	push	r29
    5a5c:	ec 01       	movw	r28, r24
    5a5e:	8b 01       	movw	r16, r22
    //*************************************************************************
    /// Returns the size of the span.
    //*************************************************************************
    ETL_NODISCARD ETL_CONSTEXPR size_t size() const ETL_NOEXCEPT
    {
      return (pend - pbegin);
    5a60:	fa 01       	movw	r30, r20
    5a62:	82 81       	ldd	r24, Z+2	; 0x02
    5a64:	93 81       	ldd	r25, Z+3	; 0x03
    5a66:	60 81       	ld	r22, Z
    5a68:	71 81       	ldd	r23, Z+1	; 0x01
    5a6a:	ac 01       	movw	r20, r24
    5a6c:	46 1b       	sub	r20, r22
    5a6e:	57 0b       	sbc	r21, r23
    int err = radio.startTransmit(msg.data(), msg.size());
    5a70:	20 e0       	ldi	r18, 0x00	; 0
    5a72:	c8 01       	movw	r24, r16
    5a74:	c4 96       	adiw	r24, 0x34	; 52
    5a76:	0e 94 00 2c 	call	0x5800	; 0x5800 <_ZN6SX127x13startTransmitEPhjh>

    if (err != RADIOLIB_ERR_NONE)
    5a7a:	89 2b       	or	r24, r25
    5a7c:	81 f0       	breq	.+32     	; 0x5a9e <_ZN3gel5Radio13startTransmitEN3etl4spanIhLj65535EEE+0x4a>
        CapacityFull,
        NotImplemented,
    };

    Error() = default;
    Error(Code other) : code(other) {}
    5a7e:	8c e8       	ldi	r24, 0x8C	; 140
    5a80:	92 e0       	ldi	r25, 0x02	; 2
    5a82:	99 83       	std	Y+1, r25	; 0x01
    5a84:	88 83       	st	Y, r24
    5a86:	87 e0       	ldi	r24, 0x07	; 7
    5a88:	90 e0       	ldi	r25, 0x00	; 0
    5a8a:	9b 83       	std	Y+3, r25	; 0x03
    5a8c:	8a 83       	std	Y+2, r24	; 0x02
    5a8e:	1d 82       	std	Y+5, r1	; 0x05
    5a90:	1c 82       	std	Y+4, r1	; 0x04
        return Error::Internal;

    setState(Transmitting);
    return Error::None;
}
    5a92:	ce 01       	movw	r24, r28
    5a94:	df 91       	pop	r29
    5a96:	cf 91       	pop	r28
    5a98:	1f 91       	pop	r17
    5a9a:	0f 91       	pop	r16
    5a9c:	08 95       	ret
    int err = radio.startTransmit(msg.data(), msg.size());

    if (err != RADIOLIB_ERR_NONE)
        return Error::Internal;

    setState(Transmitting);
    5a9e:	61 e0       	ldi	r22, 0x01	; 1
    5aa0:	70 e0       	ldi	r23, 0x00	; 0
    5aa2:	c8 01       	movw	r24, r16
    5aa4:	0e 94 f5 06 	call	0xdea	; 0xdea <_ZN3gel5Radio8setStateENS0_5StateE>
    5aa8:	8c e8       	ldi	r24, 0x8C	; 140
    5aaa:	92 e0       	ldi	r25, 0x02	; 2
    5aac:	99 83       	std	Y+1, r25	; 0x01
    5aae:	88 83       	st	Y, r24
    5ab0:	1b 82       	std	Y+3, r1	; 0x03
    5ab2:	1a 82       	std	Y+2, r1	; 0x02
    5ab4:	1d 82       	std	Y+5, r1	; 0x05
    5ab6:	1c 82       	std	Y+4, r1	; 0x04
    5ab8:	ec cf       	rjmp	.-40     	; 0x5a92 <_ZN3gel5Radio13startTransmitEN3etl4spanIhLj65535EEE+0x3e>

00005aba <_ZN3gel4Link16update_telemetryEv>:
    
    return Error::None;   
}

Error Link::update_telemetry()
{
    5aba:	cf 92       	push	r12
    5abc:	df 92       	push	r13
    5abe:	ef 92       	push	r14
    5ac0:	ff 92       	push	r15
    5ac2:	0f 93       	push	r16
    5ac4:	1f 93       	push	r17
    5ac6:	cf 93       	push	r28
    5ac8:	df 93       	push	r29
    5aca:	cd b7       	in	r28, 0x3d	; 61
    5acc:	de b7       	in	r29, 0x3e	; 62
    5ace:	64 97       	sbiw	r28, 0x14	; 20
    5ad0:	0f b6       	in	r0, 0x3f	; 63
    5ad2:	f8 94       	cli
    5ad4:	de bf       	out	0x3e, r29	; 62
    5ad6:	0f be       	out	0x3f, r0	; 63
    5ad8:	cd bf       	out	0x3d, r28	; 61
    5ada:	8c 01       	movw	r16, r24
    5adc:	7b 01       	movw	r14, r22
    Radio::State radioState = radio->getState();
    5ade:	db 01       	movw	r26, r22
    5ae0:	11 96       	adiw	r26, 0x01	; 1
    5ae2:	ed 91       	ld	r30, X+
    5ae4:	fc 91       	ld	r31, X
    5ae6:	12 97       	sbiw	r26, 0x02	; 2
    size_t available();

    // Get information about the system
    float getRssi() { return radio.getRSSI(); }
    float getDataRate() { return radio.getDataRate(); }
    State getState() { return currentState; }
    5ae8:	e4 59       	subi	r30, 0x94	; 148
    5aea:	fe 4f       	sbci	r31, 0xFE	; 254
    5aec:	80 81       	ld	r24, Z
    5aee:	91 81       	ldd	r25, Z+1	; 0x01

    switch (radioState)
    5af0:	89 2b       	or	r24, r25
    5af2:	81 f5       	brne	.+96     	; 0x5b54 <_ZN3gel4Link16update_telemetryEv+0x9a>
        // Still transmitting. Simply return
        break;
    
    case Radio::Idle:
        // Not sending. Start sending telemetry
        telemetryCallback(sendPayload);
    5af4:	50 96       	adiw	r26, 0x10	; 16
    5af6:	ed 91       	ld	r30, X+
    5af8:	fc 91       	ld	r31, X
    /// Returns a pointer to the beginning of the vector data.
    ///\return A pointer to the beginning of the vector data.
    //*********************************************************************
    pointer data()
    {
      return p_buffer;
    5afa:	6b 01       	movw	r12, r22
    5afc:	bf ed       	ldi	r27, 0xDF	; 223
    5afe:	cb 1a       	sub	r12, r27
    5b00:	be ef       	ldi	r27, 0xFE	; 254
    5b02:	db 0a       	sbc	r13, r27
    5b04:	d6 01       	movw	r26, r12
    5b06:	13 96       	adiw	r26, 0x03	; 3
    5b08:	2d 91       	ld	r18, X+
    5b0a:	3c 91       	ld	r19, X
    5b0c:	14 97       	sbiw	r26, 0x04	; 4
    /// Gets the current size of the vector.
    ///\return The current size of the vector.
    //*************************************************************************
    size_type size() const
    {
      return size_t(p_end - p_buffer);
    5b0e:	15 96       	adiw	r26, 0x05	; 5
    5b10:	8d 91       	ld	r24, X+
    5b12:	9c 91       	ld	r25, X
    template <typename TContainer, typename = typename etl::enable_if<!etl::is_pointer<etl::remove_reference_t<TContainer>>::value &&
                                                                      !etl::is_array<etl::remove_reference_t<TContainer>>::value &&
                                                                      etl::is_same<etl::remove_cv_t<T>, etl::remove_cv_t<typename etl::remove_reference_t<TContainer>::value_type>>::value, void>::type>
      ETL_CONSTEXPR span(TContainer&& a) ETL_NOEXCEPT
      : pbegin(a.data())
      , pend(a.data() + a.size())
    5b14:	3c 87       	std	Y+12, r19	; 0x0c
    5b16:	2b 87       	std	Y+11, r18	; 0x0b
    5b18:	9e 87       	std	Y+14, r25	; 0x0e
    5b1a:	8d 87       	std	Y+13, r24	; 0x0d
    5b1c:	be 01       	movw	r22, r28
    5b1e:	65 5f       	subi	r22, 0xF5	; 245
    5b20:	7f 4f       	sbci	r23, 0xFF	; 255
    5b22:	ce 01       	movw	r24, r28
    5b24:	0f 96       	adiw	r24, 0x0f	; 15
    5b26:	09 95       	icall
        radio->startTransmit(sendPayload);
    5b28:	f7 01       	movw	r30, r14
    5b2a:	61 81       	ldd	r22, Z+1	; 0x01
    5b2c:	72 81       	ldd	r23, Z+2	; 0x02
    /// Returns a pointer to the beginning of the vector data.
    ///\return A pointer to the beginning of the vector data.
    //*********************************************************************
    pointer data()
    {
      return p_buffer;
    5b2e:	d6 01       	movw	r26, r12
    5b30:	13 96       	adiw	r26, 0x03	; 3
    5b32:	2d 91       	ld	r18, X+
    5b34:	3c 91       	ld	r19, X
    5b36:	14 97       	sbiw	r26, 0x04	; 4
    /// Gets the current size of the vector.
    ///\return The current size of the vector.
    //*************************************************************************
    size_type size() const
    {
      return size_t(p_end - p_buffer);
    5b38:	15 96       	adiw	r26, 0x05	; 5
    5b3a:	8d 91       	ld	r24, X+
    5b3c:	9c 91       	ld	r25, X
    5b3e:	3a 83       	std	Y+2, r19	; 0x02
    5b40:	29 83       	std	Y+1, r18	; 0x01
    5b42:	9c 83       	std	Y+4, r25	; 0x04
    5b44:	8b 83       	std	Y+3, r24	; 0x03
    5b46:	ae 01       	movw	r20, r28
    5b48:	4f 5f       	subi	r20, 0xFF	; 255
    5b4a:	5f 4f       	sbci	r21, 0xFF	; 255
    5b4c:	ce 01       	movw	r24, r28
    5b4e:	05 96       	adiw	r24, 0x05	; 5
    5b50:	0e 94 2a 2d 	call	0x5a54	; 0x5a54 <_ZN3gel5Radio13startTransmitEN3etl4spanIhLj65535EEE>
    5b54:	8c e8       	ldi	r24, 0x8C	; 140
    5b56:	92 e0       	ldi	r25, 0x02	; 2
    5b58:	f8 01       	movw	r30, r16
    5b5a:	91 83       	std	Z+1, r25	; 0x01
    5b5c:	80 83       	st	Z, r24
    5b5e:	13 82       	std	Z+3, r1	; 0x03
    5b60:	12 82       	std	Z+2, r1	; 0x02
    5b62:	15 82       	std	Z+5, r1	; 0x05
    5b64:	14 82       	std	Z+4, r1	; 0x04
    default:
        break;
    }

    return Error::None;
}
    5b66:	c8 01       	movw	r24, r16
    5b68:	64 96       	adiw	r28, 0x14	; 20
    5b6a:	0f b6       	in	r0, 0x3f	; 63
    5b6c:	f8 94       	cli
    5b6e:	de bf       	out	0x3e, r29	; 62
    5b70:	0f be       	out	0x3f, r0	; 63
    5b72:	cd bf       	out	0x3d, r28	; 61
    5b74:	df 91       	pop	r29
    5b76:	cf 91       	pop	r28
    5b78:	1f 91       	pop	r17
    5b7a:	0f 91       	pop	r16
    5b7c:	ff 90       	pop	r15
    5b7e:	ef 90       	pop	r14
    5b80:	df 90       	pop	r13
    5b82:	cf 90       	pop	r12
    5b84:	08 95       	ret

00005b86 <_ZN6SX127x12startReceiveEhh>:

int16_t SX127x::startReceive() {
  return(this->startReceive(0, RADIOLIB_SX127X_RXCONTINUOUS));
}

int16_t SX127x::startReceive(uint8_t len, uint8_t mode) {
    5b86:	8f 92       	push	r8
    5b88:	9f 92       	push	r9
    5b8a:	af 92       	push	r10
    5b8c:	bf 92       	push	r11
    5b8e:	cf 92       	push	r12
    5b90:	ef 92       	push	r14
    5b92:	ff 92       	push	r15
    5b94:	0f 93       	push	r16
    5b96:	1f 93       	push	r17
    5b98:	cf 93       	push	r28
    5b9a:	df 93       	push	r29
    5b9c:	5c 01       	movw	r10, r24
    5b9e:	f6 2e       	mov	r15, r22
    5ba0:	14 2f       	mov	r17, r20
  // set mode to standby
  int16_t state = setMode(RADIOLIB_SX127X_STANDBY);
    5ba2:	61 e0       	ldi	r22, 0x01	; 1
    5ba4:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN6SX127x7setModeEh>
  RADIOLIB_ASSERT(state);
    5ba8:	00 97       	sbiw	r24, 0x00	; 0
    5baa:	61 f0       	breq	.+24     	; 0x5bc4 <_ZN6SX127x12startReceiveEhh+0x3e>
  // set RF switch (if present)
  this->mod->setRfSwitchState(Module::MODE_RX);

  // set mode to receive
  return(setMode(mode));
}
    5bac:	df 91       	pop	r29
    5bae:	cf 91       	pop	r28
    5bb0:	1f 91       	pop	r17
    5bb2:	0f 91       	pop	r16
    5bb4:	ff 90       	pop	r15
    5bb6:	ef 90       	pop	r14
    5bb8:	cf 90       	pop	r12
    5bba:	bf 90       	pop	r11
    5bbc:	af 90       	pop	r10
    5bbe:	9f 90       	pop	r9
    5bc0:	8f 90       	pop	r8
    5bc2:	08 95       	ret
int16_t SX127x::startReceive(uint8_t len, uint8_t mode) {
  // set mode to standby
  int16_t state = setMode(RADIOLIB_SX127X_STANDBY);
  RADIOLIB_ASSERT(state);

  int16_t modem = getActiveModem();
    5bc4:	c5 01       	movw	r24, r10
    5bc6:	0e 94 ec 18 	call	0x31d8	; 0x31d8 <_ZN6SX127x14getActiveModemEv>
  if(modem == RADIOLIB_SX127X_LORA) {
    5bca:	80 38       	cpi	r24, 0x80	; 128
    5bcc:	91 05       	cpc	r25, r1
    5bce:	81 f0       	breq	.+32     	; 0x5bf0 <_ZN6SX127x12startReceiveEhh+0x6a>
    // set FIFO pointers
    state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_FIFO_RX_BASE_ADDR, RADIOLIB_SX127X_FIFO_RX_BASE_ADDR_MAX);
    state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_FIFO_ADDR_PTR, RADIOLIB_SX127X_FIFO_RX_BASE_ADDR_MAX);
    RADIOLIB_ASSERT(state);

  } else if(modem == RADIOLIB_SX127X_FSK_OOK) {
    5bd0:	89 2b       	or	r24, r25
    5bd2:	09 f4       	brne	.+2      	; 0x5bd6 <_ZN6SX127x12startReceiveEhh+0x50>
    5bd4:	88 c0       	rjmp	.+272    	; 0x5ce6 <_ZN6SX127x12startReceiveEhh+0x160>
      return(setMode(RADIOLIB_SX127X_RX));
    }
  }

  // set RF switch (if present)
  this->mod->setRfSwitchState(Module::MODE_RX);
    5bd6:	f5 01       	movw	r30, r10
    5bd8:	e7 5e       	subi	r30, 0xE7	; 231
    5bda:	fe 4f       	sbci	r31, 0xFE	; 254
    5bdc:	62 e0       	ldi	r22, 0x02	; 2
    5bde:	80 81       	ld	r24, Z
    5be0:	91 81       	ldd	r25, Z+1	; 0x01
    5be2:	0e 94 c3 09 	call	0x1386	; 0x1386 <_ZN6Module16setRfSwitchStateEh>

  // set mode to receive
  return(setMode(mode));
    5be6:	61 2f       	mov	r22, r17
    5be8:	c5 01       	movw	r24, r10
    5bea:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN6SX127x7setModeEh>
    5bee:	de cf       	rjmp	.-68     	; 0x5bac <_ZN6SX127x12startReceiveEhh+0x26>
  RADIOLIB_ASSERT(state);

  int16_t modem = getActiveModem();
  if(modem == RADIOLIB_SX127X_LORA) {
    // set DIO pin mapping
    if(this->mod->SPIgetRegValue(RADIOLIB_SX127X_REG_HOP_PERIOD) > RADIOLIB_SX127X_HOP_PERIOD_OFF) {
    5bf0:	20 e0       	ldi	r18, 0x00	; 0
    5bf2:	47 e0       	ldi	r20, 0x07	; 7
    5bf4:	64 e2       	ldi	r22, 0x24	; 36
    5bf6:	70 e0       	ldi	r23, 0x00	; 0
    5bf8:	f5 01       	movw	r30, r10
    5bfa:	e7 5e       	subi	r30, 0xE7	; 231
    5bfc:	fe 4f       	sbci	r31, 0xFE	; 254
    5bfe:	80 81       	ld	r24, Z
    5c00:	91 81       	ldd	r25, Z+1	; 0x01
    5c02:	0e 94 c0 18 	call	0x3180	; 0x3180 <_ZN6Module14SPIgetRegValueEjhh>
    5c06:	18 16       	cp	r1, r24
    5c08:	19 06       	cpc	r1, r25
    5c0a:	0c f0       	brlt	.+2      	; 0x5c0e <_ZN6SX127x12startReceiveEhh+0x88>
    5c0c:	40 c0       	rjmp	.+128    	; 0x5c8e <_ZN6SX127x12startReceiveEhh+0x108>
      state = this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_DIO_MAPPING_1, RADIOLIB_SX127X_DIO0_LORA_RX_DONE | RADIOLIB_SX127X_DIO1_LORA_FHSS_CHANGE_CHANNEL, 7, 4);
    5c0e:	cc 24       	eor	r12, r12
    5c10:	ca 94       	dec	r12
    5c12:	68 94       	set
    5c14:	ee 24       	eor	r14, r14
    5c16:	e1 f8       	bld	r14, 1
    5c18:	04 e0       	ldi	r16, 0x04	; 4
    5c1a:	27 e0       	ldi	r18, 0x07	; 7
    5c1c:	40 e1       	ldi	r20, 0x10	; 16
    5c1e:	60 e4       	ldi	r22, 0x40	; 64
    5c20:	70 e0       	ldi	r23, 0x00	; 0
    5c22:	f5 01       	movw	r30, r10
    5c24:	e7 5e       	subi	r30, 0xE7	; 231
    5c26:	fe 4f       	sbci	r31, 0xFE	; 254
    5c28:	80 81       	ld	r24, Z
    5c2a:	91 81       	ldd	r25, Z+1	; 0x01
    5c2c:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    5c30:	ec 01       	movw	r28, r24
    } else {
      state = this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_DIO_MAPPING_1, RADIOLIB_SX127X_DIO0_LORA_RX_DONE | RADIOLIB_SX127X_DIO1_LORA_RX_TIMEOUT, 7, 4);
    }

    // set expected packet length for SF6
    if(this->spreadingFactor == 6) {
    5c32:	f5 01       	movw	r30, r10
    5c34:	ed 5d       	subi	r30, 0xDD	; 221
    5c36:	fe 4f       	sbci	r31, 0xFE	; 254
    5c38:	80 81       	ld	r24, Z
    5c3a:	86 30       	cpi	r24, 0x06	; 6
    5c3c:	d9 f1       	breq	.+118    	; 0x5cb4 <_ZN6SX127x12startReceiveEhh+0x12e>

    // apply fixes to errata
    RADIOLIB_ERRATA_SX127X(true);

    // clear interrupt flags
    clearIRQFlags();
    5c3e:	c5 01       	movw	r24, r10
    5c40:	0e 94 61 19 	call	0x32c2	; 0x32c2 <_ZN6SX127x13clearIRQFlagsEv>

    // set FIFO pointers
    state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_FIFO_RX_BASE_ADDR, RADIOLIB_SX127X_FIFO_RX_BASE_ADDR_MAX);
    5c44:	cc 24       	eor	r12, r12
    5c46:	ca 94       	dec	r12
    5c48:	68 94       	set
    5c4a:	ee 24       	eor	r14, r14
    5c4c:	e1 f8       	bld	r14, 1
    5c4e:	00 e0       	ldi	r16, 0x00	; 0
    5c50:	27 e0       	ldi	r18, 0x07	; 7
    5c52:	40 e0       	ldi	r20, 0x00	; 0
    5c54:	6f e0       	ldi	r22, 0x0F	; 15
    5c56:	70 e0       	ldi	r23, 0x00	; 0
    5c58:	45 01       	movw	r8, r10
    5c5a:	87 ee       	ldi	r24, 0xE7	; 231
    5c5c:	88 1a       	sub	r8, r24
    5c5e:	8e ef       	ldi	r24, 0xFE	; 254
    5c60:	98 0a       	sbc	r9, r24
    5c62:	f4 01       	movw	r30, r8
    5c64:	80 81       	ld	r24, Z
    5c66:	91 81       	ldd	r25, Z+1	; 0x01
    5c68:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    5c6c:	c8 2b       	or	r28, r24
    5c6e:	d9 2b       	or	r29, r25
    state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_FIFO_ADDR_PTR, RADIOLIB_SX127X_FIFO_RX_BASE_ADDR_MAX);
    5c70:	27 e0       	ldi	r18, 0x07	; 7
    5c72:	40 e0       	ldi	r20, 0x00	; 0
    5c74:	6d e0       	ldi	r22, 0x0D	; 13
    5c76:	70 e0       	ldi	r23, 0x00	; 0
    5c78:	f4 01       	movw	r30, r8
    5c7a:	80 81       	ld	r24, Z
    5c7c:	91 81       	ldd	r25, Z+1	; 0x01
    5c7e:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    5c82:	8c 2b       	or	r24, r28
    5c84:	9d 2b       	or	r25, r29
    RADIOLIB_ASSERT(state);
    5c86:	00 97       	sbiw	r24, 0x00	; 0
    5c88:	09 f4       	brne	.+2      	; 0x5c8c <_ZN6SX127x12startReceiveEhh+0x106>
    5c8a:	a5 cf       	rjmp	.-182    	; 0x5bd6 <_ZN6SX127x12startReceiveEhh+0x50>
    5c8c:	8f cf       	rjmp	.-226    	; 0x5bac <_ZN6SX127x12startReceiveEhh+0x26>
  if(modem == RADIOLIB_SX127X_LORA) {
    // set DIO pin mapping
    if(this->mod->SPIgetRegValue(RADIOLIB_SX127X_REG_HOP_PERIOD) > RADIOLIB_SX127X_HOP_PERIOD_OFF) {
      state = this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_DIO_MAPPING_1, RADIOLIB_SX127X_DIO0_LORA_RX_DONE | RADIOLIB_SX127X_DIO1_LORA_FHSS_CHANGE_CHANNEL, 7, 4);
    } else {
      state = this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_DIO_MAPPING_1, RADIOLIB_SX127X_DIO0_LORA_RX_DONE | RADIOLIB_SX127X_DIO1_LORA_RX_TIMEOUT, 7, 4);
    5c8e:	cc 24       	eor	r12, r12
    5c90:	ca 94       	dec	r12
    5c92:	68 94       	set
    5c94:	ee 24       	eor	r14, r14
    5c96:	e1 f8       	bld	r14, 1
    5c98:	04 e0       	ldi	r16, 0x04	; 4
    5c9a:	27 e0       	ldi	r18, 0x07	; 7
    5c9c:	40 e0       	ldi	r20, 0x00	; 0
    5c9e:	60 e4       	ldi	r22, 0x40	; 64
    5ca0:	70 e0       	ldi	r23, 0x00	; 0
    5ca2:	f5 01       	movw	r30, r10
    5ca4:	e7 5e       	subi	r30, 0xE7	; 231
    5ca6:	fe 4f       	sbci	r31, 0xFE	; 254
    5ca8:	80 81       	ld	r24, Z
    5caa:	91 81       	ldd	r25, Z+1	; 0x01
    5cac:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    5cb0:	ec 01       	movw	r28, r24
    5cb2:	bf cf       	rjmp	.-130    	; 0x5c32 <_ZN6SX127x12startReceiveEhh+0xac>
    }

    // set expected packet length for SF6
    if(this->spreadingFactor == 6) {
      state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_PAYLOAD_LENGTH, len);
    5cb4:	cc 24       	eor	r12, r12
    5cb6:	ca 94       	dec	r12
    5cb8:	68 94       	set
    5cba:	ee 24       	eor	r14, r14
    5cbc:	e1 f8       	bld	r14, 1
    5cbe:	00 e0       	ldi	r16, 0x00	; 0
    5cc0:	27 e0       	ldi	r18, 0x07	; 7
    5cc2:	4f 2d       	mov	r20, r15
    5cc4:	62 e2       	ldi	r22, 0x22	; 34
    5cc6:	70 e0       	ldi	r23, 0x00	; 0
    5cc8:	3a 97       	sbiw	r30, 0x0a	; 10
    5cca:	80 81       	ld	r24, Z
    5ccc:	91 81       	ldd	r25, Z+1	; 0x01
    5cce:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    5cd2:	c8 2b       	or	r28, r24
    5cd4:	d9 2b       	or	r29, r25
      this->packetLength = len;
    5cd6:	f5 01       	movw	r30, r10
    5cd8:	e4 5d       	subi	r30, 0xD4	; 212
    5cda:	fe 4f       	sbci	r31, 0xFE	; 254
    5cdc:	8f 2d       	mov	r24, r15
    5cde:	90 e0       	ldi	r25, 0x00	; 0
    5ce0:	91 83       	std	Z+1, r25	; 0x01
    5ce2:	80 83       	st	Z, r24
    5ce4:	ac cf       	rjmp	.-168    	; 0x5c3e <_ZN6SX127x12startReceiveEhh+0xb8>
    state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_FIFO_ADDR_PTR, RADIOLIB_SX127X_FIFO_RX_BASE_ADDR_MAX);
    RADIOLIB_ASSERT(state);

  } else if(modem == RADIOLIB_SX127X_FSK_OOK) {
    // set DIO pin mapping
    state = this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_DIO_MAPPING_1, RADIOLIB_SX127X_DIO0_PACK_PAYLOAD_READY, 7, 6);
    5ce6:	cc 24       	eor	r12, r12
    5ce8:	ca 94       	dec	r12
    5cea:	68 94       	set
    5cec:	ee 24       	eor	r14, r14
    5cee:	e1 f8       	bld	r14, 1
    5cf0:	06 e0       	ldi	r16, 0x06	; 6
    5cf2:	27 e0       	ldi	r18, 0x07	; 7
    5cf4:	40 e0       	ldi	r20, 0x00	; 0
    5cf6:	60 e4       	ldi	r22, 0x40	; 64
    5cf8:	70 e0       	ldi	r23, 0x00	; 0
    5cfa:	f5 01       	movw	r30, r10
    5cfc:	e7 5e       	subi	r30, 0xE7	; 231
    5cfe:	fe 4f       	sbci	r31, 0xFE	; 254
    5d00:	80 81       	ld	r24, Z
    5d02:	91 81       	ldd	r25, Z+1	; 0x01
    5d04:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    RADIOLIB_ASSERT(state);
    5d08:	00 97       	sbiw	r24, 0x00	; 0
    5d0a:	09 f0       	breq	.+2      	; 0x5d0e <_ZN6SX127x12startReceiveEhh+0x188>
    5d0c:	4f cf       	rjmp	.-354    	; 0x5bac <_ZN6SX127x12startReceiveEhh+0x26>

    // clear interrupt flags
    clearIRQFlags();
    5d0e:	c5 01       	movw	r24, r10
    5d10:	0e 94 61 19 	call	0x32c2	; 0x32c2 <_ZN6SX127x13clearIRQFlagsEv>

    // FSK modem does not distinguish between Rx single and continuous
    if(mode == RADIOLIB_SX127X_RXCONTINUOUS) {
    5d14:	15 30       	cpi	r17, 0x05	; 5
    5d16:	09 f0       	breq	.+2      	; 0x5d1a <_ZN6SX127x12startReceiveEhh+0x194>
    5d18:	5e cf       	rjmp	.-324    	; 0x5bd6 <_ZN6SX127x12startReceiveEhh+0x50>
      // set RF switch (if present)
      this->mod->setRfSwitchState(Module::MODE_RX);
    5d1a:	f5 01       	movw	r30, r10
    5d1c:	e7 5e       	subi	r30, 0xE7	; 231
    5d1e:	fe 4f       	sbci	r31, 0xFE	; 254
    5d20:	62 e0       	ldi	r22, 0x02	; 2
    5d22:	80 81       	ld	r24, Z
    5d24:	91 81       	ldd	r25, Z+1	; 0x01
    5d26:	0e 94 c3 09 	call	0x1386	; 0x1386 <_ZN6Module16setRfSwitchStateEh>
      return(setMode(RADIOLIB_SX127X_RX));
    5d2a:	65 e0       	ldi	r22, 0x05	; 5
    5d2c:	c5 01       	movw	r24, r10
    5d2e:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN6SX127x7setModeEh>
    5d32:	3c cf       	rjmp	.-392    	; 0x5bac <_ZN6SX127x12startReceiveEhh+0x26>

00005d34 <_ZN6SX127x12startReceiveEmjjj>:

  // set mode to receive
  return(setMode(mode));
}

int16_t SX127x::startReceive(uint32_t mode, uint16_t irqFlags, uint16_t irqMask, size_t len) {
    5d34:	ef 92       	push	r14
    5d36:	6e 2d       	mov	r22, r14
  (void)irqFlags;
  (void)irqMask;
  return(startReceive((uint8_t)len, (uint8_t)mode));
    5d38:	0e 94 c3 2d 	call	0x5b86	; 0x5b86 <_ZN6SX127x12startReceiveEhh>
}
    5d3c:	ef 90       	pop	r14
    5d3e:	08 95       	ret

00005d40 <_ZN6SX127x12startReceiveEv>:

  return(this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_PACKET_CONFIG_2, RADIOLIB_SX127X_DATA_MODE_PACKET, 6, 6));
}

int16_t SX127x::startReceive() {
  return(this->startReceive(0, RADIOLIB_SX127X_RXCONTINUOUS));
    5d40:	45 e0       	ldi	r20, 0x05	; 5
    5d42:	60 e0       	ldi	r22, 0x00	; 0
    5d44:	0e 94 c3 2d 	call	0x5b86	; 0x5b86 <_ZN6SX127x12startReceiveEhh>
}
    5d48:	08 95       	ret

00005d4a <_ZN3gel5Radio12startReceiveEv>:
{
    return Error::None;
}

Error Radio::startReceive()
{
    5d4a:	0f 93       	push	r16
    5d4c:	1f 93       	push	r17
    5d4e:	cf 93       	push	r28
    5d50:	df 93       	push	r29
    5d52:	ec 01       	movw	r28, r24
    5d54:	8b 01       	movw	r16, r22
    int err = radio.startReceive();
    5d56:	cb 01       	movw	r24, r22
    5d58:	c4 96       	adiw	r24, 0x34	; 52
    5d5a:	0e 94 a0 2e 	call	0x5d40	; 0x5d40 <_ZN6SX127x12startReceiveEv>

    if (err != RADIOLIB_ERR_NONE)
    5d5e:	89 2b       	or	r24, r25
    5d60:	81 f0       	breq	.+32     	; 0x5d82 <_ZN3gel5Radio12startReceiveEv+0x38>
    5d62:	8c e8       	ldi	r24, 0x8C	; 140
    5d64:	92 e0       	ldi	r25, 0x02	; 2
    5d66:	99 83       	std	Y+1, r25	; 0x01
    5d68:	88 83       	st	Y, r24
    5d6a:	87 e0       	ldi	r24, 0x07	; 7
    5d6c:	90 e0       	ldi	r25, 0x00	; 0
    5d6e:	9b 83       	std	Y+3, r25	; 0x03
    5d70:	8a 83       	std	Y+2, r24	; 0x02
    5d72:	1d 82       	std	Y+5, r1	; 0x05
    5d74:	1c 82       	std	Y+4, r1	; 0x04
        return Error::Internal;

    setState(Receiving);
    return Error::None;
}
    5d76:	ce 01       	movw	r24, r28
    5d78:	df 91       	pop	r29
    5d7a:	cf 91       	pop	r28
    5d7c:	1f 91       	pop	r17
    5d7e:	0f 91       	pop	r16
    5d80:	08 95       	ret
    int err = radio.startReceive();

    if (err != RADIOLIB_ERR_NONE)
        return Error::Internal;

    setState(Receiving);
    5d82:	62 e0       	ldi	r22, 0x02	; 2
    5d84:	70 e0       	ldi	r23, 0x00	; 0
    5d86:	c8 01       	movw	r24, r16
    5d88:	0e 94 f5 06 	call	0xdea	; 0xdea <_ZN3gel5Radio8setStateENS0_5StateE>
    5d8c:	8c e8       	ldi	r24, 0x8C	; 140
    5d8e:	92 e0       	ldi	r25, 0x02	; 2
    5d90:	99 83       	std	Y+1, r25	; 0x01
    5d92:	88 83       	st	Y, r24
    5d94:	1b 82       	std	Y+3, r1	; 0x03
    5d96:	1a 82       	std	Y+2, r1	; 0x02
    5d98:	1d 82       	std	Y+5, r1	; 0x05
    5d9a:	1c 82       	std	Y+4, r1	; 0x04
    5d9c:	ec cf       	rjmp	.-40     	; 0x5d76 <_ZN3gel5Radio12startReceiveEv+0x2c>

00005d9e <_ZN6SX127x7receiveEPhj>:
  this->dataRate = (len*8.0)/((float)elapsed/1000000.0);

  return(finishTransmit());
}

int16_t SX127x::receive(uint8_t* data, size_t len) {
    5d9e:	4f 92       	push	r4
    5da0:	5f 92       	push	r5
    5da2:	6f 92       	push	r6
    5da4:	7f 92       	push	r7
    5da6:	8f 92       	push	r8
    5da8:	9f 92       	push	r9
    5daa:	af 92       	push	r10
    5dac:	bf 92       	push	r11
    5dae:	cf 92       	push	r12
    5db0:	df 92       	push	r13
    5db2:	ef 92       	push	r14
    5db4:	ff 92       	push	r15
    5db6:	0f 93       	push	r16
    5db8:	1f 93       	push	r17
    5dba:	cf 93       	push	r28
    5dbc:	df 93       	push	r29
    5dbe:	ec 01       	movw	r28, r24
    5dc0:	2b 01       	movw	r4, r22
    5dc2:	74 2e       	mov	r7, r20
    5dc4:	65 2e       	mov	r6, r21
  // set mode to standby
  int16_t state = setMode(RADIOLIB_SX127X_STANDBY);
    5dc6:	61 e0       	ldi	r22, 0x01	; 1
    5dc8:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN6SX127x7setModeEh>
  RADIOLIB_ASSERT(state);
    5dcc:	00 97       	sbiw	r24, 0x00	; 0
    5dce:	89 f0       	breq	.+34     	; 0x5df2 <_ZN6SX127x7receiveEPhj+0x54>

  // read the received data
  state = readData(data, len);

  return(state);
}
    5dd0:	df 91       	pop	r29
    5dd2:	cf 91       	pop	r28
    5dd4:	1f 91       	pop	r17
    5dd6:	0f 91       	pop	r16
    5dd8:	ff 90       	pop	r15
    5dda:	ef 90       	pop	r14
    5ddc:	df 90       	pop	r13
    5dde:	cf 90       	pop	r12
    5de0:	bf 90       	pop	r11
    5de2:	af 90       	pop	r10
    5de4:	9f 90       	pop	r9
    5de6:	8f 90       	pop	r8
    5de8:	7f 90       	pop	r7
    5dea:	6f 90       	pop	r6
    5dec:	5f 90       	pop	r5
    5dee:	4f 90       	pop	r4
    5df0:	08 95       	ret
int16_t SX127x::receive(uint8_t* data, size_t len) {
  // set mode to standby
  int16_t state = setMode(RADIOLIB_SX127X_STANDBY);
  RADIOLIB_ASSERT(state);

  int16_t modem = getActiveModem();
    5df2:	ce 01       	movw	r24, r28
    5df4:	0e 94 ec 18 	call	0x31d8	; 0x31d8 <_ZN6SX127x14getActiveModemEv>
  if(modem == RADIOLIB_SX127X_LORA) {
    5df8:	80 38       	cpi	r24, 0x80	; 128
    5dfa:	91 05       	cpc	r25, r1
    5dfc:	09 f4       	brne	.+2      	; 0x5e00 <_ZN6SX127x7receiveEPhj+0x62>
    5dfe:	77 c0       	rjmp	.+238    	; 0x5eee <_ZN6SX127x7receiveEPhj+0x150>
        }
      }

    }

  } else if(modem == RADIOLIB_SX127X_FSK_OOK) {
    5e00:	89 2b       	or	r24, r25
    5e02:	09 f0       	breq	.+2      	; 0x5e06 <_ZN6SX127x7receiveEPhj+0x68>
    5e04:	24 c1       	rjmp	.+584    	; 0x604e <_ZN6SX127x7receiveEPhj+0x2b0>
    // calculate timeout (500 % of expected time-on-air)
    uint32_t timeout = getTimeOnAir(len) * 5;
    5e06:	e8 81       	ld	r30, Y
    5e08:	f9 81       	ldd	r31, Y+1	; 0x01
    5e0a:	02 a8       	ldd	r0, Z+50	; 0x32
    5e0c:	f3 a9       	ldd	r31, Z+51	; 0x33
    5e0e:	e0 2d       	mov	r30, r0
    5e10:	67 2d       	mov	r22, r7
    5e12:	76 2d       	mov	r23, r6
    5e14:	ce 01       	movw	r24, r28
    5e16:	09 95       	icall
    5e18:	6b 01       	movw	r12, r22
    5e1a:	7c 01       	movw	r14, r24
    5e1c:	cc 0c       	add	r12, r12
    5e1e:	dd 1c       	adc	r13, r13
    5e20:	ee 1c       	adc	r14, r14
    5e22:	ff 1c       	adc	r15, r15
    5e24:	cc 0c       	add	r12, r12
    5e26:	dd 1c       	adc	r13, r13
    5e28:	ee 1c       	adc	r14, r14
    5e2a:	ff 1c       	adc	r15, r15
    5e2c:	c6 0e       	add	r12, r22
    5e2e:	d7 1e       	adc	r13, r23
    5e30:	e8 1e       	adc	r14, r24
    5e32:	f9 1e       	adc	r15, r25

    // set mode to receive
    state = startReceive(len, RADIOLIB_SX127X_RX);
    5e34:	45 e0       	ldi	r20, 0x05	; 5
    5e36:	67 2d       	mov	r22, r7
    5e38:	ce 01       	movw	r24, r28
    5e3a:	0e 94 c3 2d 	call	0x5b86	; 0x5b86 <_ZN6SX127x12startReceiveEhh>
    RADIOLIB_ASSERT(state);
    5e3e:	00 97       	sbiw	r24, 0x00	; 0
    5e40:	39 f6       	brne	.-114    	; 0x5dd0 <_ZN6SX127x7receiveEPhj+0x32>

    // wait for packet reception or timeout
    uint32_t start = this->mod->hal->micros();
    5e42:	fe 01       	movw	r30, r28
    5e44:	e7 5e       	subi	r30, 0xE7	; 231
    5e46:	fe 4f       	sbci	r31, 0xFE	; 254
    5e48:	01 90       	ld	r0, Z+
    5e4a:	f0 81       	ld	r31, Z
    5e4c:	e0 2d       	mov	r30, r0
    5e4e:	80 81       	ld	r24, Z
    5e50:	91 81       	ldd	r25, Z+1	; 0x01
    5e52:	dc 01       	movw	r26, r24
    5e54:	ed 91       	ld	r30, X+
    5e56:	fc 91       	ld	r31, X
    5e58:	00 88       	ldd	r0, Z+16	; 0x10
    5e5a:	f1 89       	ldd	r31, Z+17	; 0x11
    5e5c:	e0 2d       	mov	r30, r0
    5e5e:	09 95       	icall
    5e60:	4b 01       	movw	r8, r22
    5e62:	5c 01       	movw	r10, r24
    while(!this->mod->hal->digitalRead(this->mod->getIrq())) {
    5e64:	fe 01       	movw	r30, r28
    5e66:	e7 5e       	subi	r30, 0xE7	; 231
    5e68:	fe 4f       	sbci	r31, 0xFE	; 254
    5e6a:	a0 81       	ld	r26, Z
    5e6c:	b1 81       	ldd	r27, Z+1	; 0x01
    5e6e:	8d 91       	ld	r24, X+
    5e70:	9c 91       	ld	r25, X
    5e72:	11 97       	sbiw	r26, 0x01	; 1
    5e74:	fc 01       	movw	r30, r24
    5e76:	20 81       	ld	r18, Z
    5e78:	31 81       	ldd	r19, Z+1	; 0x01
    5e7a:	f9 01       	movw	r30, r18
    5e7c:	24 81       	ldd	r18, Z+4	; 0x04
    5e7e:	35 81       	ldd	r19, Z+5	; 0x05

    /*!
      \brief Access method to get the pin number of interrupt/GPIO.
      \returns Pin number of interrupt/GPIO configured in the constructor.
    */
    uint32_t getIrq() const { return(irqPin); }
    5e80:	50 96       	adiw	r26, 0x10	; 16
    5e82:	4d 91       	ld	r20, X+
    5e84:	5d 91       	ld	r21, X+
    5e86:	6d 91       	ld	r22, X+
    5e88:	7c 91       	ld	r23, X
    5e8a:	53 97       	sbiw	r26, 0x13	; 19
    5e8c:	f9 01       	movw	r30, r18
    5e8e:	09 95       	icall
    5e90:	67 2b       	or	r22, r23
    5e92:	68 2b       	or	r22, r24
    5e94:	69 2b       	or	r22, r25
    5e96:	09 f0       	breq	.+2      	; 0x5e9a <_ZN6SX127x7receiveEPhj+0xfc>
    5e98:	da c0       	rjmp	.+436    	; 0x604e <_ZN6SX127x7receiveEPhj+0x2b0>
      this->mod->hal->yield();
    5e9a:	8e 01       	movw	r16, r28
    5e9c:	07 5e       	subi	r16, 0xE7	; 231
    5e9e:	1e 4f       	sbci	r17, 0xFE	; 254
    5ea0:	d8 01       	movw	r26, r16
    5ea2:	ed 91       	ld	r30, X+
    5ea4:	fc 91       	ld	r31, X
    5ea6:	80 81       	ld	r24, Z
    5ea8:	91 81       	ldd	r25, Z+1	; 0x01
    5eaa:	dc 01       	movw	r26, r24
    5eac:	ed 91       	ld	r30, X+
    5eae:	fc 91       	ld	r31, X
    5eb0:	06 a0       	ldd	r0, Z+38	; 0x26
    5eb2:	f7 a1       	ldd	r31, Z+39	; 0x27
    5eb4:	e0 2d       	mov	r30, r0
    5eb6:	09 95       	icall
      if(this->mod->hal->micros() - start > timeout) {
    5eb8:	d8 01       	movw	r26, r16
    5eba:	ed 91       	ld	r30, X+
    5ebc:	fc 91       	ld	r31, X
    5ebe:	80 81       	ld	r24, Z
    5ec0:	91 81       	ldd	r25, Z+1	; 0x01
    5ec2:	dc 01       	movw	r26, r24
    5ec4:	ed 91       	ld	r30, X+
    5ec6:	fc 91       	ld	r31, X
    5ec8:	00 88       	ldd	r0, Z+16	; 0x10
    5eca:	f1 89       	ldd	r31, Z+17	; 0x11
    5ecc:	e0 2d       	mov	r30, r0
    5ece:	09 95       	icall
    5ed0:	68 19       	sub	r22, r8
    5ed2:	79 09       	sbc	r23, r9
    5ed4:	8a 09       	sbc	r24, r10
    5ed6:	9b 09       	sbc	r25, r11
    5ed8:	c6 16       	cp	r12, r22
    5eda:	d7 06       	cpc	r13, r23
    5edc:	e8 06       	cpc	r14, r24
    5ede:	f9 06       	cpc	r15, r25
    5ee0:	08 f6       	brcc	.-126    	; 0x5e64 <_ZN6SX127x7receiveEPhj+0xc6>
        clearIRQFlags();
    5ee2:	ce 01       	movw	r24, r28
    5ee4:	0e 94 61 19 	call	0x32c2	; 0x32c2 <_ZN6SX127x13clearIRQFlagsEv>
        return(RADIOLIB_ERR_RX_TIMEOUT);
    5ee8:	8a ef       	ldi	r24, 0xFA	; 250
    5eea:	9f ef       	ldi	r25, 0xFF	; 255
    5eec:	71 cf       	rjmp	.-286    	; 0x5dd0 <_ZN6SX127x7receiveEPhj+0x32>
  RADIOLIB_ASSERT(state);

  int16_t modem = getActiveModem();
  if(modem == RADIOLIB_SX127X_LORA) {
    // set mode to receive
    state = startReceive(len, RADIOLIB_SX127X_RXSINGLE);
    5eee:	46 e0       	ldi	r20, 0x06	; 6
    5ef0:	67 2d       	mov	r22, r7
    5ef2:	ce 01       	movw	r24, r28
    5ef4:	0e 94 c3 2d 	call	0x5b86	; 0x5b86 <_ZN6SX127x12startReceiveEhh>
    RADIOLIB_ASSERT(state);
    5ef8:	00 97       	sbiw	r24, 0x00	; 0
    5efa:	09 f0       	breq	.+2      	; 0x5efe <_ZN6SX127x7receiveEPhj+0x160>
    5efc:	69 cf       	rjmp	.-302    	; 0x5dd0 <_ZN6SX127x7receiveEPhj+0x32>

    // if no DIO1 is provided, use software timeout (100 LoRa symbols, same as hardware timeout)
    uint32_t timeout = 0;
    if(this->mod->getGpio() == RADIOLIB_NC) {
    5efe:	fe 01       	movw	r30, r28
    5f00:	e7 5e       	subi	r30, 0xE7	; 231
    5f02:	fe 4f       	sbci	r31, 0xFE	; 254
    5f04:	00 81       	ld	r16, Z
    5f06:	11 81       	ldd	r17, Z+1	; 0x01

    /*!
      \brief Access method to get the pin number of second interrupt/GPIO.
      \returns Pin number of second interrupt/GPIO configured in the constructor.
    */
    uint32_t getGpio() const { return(gpioPin); }
    5f08:	f8 01       	movw	r30, r16
    5f0a:	80 8d       	ldd	r24, Z+24	; 0x18
    5f0c:	91 8d       	ldd	r25, Z+25	; 0x19
    5f0e:	a2 8d       	ldd	r26, Z+26	; 0x1a
    5f10:	b3 8d       	ldd	r27, Z+27	; 0x1b
    5f12:	8f 3f       	cpi	r24, 0xFF	; 255
    5f14:	9f 4f       	sbci	r25, 0xFF	; 255
    5f16:	af 4f       	sbci	r26, 0xFF	; 255
    5f18:	bf 4f       	sbci	r27, 0xFF	; 255
    5f1a:	81 f0       	breq	.+32     	; 0x5f3c <_ZN6SX127x7receiveEPhj+0x19e>
    // set mode to receive
    state = startReceive(len, RADIOLIB_SX127X_RXSINGLE);
    RADIOLIB_ASSERT(state);

    // if no DIO1 is provided, use software timeout (100 LoRa symbols, same as hardware timeout)
    uint32_t timeout = 0;
    5f1c:	81 2c       	mov	r8, r1
    5f1e:	91 2c       	mov	r9, r1
    5f20:	54 01       	movw	r10, r8
      float symbolLength = (float) (uint32_t(1) << this->spreadingFactor) / (float) this->bandwidth;
      timeout = 100*symbolLength;
    }

    // wait for packet reception or timeout
    uint32_t start = this->mod->hal->micros();
    5f22:	d8 01       	movw	r26, r16
    5f24:	8d 91       	ld	r24, X+
    5f26:	9c 91       	ld	r25, X
    5f28:	dc 01       	movw	r26, r24
    5f2a:	ed 91       	ld	r30, X+
    5f2c:	fc 91       	ld	r31, X
    5f2e:	00 88       	ldd	r0, Z+16	; 0x10
    5f30:	f1 89       	ldd	r31, Z+17	; 0x11
    5f32:	e0 2d       	mov	r30, r0
    5f34:	09 95       	icall
    5f36:	6b 01       	movw	r12, r22
    5f38:	7c 01       	movw	r14, r24
    5f3a:	38 c0       	rjmp	.+112    	; 0x5fac <_ZN6SX127x7receiveEPhj+0x20e>
    RADIOLIB_ASSERT(state);

    // if no DIO1 is provided, use software timeout (100 LoRa symbols, same as hardware timeout)
    uint32_t timeout = 0;
    if(this->mod->getGpio() == RADIOLIB_NC) {
      float symbolLength = (float) (uint32_t(1) << this->spreadingFactor) / (float) this->bandwidth;
    5f3c:	fe 01       	movw	r30, r28
    5f3e:	ed 5d       	subi	r30, 0xDD	; 221
    5f40:	fe 4f       	sbci	r31, 0xFE	; 254
    5f42:	20 81       	ld	r18, Z
    5f44:	61 e0       	ldi	r22, 0x01	; 1
    5f46:	70 e0       	ldi	r23, 0x00	; 0
    5f48:	80 e0       	ldi	r24, 0x00	; 0
    5f4a:	90 e0       	ldi	r25, 0x00	; 0
    5f4c:	04 c0       	rjmp	.+8      	; 0x5f56 <_ZN6SX127x7receiveEPhj+0x1b8>
    5f4e:	66 0f       	add	r22, r22
    5f50:	77 1f       	adc	r23, r23
    5f52:	88 1f       	adc	r24, r24
    5f54:	99 1f       	adc	r25, r25
    5f56:	2a 95       	dec	r18
    5f58:	d2 f7       	brpl	.-12     	; 0x5f4e <_ZN6SX127x7receiveEPhj+0x1b0>
    5f5a:	0e 94 76 39 	call	0x72ec	; 0x72ec <__floatunsisf>
    5f5e:	fe 01       	movw	r30, r28
    5f60:	e1 5e       	subi	r30, 0xE1	; 225
    5f62:	fe 4f       	sbci	r31, 0xFE	; 254
    5f64:	20 81       	ld	r18, Z
    5f66:	31 81       	ldd	r19, Z+1	; 0x01
    5f68:	42 81       	ldd	r20, Z+2	; 0x02
    5f6a:	53 81       	ldd	r21, Z+3	; 0x03
    5f6c:	0e 94 ef 3b 	call	0x77de	; 0x77de <__divsf3>
      timeout = 100*symbolLength;
    5f70:	20 e0       	ldi	r18, 0x00	; 0
    5f72:	30 e0       	ldi	r19, 0x00	; 0
    5f74:	48 ec       	ldi	r20, 0xC8	; 200
    5f76:	52 e4       	ldi	r21, 0x42	; 66
    5f78:	0e 94 d7 39 	call	0x73ae	; 0x73ae <__mulsf3>
    5f7c:	0e 94 61 3c 	call	0x78c2	; 0x78c2 <__fixunssfsi>
    5f80:	4b 01       	movw	r8, r22
    5f82:	5c 01       	movw	r10, r24
    5f84:	ce cf       	rjmp	.-100    	; 0x5f22 <_ZN6SX127x7receiveEPhj+0x184>
    while(!this->mod->hal->digitalRead(this->mod->getIrq())) {
      this->mod->hal->yield();

      if(this->mod->getGpio() == RADIOLIB_NC) {
        // no GPIO pin provided, use software timeout
        if(this->mod->hal->micros() - start > timeout) {
    5f86:	80 81       	ld	r24, Z
    5f88:	91 81       	ldd	r25, Z+1	; 0x01
    5f8a:	dc 01       	movw	r26, r24
    5f8c:	ed 91       	ld	r30, X+
    5f8e:	fc 91       	ld	r31, X
    5f90:	00 88       	ldd	r0, Z+16	; 0x10
    5f92:	f1 89       	ldd	r31, Z+17	; 0x11
    5f94:	e0 2d       	mov	r30, r0
    5f96:	09 95       	icall
    5f98:	6c 19       	sub	r22, r12
    5f9a:	7d 09       	sbc	r23, r13
    5f9c:	8e 09       	sbc	r24, r14
    5f9e:	9f 09       	sbc	r25, r15
    5fa0:	86 16       	cp	r8, r22
    5fa2:	97 06       	cpc	r9, r23
    5fa4:	a8 06       	cpc	r10, r24
    5fa6:	b9 06       	cpc	r11, r25
    5fa8:	08 f4       	brcc	.+2      	; 0x5fac <_ZN6SX127x7receiveEPhj+0x20e>
    5faa:	4b c0       	rjmp	.+150    	; 0x6042 <_ZN6SX127x7receiveEPhj+0x2a4>
      timeout = 100*symbolLength;
    }

    // wait for packet reception or timeout
    uint32_t start = this->mod->hal->micros();
    while(!this->mod->hal->digitalRead(this->mod->getIrq())) {
    5fac:	fe 01       	movw	r30, r28
    5fae:	e7 5e       	subi	r30, 0xE7	; 231
    5fb0:	fe 4f       	sbci	r31, 0xFE	; 254
    5fb2:	a0 81       	ld	r26, Z
    5fb4:	b1 81       	ldd	r27, Z+1	; 0x01
    5fb6:	8d 91       	ld	r24, X+
    5fb8:	9c 91       	ld	r25, X
    5fba:	11 97       	sbiw	r26, 0x01	; 1
    5fbc:	fc 01       	movw	r30, r24
    5fbe:	20 81       	ld	r18, Z
    5fc0:	31 81       	ldd	r19, Z+1	; 0x01
    5fc2:	f9 01       	movw	r30, r18
    5fc4:	24 81       	ldd	r18, Z+4	; 0x04
    5fc6:	35 81       	ldd	r19, Z+5	; 0x05

    /*!
      \brief Access method to get the pin number of interrupt/GPIO.
      \returns Pin number of interrupt/GPIO configured in the constructor.
    */
    uint32_t getIrq() const { return(irqPin); }
    5fc8:	50 96       	adiw	r26, 0x10	; 16
    5fca:	4d 91       	ld	r20, X+
    5fcc:	5d 91       	ld	r21, X+
    5fce:	6d 91       	ld	r22, X+
    5fd0:	7c 91       	ld	r23, X
    5fd2:	53 97       	sbiw	r26, 0x13	; 19
    5fd4:	f9 01       	movw	r30, r18
    5fd6:	09 95       	icall
    5fd8:	67 2b       	or	r22, r23
    5fda:	68 2b       	or	r22, r24
    5fdc:	69 2b       	or	r22, r25
    5fde:	b9 f5       	brne	.+110    	; 0x604e <_ZN6SX127x7receiveEPhj+0x2b0>
      this->mod->hal->yield();
    5fe0:	8e 01       	movw	r16, r28
    5fe2:	07 5e       	subi	r16, 0xE7	; 231
    5fe4:	1e 4f       	sbci	r17, 0xFE	; 254
    5fe6:	d8 01       	movw	r26, r16
    5fe8:	ed 91       	ld	r30, X+
    5fea:	fc 91       	ld	r31, X
    5fec:	80 81       	ld	r24, Z
    5fee:	91 81       	ldd	r25, Z+1	; 0x01
    5ff0:	dc 01       	movw	r26, r24
    5ff2:	ed 91       	ld	r30, X+
    5ff4:	fc 91       	ld	r31, X
    5ff6:	06 a0       	ldd	r0, Z+38	; 0x26
    5ff8:	f7 a1       	ldd	r31, Z+39	; 0x27
    5ffa:	e0 2d       	mov	r30, r0
    5ffc:	09 95       	icall

      if(this->mod->getGpio() == RADIOLIB_NC) {
    5ffe:	d8 01       	movw	r26, r16
    6000:	ed 91       	ld	r30, X+
    6002:	fc 91       	ld	r31, X

    /*!
      \brief Access method to get the pin number of second interrupt/GPIO.
      \returns Pin number of second interrupt/GPIO configured in the constructor.
    */
    uint32_t getGpio() const { return(gpioPin); }
    6004:	40 8d       	ldd	r20, Z+24	; 0x18
    6006:	51 8d       	ldd	r21, Z+25	; 0x19
    6008:	62 8d       	ldd	r22, Z+26	; 0x1a
    600a:	73 8d       	ldd	r23, Z+27	; 0x1b
    600c:	4f 3f       	cpi	r20, 0xFF	; 255
    600e:	bf ef       	ldi	r27, 0xFF	; 255
    6010:	5b 07       	cpc	r21, r27
    6012:	6b 07       	cpc	r22, r27
    6014:	7b 07       	cpc	r23, r27
    6016:	09 f4       	brne	.+2      	; 0x601a <_ZN6SX127x7receiveEPhj+0x27c>
    6018:	b6 cf       	rjmp	.-148    	; 0x5f86 <_ZN6SX127x7receiveEPhj+0x1e8>
          clearIRQFlags();
          return(RADIOLIB_ERR_RX_TIMEOUT);
        }
      } else {
        // GPIO provided, use that
        if(this->mod->hal->digitalRead(this->mod->getGpio())) {
    601a:	80 81       	ld	r24, Z
    601c:	91 81       	ldd	r25, Z+1	; 0x01
    601e:	dc 01       	movw	r26, r24
    6020:	ed 91       	ld	r30, X+
    6022:	fc 91       	ld	r31, X
    6024:	04 80       	ldd	r0, Z+4	; 0x04
    6026:	f5 81       	ldd	r31, Z+5	; 0x05
    6028:	e0 2d       	mov	r30, r0
    602a:	09 95       	icall
    602c:	67 2b       	or	r22, r23
    602e:	68 2b       	or	r22, r24
    6030:	69 2b       	or	r22, r25
    6032:	09 f4       	brne	.+2      	; 0x6036 <_ZN6SX127x7receiveEPhj+0x298>
    6034:	bb cf       	rjmp	.-138    	; 0x5fac <_ZN6SX127x7receiveEPhj+0x20e>
          clearIRQFlags();
    6036:	ce 01       	movw	r24, r28
    6038:	0e 94 61 19 	call	0x32c2	; 0x32c2 <_ZN6SX127x13clearIRQFlagsEv>
          return(RADIOLIB_ERR_RX_TIMEOUT);
    603c:	8a ef       	ldi	r24, 0xFA	; 250
    603e:	9f ef       	ldi	r25, 0xFF	; 255
    6040:	c7 ce       	rjmp	.-626    	; 0x5dd0 <_ZN6SX127x7receiveEPhj+0x32>
      this->mod->hal->yield();

      if(this->mod->getGpio() == RADIOLIB_NC) {
        // no GPIO pin provided, use software timeout
        if(this->mod->hal->micros() - start > timeout) {
          clearIRQFlags();
    6042:	ce 01       	movw	r24, r28
    6044:	0e 94 61 19 	call	0x32c2	; 0x32c2 <_ZN6SX127x13clearIRQFlagsEv>
          return(RADIOLIB_ERR_RX_TIMEOUT);
    6048:	8a ef       	ldi	r24, 0xFA	; 250
    604a:	9f ef       	ldi	r25, 0xFF	; 255
    604c:	c1 ce       	rjmp	.-638    	; 0x5dd0 <_ZN6SX127x7receiveEPhj+0x32>
      }
    }
  }

  // read the received data
  state = readData(data, len);
    604e:	e8 81       	ld	r30, Y
    6050:	f9 81       	ldd	r31, Y+1	; 0x01
    6052:	02 88       	ldd	r0, Z+18	; 0x12
    6054:	f3 89       	ldd	r31, Z+19	; 0x13
    6056:	e0 2d       	mov	r30, r0
    6058:	47 2d       	mov	r20, r7
    605a:	56 2d       	mov	r21, r6
    605c:	b2 01       	movw	r22, r4
    605e:	ce 01       	movw	r24, r28
    6060:	09 95       	icall
    6062:	b6 ce       	rjmp	.-660    	; 0x5dd0 <_ZN6SX127x7receiveEPhj+0x32>

00006064 <_ZN6SX127x9clearFIFOEj>:
    this->mod->SPIwriteRegister(RADIOLIB_SX127X_REG_IRQ_FLAGS_1, 0b11111111);
    this->mod->SPIwriteRegister(RADIOLIB_SX127X_REG_IRQ_FLAGS_2, 0b11111111);
  }
}

void SX127x::clearFIFO(size_t count) {
    6064:	0f 93       	push	r16
    6066:	1f 93       	push	r17
    6068:	cf 93       	push	r28
    606a:	df 93       	push	r29
    606c:	8c 01       	movw	r16, r24
    606e:	eb 01       	movw	r28, r22
  while(count) {
    6070:	20 97       	sbiw	r28, 0x00	; 0
    6072:	59 f0       	breq	.+22     	; 0x608a <_ZN6SX127x9clearFIFOEj+0x26>
    this->mod->SPIreadRegister(RADIOLIB_SX127X_REG_FIFO);
    6074:	70 e0       	ldi	r23, 0x00	; 0
    6076:	60 e0       	ldi	r22, 0x00	; 0
    6078:	f8 01       	movw	r30, r16
    607a:	e7 5e       	subi	r30, 0xE7	; 231
    607c:	fe 4f       	sbci	r31, 0xFE	; 254
    607e:	80 81       	ld	r24, Z
    6080:	91 81       	ldd	r25, Z+1	; 0x01
    6082:	0e 94 82 17 	call	0x2f04	; 0x2f04 <_ZN6Module15SPIreadRegisterEj>
    count--;
    6086:	21 97       	sbiw	r28, 0x01	; 1
    6088:	f3 cf       	rjmp	.-26     	; 0x6070 <_ZN6SX127x9clearFIFOEj+0xc>
  }
}
    608a:	df 91       	pop	r29
    608c:	cf 91       	pop	r28
    608e:	1f 91       	pop	r17
    6090:	0f 91       	pop	r16
    6092:	08 95       	ret

00006094 <_ZN6SX127x10randomByteEv>:

void SX127x::setRfSwitchTable(const uint32_t (&pins)[Module::RFSWITCH_MAX_PINS], const Module::RfSwitchMode_t table[]) {
  this->mod->setRfSwitchTable(pins, table);
}

uint8_t SX127x::randomByte() {
    6094:	df 92       	push	r13
    6096:	ef 92       	push	r14
    6098:	ff 92       	push	r15
    609a:	0f 93       	push	r16
    609c:	1f 93       	push	r17
    609e:	cf 93       	push	r28
    60a0:	df 93       	push	r29
    60a2:	7c 01       	movw	r14, r24
  // check active modem
  uint8_t rssiValueReg = RADIOLIB_SX127X_REG_RSSI_WIDEBAND;
  if(getActiveModem() == RADIOLIB_SX127X_FSK_OOK) {
    60a4:	0e 94 ec 18 	call	0x31d8	; 0x31d8 <_ZN6SX127x14getActiveModemEv>
    60a8:	89 2b       	or	r24, r25
    60aa:	a9 f1       	breq	.+106    	; 0x6116 <_ZN6SX127x10randomByteEv+0x82>
  this->mod->setRfSwitchTable(pins, table);
}

uint8_t SX127x::randomByte() {
  // check active modem
  uint8_t rssiValueReg = RADIOLIB_SX127X_REG_RSSI_WIDEBAND;
    60ac:	0f 2e       	mov	r0, r31
    60ae:	fc e2       	ldi	r31, 0x2C	; 44
    60b0:	df 2e       	mov	r13, r31
    60b2:	f0 2d       	mov	r31, r0
  if(getActiveModem() == RADIOLIB_SX127X_FSK_OOK) {
    rssiValueReg = RADIOLIB_SX127X_REG_RSSI_VALUE_FSK;
  }

  // set mode to Rx
  setMode(RADIOLIB_SX127X_RX);
    60b4:	65 e0       	ldi	r22, 0x05	; 5
    60b6:	c7 01       	movw	r24, r14
    60b8:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN6SX127x7setModeEh>

  // wait a bit for the RSSI reading to stabilise
  this->mod->hal->delay(10);
    60bc:	f7 01       	movw	r30, r14
    60be:	e7 5e       	subi	r30, 0xE7	; 231
    60c0:	fe 4f       	sbci	r31, 0xFE	; 254
    60c2:	01 90       	ld	r0, Z+
    60c4:	f0 81       	ld	r31, Z
    60c6:	e0 2d       	mov	r30, r0
    60c8:	80 81       	ld	r24, Z
    60ca:	91 81       	ldd	r25, Z+1	; 0x01
    60cc:	dc 01       	movw	r26, r24
    60ce:	ed 91       	ld	r30, X+
    60d0:	fc 91       	ld	r31, X
    60d2:	02 84       	ldd	r0, Z+10	; 0x0a
    60d4:	f3 85       	ldd	r31, Z+11	; 0x0b
    60d6:	e0 2d       	mov	r30, r0
    60d8:	4a e0       	ldi	r20, 0x0A	; 10
    60da:	50 e0       	ldi	r21, 0x00	; 0
    60dc:	60 e0       	ldi	r22, 0x00	; 0
    60de:	70 e0       	ldi	r23, 0x00	; 0
    60e0:	09 95       	icall

  // read RSSI value 8 times, always keep just the least significant bit
  uint8_t randByte = 0x00;
  for(uint8_t i = 0; i < 8; i++) {
    60e2:	c0 e0       	ldi	r28, 0x00	; 0

  // wait a bit for the RSSI reading to stabilise
  this->mod->hal->delay(10);

  // read RSSI value 8 times, always keep just the least significant bit
  uint8_t randByte = 0x00;
    60e4:	d0 e0       	ldi	r29, 0x00	; 0
  for(uint8_t i = 0; i < 8; i++) {
    60e6:	c8 30       	cpi	r28, 0x08	; 8
    60e8:	d8 f4       	brcc	.+54     	; 0x6120 <_ZN6SX127x10randomByteEv+0x8c>
    randByte |= ((this->mod->SPIreadRegister(rssiValueReg) & 0x01) << i);
    60ea:	6d 2d       	mov	r22, r13
    60ec:	70 e0       	ldi	r23, 0x00	; 0
    60ee:	f7 01       	movw	r30, r14
    60f0:	e7 5e       	subi	r30, 0xE7	; 231
    60f2:	fe 4f       	sbci	r31, 0xFE	; 254
    60f4:	80 81       	ld	r24, Z
    60f6:	91 81       	ldd	r25, Z+1	; 0x01
    60f8:	0e 94 82 17 	call	0x2f04	; 0x2f04 <_ZN6Module15SPIreadRegisterEj>
    60fc:	08 2f       	mov	r16, r24
    60fe:	01 70       	andi	r16, 0x01	; 1
    6100:	10 e0       	ldi	r17, 0x00	; 0
    6102:	c8 01       	movw	r24, r16
    6104:	0c 2e       	mov	r0, r28
    6106:	02 c0       	rjmp	.+4      	; 0x610c <_ZN6SX127x10randomByteEv+0x78>
    6108:	88 0f       	add	r24, r24
    610a:	99 1f       	adc	r25, r25
    610c:	0a 94       	dec	r0
    610e:	e2 f7       	brpl	.-8      	; 0x6108 <_ZN6SX127x10randomByteEv+0x74>
    6110:	d8 2b       	or	r29, r24
  // wait a bit for the RSSI reading to stabilise
  this->mod->hal->delay(10);

  // read RSSI value 8 times, always keep just the least significant bit
  uint8_t randByte = 0x00;
  for(uint8_t i = 0; i < 8; i++) {
    6112:	cf 5f       	subi	r28, 0xFF	; 255
    6114:	e8 cf       	rjmp	.-48     	; 0x60e6 <_ZN6SX127x10randomByteEv+0x52>

uint8_t SX127x::randomByte() {
  // check active modem
  uint8_t rssiValueReg = RADIOLIB_SX127X_REG_RSSI_WIDEBAND;
  if(getActiveModem() == RADIOLIB_SX127X_FSK_OOK) {
    rssiValueReg = RADIOLIB_SX127X_REG_RSSI_VALUE_FSK;
    6116:	0f 2e       	mov	r0, r31
    6118:	f1 e1       	ldi	r31, 0x11	; 17
    611a:	df 2e       	mov	r13, r31
    611c:	f0 2d       	mov	r31, r0
    611e:	ca cf       	rjmp	.-108    	; 0x60b4 <_ZN6SX127x10randomByteEv+0x20>
  for(uint8_t i = 0; i < 8; i++) {
    randByte |= ((this->mod->SPIreadRegister(rssiValueReg) & 0x01) << i);
  }

  // set mode to standby
  setMode(RADIOLIB_SX127X_STANDBY);
    6120:	61 e0       	ldi	r22, 0x01	; 1
    6122:	c7 01       	movw	r24, r14
    6124:	0e 94 ac 19 	call	0x3358	; 0x3358 <_ZN6SX127x7setModeEh>

  return(randByte);
}
    6128:	8d 2f       	mov	r24, r29
    612a:	df 91       	pop	r29
    612c:	cf 91       	pop	r28
    612e:	1f 91       	pop	r17
    6130:	0f 91       	pop	r16
    6132:	ff 90       	pop	r15
    6134:	ef 90       	pop	r14
    6136:	df 90       	pop	r13
    6138:	08 95       	ret

0000613a <_ZN6SX127x11getIRQFlagsEv>:
    default:
      return(RADIOLIB_ERR_INVALID_ENCODING);
  }
}

uint16_t SX127x::getIRQFlags() {
    613a:	0f 93       	push	r16
    613c:	1f 93       	push	r17
    613e:	cf 93       	push	r28
    6140:	df 93       	push	r29
    6142:	8c 01       	movw	r16, r24
  // check active modem
  if(getActiveModem() == RADIOLIB_SX127X_LORA) {
    6144:	0e 94 ec 18 	call	0x31d8	; 0x31d8 <_ZN6SX127x14getActiveModemEv>
    6148:	80 38       	cpi	r24, 0x80	; 128
    614a:	91 05       	cpc	r25, r1
    614c:	e1 f0       	breq	.+56     	; 0x6186 <_ZN6SX127x11getIRQFlagsEv+0x4c>
    // LoRa, just 8-bit value
    return((uint16_t)this->mod->SPIreadRegister(RADIOLIB_SX127X_REG_IRQ_FLAGS));

  } else {
    // FSK, the IRQ flags are 16 bits in total
    uint16_t flags = ((uint16_t)this->mod->SPIreadRegister(RADIOLIB_SX127X_REG_IRQ_FLAGS_2)) << 8;
    614e:	07 5e       	subi	r16, 0xE7	; 231
    6150:	1e 4f       	sbci	r17, 0xFE	; 254
    6152:	6f e3       	ldi	r22, 0x3F	; 63
    6154:	70 e0       	ldi	r23, 0x00	; 0
    6156:	f8 01       	movw	r30, r16
    6158:	80 81       	ld	r24, Z
    615a:	91 81       	ldd	r25, Z+1	; 0x01
    615c:	0e 94 82 17 	call	0x2f04	; 0x2f04 <_ZN6Module15SPIreadRegisterEj>
    6160:	c8 2f       	mov	r28, r24
    6162:	d0 e0       	ldi	r29, 0x00	; 0
    6164:	dc 2f       	mov	r29, r28
    6166:	cc 27       	eor	r28, r28
    flags |= (uint16_t)this->mod->SPIreadRegister(RADIOLIB_SX127X_REG_IRQ_FLAGS_1);
    6168:	6e e3       	ldi	r22, 0x3E	; 62
    616a:	70 e0       	ldi	r23, 0x00	; 0
    616c:	f8 01       	movw	r30, r16
    616e:	80 81       	ld	r24, Z
    6170:	91 81       	ldd	r25, Z+1	; 0x01
    6172:	0e 94 82 17 	call	0x2f04	; 0x2f04 <_ZN6Module15SPIreadRegisterEj>
    6176:	9e 01       	movw	r18, r28
    6178:	28 2b       	or	r18, r24
    617a:	c9 01       	movw	r24, r18
    return(flags);
  }

}
    617c:	df 91       	pop	r29
    617e:	cf 91       	pop	r28
    6180:	1f 91       	pop	r17
    6182:	0f 91       	pop	r16
    6184:	08 95       	ret

uint16_t SX127x::getIRQFlags() {
  // check active modem
  if(getActiveModem() == RADIOLIB_SX127X_LORA) {
    // LoRa, just 8-bit value
    return((uint16_t)this->mod->SPIreadRegister(RADIOLIB_SX127X_REG_IRQ_FLAGS));
    6186:	e8 01       	movw	r28, r16
    6188:	c7 5e       	subi	r28, 0xE7	; 231
    618a:	de 4f       	sbci	r29, 0xFE	; 254
    618c:	62 e1       	ldi	r22, 0x12	; 18
    618e:	70 e0       	ldi	r23, 0x00	; 0
    6190:	88 81       	ld	r24, Y
    6192:	99 81       	ldd	r25, Y+1	; 0x01
    6194:	0e 94 82 17 	call	0x2f04	; 0x2f04 <_ZN6Module15SPIreadRegisterEj>
    6198:	90 e0       	ldi	r25, 0x00	; 0
    619a:	f0 cf       	rjmp	.-32     	; 0x617c <_ZN6SX127x11getIRQFlagsEv+0x42>

0000619c <_ZN6SX127x20getChannelScanResultEv>:
  state = setMode(RADIOLIB_SX127X_CAD);
  return(state);
}

int16_t SX127x::getChannelScanResult() {
  if((this->getIRQFlags() & RADIOLIB_SX127X_CLEAR_IRQ_FLAG_CAD_DETECTED) == RADIOLIB_SX127X_CLEAR_IRQ_FLAG_CAD_DETECTED) {
    619c:	0e 94 9d 30 	call	0x613a	; 0x613a <_ZN6SX127x11getIRQFlagsEv>
    61a0:	80 fd       	sbrc	r24, 0
    61a2:	03 c0       	rjmp	.+6      	; 0x61aa <_ZN6SX127x20getChannelScanResultEv+0xe>
    return(RADIOLIB_PREAMBLE_DETECTED);
  }
  return(RADIOLIB_CHANNEL_FREE);
    61a4:	81 ef       	ldi	r24, 0xF1	; 241
    61a6:	9f ef       	ldi	r25, 0xFF	; 255
}
    61a8:	08 95       	ret
  return(state);
}

int16_t SX127x::getChannelScanResult() {
  if((this->getIRQFlags() & RADIOLIB_SX127X_CLEAR_IRQ_FLAG_CAD_DETECTED) == RADIOLIB_SX127X_CLEAR_IRQ_FLAG_CAD_DETECTED) {
    return(RADIOLIB_PREAMBLE_DETECTED);
    61aa:	82 ef       	ldi	r24, 0xF2	; 242
    61ac:	9f ef       	ldi	r25, 0xFF	; 255
    61ae:	08 95       	ret

000061b0 <_ZN6SX127x15getPacketLengthEb>:
  state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_FRF_MID, (FRF & 0x00FF00) >> 8);
  state |= this->mod->SPIsetRegValue(RADIOLIB_SX127X_REG_FRF_LSB, FRF & 0x0000FF);
  return(state);
}

size_t SX127x::getPacketLength(bool update) {
    61b0:	1f 93       	push	r17
    61b2:	cf 93       	push	r28
    61b4:	df 93       	push	r29
    61b6:	ec 01       	movw	r28, r24
    61b8:	16 2f       	mov	r17, r22
  int16_t modem = getActiveModem();
    61ba:	0e 94 ec 18 	call	0x31d8	; 0x31d8 <_ZN6SX127x14getActiveModemEv>

  if(modem == RADIOLIB_SX127X_LORA) {
    61be:	80 38       	cpi	r24, 0x80	; 128
    61c0:	91 05       	cpc	r25, r1
    61c2:	51 f1       	breq	.+84     	; 0x6218 <_ZN6SX127x15getPacketLengthEb+0x68>
    } else {
      // return the cached value for SF6
      return(this->packetLength);
    }

  } else if(modem == RADIOLIB_SX127X_FSK_OOK) {
    61c4:	89 2b       	or	r24, r25
    61c6:	01 f5       	brne	.+64     	; 0x6208 <_ZN6SX127x15getPacketLengthEb+0x58>
    // get packet length
    if(!this->packetLengthQueried && update) {
    61c8:	fe 01       	movw	r30, r28
    61ca:	ee 5c       	subi	r30, 0xCE	; 206
    61cc:	fe 4f       	sbci	r31, 0xFE	; 254
    61ce:	80 81       	ld	r24, Z
    61d0:	81 11       	cpse	r24, r1
    61d2:	1a c0       	rjmp	.+52     	; 0x6208 <_ZN6SX127x15getPacketLengthEb+0x58>
    61d4:	11 23       	and	r17, r17
    61d6:	c1 f0       	breq	.+48     	; 0x6208 <_ZN6SX127x15getPacketLengthEb+0x58>
      if (this->packetLengthConfig == RADIOLIB_SX127X_PACKET_VARIABLE) {
    61d8:	31 96       	adiw	r30, 0x01	; 1
    61da:	80 81       	ld	r24, Z
    61dc:	80 38       	cpi	r24, 0x80	; 128
    61de:	89 f1       	breq	.+98     	; 0x6242 <_ZN6SX127x15getPacketLengthEb+0x92>
        this->packetLength = this->mod->SPIreadRegister(RADIOLIB_SX127X_REG_FIFO);
      } else {
        this->packetLength = this->mod->SPIreadRegister(RADIOLIB_SX127X_REG_PAYLOAD_LENGTH_FSK);
    61e0:	62 e3       	ldi	r22, 0x32	; 50
    61e2:	70 e0       	ldi	r23, 0x00	; 0
    61e4:	fe 01       	movw	r30, r28
    61e6:	e7 5e       	subi	r30, 0xE7	; 231
    61e8:	fe 4f       	sbci	r31, 0xFE	; 254
    61ea:	80 81       	ld	r24, Z
    61ec:	91 81       	ldd	r25, Z+1	; 0x01
    61ee:	0e 94 82 17 	call	0x2f04	; 0x2f04 <_ZN6Module15SPIreadRegisterEj>
    61f2:	90 e0       	ldi	r25, 0x00	; 0
    61f4:	fe 01       	movw	r30, r28
    61f6:	e4 5d       	subi	r30, 0xD4	; 212
    61f8:	fe 4f       	sbci	r31, 0xFE	; 254
    61fa:	91 83       	std	Z+1, r25	; 0x01
    61fc:	80 83       	st	Z, r24
      }
      this->packetLengthQueried = true;
    61fe:	81 e0       	ldi	r24, 0x01	; 1
    6200:	fe 01       	movw	r30, r28
    6202:	ee 5c       	subi	r30, 0xCE	; 206
    6204:	fe 4f       	sbci	r31, 0xFE	; 254
    6206:	80 83       	st	Z, r24
    }
  }

  return(this->packetLength);
    6208:	c4 5d       	subi	r28, 0xD4	; 212
    620a:	de 4f       	sbci	r29, 0xFE	; 254
    620c:	88 81       	ld	r24, Y
    620e:	99 81       	ldd	r25, Y+1	; 0x01
}
    6210:	df 91       	pop	r29
    6212:	cf 91       	pop	r28
    6214:	1f 91       	pop	r17
    6216:	08 95       	ret

size_t SX127x::getPacketLength(bool update) {
  int16_t modem = getActiveModem();

  if(modem == RADIOLIB_SX127X_LORA) {
    if(this->spreadingFactor != 6) {
    6218:	fe 01       	movw	r30, r28
    621a:	ed 5d       	subi	r30, 0xDD	; 221
    621c:	fe 4f       	sbci	r31, 0xFE	; 254
    621e:	80 81       	ld	r24, Z
    6220:	86 30       	cpi	r24, 0x06	; 6
    6222:	29 f4       	brne	.+10     	; 0x622e <_ZN6SX127x15getPacketLengthEb+0x7e>
      // get packet length for SF7 - SF12
      return(this->mod->SPIreadRegister(RADIOLIB_SX127X_REG_RX_NB_BYTES));

    } else {
      // return the cached value for SF6
      return(this->packetLength);
    6224:	c4 5d       	subi	r28, 0xD4	; 212
    6226:	de 4f       	sbci	r29, 0xFE	; 254
    6228:	88 81       	ld	r24, Y
    622a:	99 81       	ldd	r25, Y+1	; 0x01
    622c:	f1 cf       	rjmp	.-30     	; 0x6210 <_ZN6SX127x15getPacketLengthEb+0x60>
  int16_t modem = getActiveModem();

  if(modem == RADIOLIB_SX127X_LORA) {
    if(this->spreadingFactor != 6) {
      // get packet length for SF7 - SF12
      return(this->mod->SPIreadRegister(RADIOLIB_SX127X_REG_RX_NB_BYTES));
    622e:	c7 5e       	subi	r28, 0xE7	; 231
    6230:	de 4f       	sbci	r29, 0xFE	; 254
    6232:	63 e1       	ldi	r22, 0x13	; 19
    6234:	70 e0       	ldi	r23, 0x00	; 0
    6236:	88 81       	ld	r24, Y
    6238:	99 81       	ldd	r25, Y+1	; 0x01
    623a:	0e 94 82 17 	call	0x2f04	; 0x2f04 <_ZN6Module15SPIreadRegisterEj>
    623e:	90 e0       	ldi	r25, 0x00	; 0
    6240:	e7 cf       	rjmp	.-50     	; 0x6210 <_ZN6SX127x15getPacketLengthEb+0x60>

  } else if(modem == RADIOLIB_SX127X_FSK_OOK) {
    // get packet length
    if(!this->packetLengthQueried && update) {
      if (this->packetLengthConfig == RADIOLIB_SX127X_PACKET_VARIABLE) {
        this->packetLength = this->mod->SPIreadRegister(RADIOLIB_SX127X_REG_FIFO);
    6242:	70 e0       	ldi	r23, 0x00	; 0
    6244:	60 e0       	ldi	r22, 0x00	; 0
    6246:	7a 97       	sbiw	r30, 0x1a	; 26
    6248:	80 81       	ld	r24, Z
    624a:	91 81       	ldd	r25, Z+1	; 0x01
    624c:	0e 94 82 17 	call	0x2f04	; 0x2f04 <_ZN6Module15SPIreadRegisterEj>
    6250:	90 e0       	ldi	r25, 0x00	; 0
    6252:	fe 01       	movw	r30, r28
    6254:	e4 5d       	subi	r30, 0xD4	; 212
    6256:	fe 4f       	sbci	r31, 0xFE	; 254
    6258:	91 83       	std	Z+1, r25	; 0x01
    625a:	80 83       	st	Z, r24
    625c:	d0 cf       	rjmp	.-96     	; 0x61fe <_ZN6SX127x15getPacketLengthEb+0x4e>

0000625e <_ZN3gel5Radio9availableEv>:
        standby();
};

size_t Radio::available()
{
    if (!(currentState == Receiving) || !(dataReceived == true))
    625e:	fc 01       	movw	r30, r24
    6260:	e4 59       	subi	r30, 0x94	; 148
    6262:	fe 4f       	sbci	r31, 0xFE	; 254
    6264:	20 81       	ld	r18, Z
    6266:	31 81       	ldd	r19, Z+1	; 0x01
    6268:	22 30       	cpi	r18, 0x02	; 2
    626a:	31 05       	cpc	r19, r1
    626c:	19 f0       	breq	.+6      	; 0x6274 <_ZN3gel5Radio9availableEv+0x16>
        return 0;
    626e:	90 e0       	ldi	r25, 0x00	; 0
    6270:	80 e0       	ldi	r24, 0x00	; 0
    6272:	08 95       	ret
        standby();
};

size_t Radio::available()
{
    if (!(currentState == Receiving) || !(dataReceived == true))
    6274:	31 97       	sbiw	r30, 0x01	; 1
    6276:	20 81       	ld	r18, Z
    6278:	21 11       	cpse	r18, r1
    627a:	03 c0       	rjmp	.+6      	; 0x6282 <_ZN3gel5Radio9availableEv+0x24>
        return 0;
    627c:	90 e0       	ldi	r25, 0x00	; 0
    627e:	80 e0       	ldi	r24, 0x00	; 0

    return radio.getPacketLength();
}
    6280:	08 95       	ret
size_t Radio::available()
{
    if (!(currentState == Receiving) || !(dataReceived == true))
        return 0;

    return radio.getPacketLength();
    6282:	61 e0       	ldi	r22, 0x01	; 1
    6284:	c4 96       	adiw	r24, 0x34	; 52
    6286:	0e 94 d8 30 	call	0x61b0	; 0x61b0 <_ZN6SX127x15getPacketLengthEb>
    628a:	08 95       	ret

0000628c <_ZN3gel4Link18update_telecommandEv>:

Error Link::update_telecommand()
{
    628c:	cf 92       	push	r12
    628e:	df 92       	push	r13
    6290:	ef 92       	push	r14
    6292:	ff 92       	push	r15
    6294:	0f 93       	push	r16
    6296:	1f 93       	push	r17
    6298:	cf 93       	push	r28
    629a:	df 93       	push	r29
    629c:	cd b7       	in	r28, 0x3d	; 61
    629e:	de b7       	in	r29, 0x3e	; 62
    62a0:	6c 97       	sbiw	r28, 0x1c	; 28
    62a2:	0f b6       	in	r0, 0x3f	; 63
    62a4:	f8 94       	cli
    62a6:	de bf       	out	0x3e, r29	; 62
    62a8:	0f be       	out	0x3f, r0	; 63
    62aa:	cd bf       	out	0x3d, r28	; 61
    62ac:	7c 01       	movw	r14, r24
    62ae:	8b 01       	movw	r16, r22
    Radio::State radioState = radio->getState();
    62b0:	db 01       	movw	r26, r22
    62b2:	11 96       	adiw	r26, 0x01	; 1
    62b4:	8d 91       	ld	r24, X+
    62b6:	9c 91       	ld	r25, X
    62b8:	fc 01       	movw	r30, r24
    62ba:	e4 59       	subi	r30, 0x94	; 148
    62bc:	fe 4f       	sbci	r31, 0xFE	; 254
    62be:	c0 80       	ld	r12, Z
    62c0:	d1 80       	ldd	r13, Z+1	; 0x01

    // First, we deal with any data we may have received and forward it
    // to the Telecommand callback to be transmitted
    if (radio->available() > 0)
    62c2:	0e 94 2f 31 	call	0x625e	; 0x625e <_ZN3gel5Radio9availableEv>
    62c6:	89 2b       	or	r24, r25
    62c8:	f1 f4       	brne	.+60     	; 0x6306 <_ZN3gel4Link18update_telecommandEv+0x7a>
        strcpy((char*)receivePayload.data(), msgString);
        telecommandCallback(receivePayload, sendPayload);
        return radio->startTransmit(sendPayload);
    }

    if (radioState != Radio::Receiving)
    62ca:	e2 e0       	ldi	r30, 0x02	; 2
    62cc:	ce 16       	cp	r12, r30
    62ce:	d1 04       	cpc	r13, r1
    62d0:	09 f0       	breq	.+2      	; 0x62d4 <_ZN3gel4Link18update_telecommandEv+0x48>
    62d2:	7b c0       	rjmp	.+246    	; 0x63ca <_ZN3gel4Link18update_telecommandEv+0x13e>
    62d4:	8c e8       	ldi	r24, 0x8C	; 140
    62d6:	92 e0       	ldi	r25, 0x02	; 2
    62d8:	f7 01       	movw	r30, r14
    62da:	91 83       	std	Z+1, r25	; 0x01
    62dc:	80 83       	st	Z, r24
    62de:	13 82       	std	Z+3, r1	; 0x03
    62e0:	12 82       	std	Z+2, r1	; 0x02
    62e2:	15 82       	std	Z+5, r1	; 0x05
    62e4:	14 82       	std	Z+4, r1	; 0x04
        return radio->startReceive();

    return Error::None;
}
    62e6:	c7 01       	movw	r24, r14
    62e8:	6c 96       	adiw	r28, 0x1c	; 28
    62ea:	0f b6       	in	r0, 0x3f	; 63
    62ec:	f8 94       	cli
    62ee:	de bf       	out	0x3e, r29	; 62
    62f0:	0f be       	out	0x3f, r0	; 63
    62f2:	cd bf       	out	0x3d, r28	; 61
    62f4:	df 91       	pop	r29
    62f6:	cf 91       	pop	r28
    62f8:	1f 91       	pop	r17
    62fa:	0f 91       	pop	r16
    62fc:	ff 90       	pop	r15
    62fe:	ef 90       	pop	r14
    6300:	df 90       	pop	r13
    6302:	cf 90       	pop	r12
    6304:	08 95       	ret

    // First, we deal with any data we may have received and forward it
    // to the Telecommand callback to be transmitted
    if (radio->available() > 0)
    {
        auto msg = radio->readData();
    6306:	f8 01       	movw	r30, r16
    6308:	61 81       	ldd	r22, Z+1	; 0x01
    630a:	72 81       	ldd	r23, Z+2	; 0x02
    630c:	ce 01       	movw	r24, r28
    630e:	43 96       	adiw	r24, 0x13	; 19
    6310:	0e 94 7c 12 	call	0x24f8	; 0x24f8 <_ZN3gel5Radio8readDataEv>
    //*******************************************
    /// Get the value.
    //*******************************************
    ETL_CONSTEXPR14 value_type& value()&
    {
      return etl::get<Value_Type>(storage);
    6314:	ce 01       	movw	r24, r28
    6316:	43 96       	adiw	r24, 0x13	; 19
    6318:	0e 94 e5 07 	call	0xfca	; 0xfca <_ZN3etl3getILj1EJNS_9monostateE6StringN3gel5ErrorEEEERNS_19variant_alternativeIXT_ENS_7variantIJDpT0_EEEE4typeERS9_>
    631c:	dc 01       	movw	r26, r24
    631e:	6d 91       	ld	r22, X+
    6320:	7c 91       	ld	r23, X
        const char* msgString = msg.value().c_str();
        strcpy((char*)receivePayload.data(), msgString);
    6322:	f8 01       	movw	r30, r16
    6324:	86 8d       	ldd	r24, Z+30	; 0x1e
    6326:	97 8d       	ldd	r25, Z+31	; 0x1f
    6328:	0e 94 cd 3e 	call	0x7d9a	; 0x7d9a <strcpy>
        telecommandCallback(receivePayload, sendPayload);
    632c:	d8 01       	movw	r26, r16
    632e:	1e 96       	adiw	r26, 0x0e	; 14
    6330:	ed 91       	ld	r30, X+
    6332:	fc 91       	ld	r31, X
    /// Returns a pointer to the beginning of the vector data.
    ///\return A pointer to the beginning of the vector data.
    //*********************************************************************
    pointer data()
    {
      return p_buffer;
    6334:	68 01       	movw	r12, r16
    6336:	bf ed       	ldi	r27, 0xDF	; 223
    6338:	cb 1a       	sub	r12, r27
    633a:	be ef       	ldi	r27, 0xFE	; 254
    633c:	db 0a       	sbc	r13, r27
    633e:	d6 01       	movw	r26, r12
    6340:	13 96       	adiw	r26, 0x03	; 3
    6342:	2d 91       	ld	r18, X+
    6344:	3c 91       	ld	r19, X
    6346:	14 97       	sbiw	r26, 0x04	; 4
    /// Gets the current size of the vector.
    ///\return The current size of the vector.
    //*************************************************************************
    size_type size() const
    {
      return size_t(p_end - p_buffer);
    6348:	15 96       	adiw	r26, 0x05	; 5
    634a:	8d 91       	ld	r24, X+
    634c:	9c 91       	ld	r25, X
    634e:	3a 87       	std	Y+10, r19	; 0x0a
    6350:	29 87       	std	Y+9, r18	; 0x09
    6352:	9c 87       	std	Y+12, r25	; 0x0c
    6354:	8b 87       	std	Y+11, r24	; 0x0b
    /// Returns a pointer to the beginning of the vector data.
    ///\return A pointer to the beginning of the vector data.
    //*********************************************************************
    pointer data()
    {
      return p_buffer;
    6356:	d8 01       	movw	r26, r16
    6358:	5e 96       	adiw	r26, 0x1e	; 30
    635a:	2d 91       	ld	r18, X+
    635c:	3c 91       	ld	r19, X
    635e:	5f 97       	sbiw	r26, 0x1f	; 31
    /// Gets the current size of the vector.
    ///\return The current size of the vector.
    //*************************************************************************
    size_type size() const
    {
      return size_t(p_end - p_buffer);
    6360:	90 96       	adiw	r26, 0x20	; 32
    6362:	8d 91       	ld	r24, X+
    6364:	9c 91       	ld	r25, X
    6366:	3e 83       	std	Y+6, r19	; 0x06
    6368:	2d 83       	std	Y+5, r18	; 0x05
    636a:	98 87       	std	Y+8, r25	; 0x08
    636c:	8f 83       	std	Y+7, r24	; 0x07
    636e:	ae 01       	movw	r20, r28
    6370:	47 5f       	subi	r20, 0xF7	; 247
    6372:	5f 4f       	sbci	r21, 0xFF	; 255
    6374:	be 01       	movw	r22, r28
    6376:	6b 5f       	subi	r22, 0xFB	; 251
    6378:	7f 4f       	sbci	r23, 0xFF	; 255
    637a:	ce 01       	movw	r24, r28
    637c:	0d 96       	adiw	r24, 0x0d	; 13
    637e:	09 95       	icall
        return radio->startTransmit(sendPayload);
    6380:	f8 01       	movw	r30, r16
    6382:	61 81       	ldd	r22, Z+1	; 0x01
    6384:	72 81       	ldd	r23, Z+2	; 0x02
    /// Returns a pointer to the beginning of the vector data.
    ///\return A pointer to the beginning of the vector data.
    //*********************************************************************
    pointer data()
    {
      return p_buffer;
    6386:	d6 01       	movw	r26, r12
    6388:	13 96       	adiw	r26, 0x03	; 3
    638a:	2d 91       	ld	r18, X+
    638c:	3c 91       	ld	r19, X
    638e:	14 97       	sbiw	r26, 0x04	; 4
    /// Gets the current size of the vector.
    ///\return The current size of the vector.
    //*************************************************************************
    size_type size() const
    {
      return size_t(p_end - p_buffer);
    6390:	15 96       	adiw	r26, 0x05	; 5
    6392:	8d 91       	ld	r24, X+
    6394:	9c 91       	ld	r25, X
    6396:	3a 83       	std	Y+2, r19	; 0x02
    6398:	29 83       	std	Y+1, r18	; 0x01
    639a:	9c 83       	std	Y+4, r25	; 0x04
    639c:	8b 83       	std	Y+3, r24	; 0x03
    639e:	ae 01       	movw	r20, r28
    63a0:	4f 5f       	subi	r20, 0xFF	; 255
    63a2:	5f 4f       	sbci	r21, 0xFF	; 255
    63a4:	c7 01       	movw	r24, r14
    63a6:	0e 94 2a 2d 	call	0x5a54	; 0x5a54 <_ZN3gel5Radio13startTransmitEN3etl4spanIhLj65535EEE>
    //***************************************************************************
    /// Gets the index of the type currently stored or variant_npos
    //***************************************************************************
    constexpr size_t index() const noexcept
    {
      return type_id;
    63aa:	8b 8d       	ldd	r24, Y+27	; 0x1b
    63ac:	9c 8d       	ldd	r25, Y+28	; 0x1c
    //***************************************************************************
    /// Destructor.
    //***************************************************************************
    ~variant()
    {
      if (index() != variant_npos)
    63ae:	01 96       	adiw	r24, 0x01	; 1
    63b0:	09 f4       	brne	.+2      	; 0x63b4 <_ZN3gel4Link18update_telecommandEv+0x128>
    63b2:	99 cf       	rjmp	.-206    	; 0x62e6 <_ZN3gel4Link18update_telecommandEv+0x5a>
      {
        operation(private_variant::Destroy, data, nullptr);
    63b4:	e9 8d       	ldd	r30, Y+25	; 0x19
    63b6:	fa 8d       	ldd	r31, Y+26	; 0x1a
    63b8:	50 e0       	ldi	r21, 0x00	; 0
    63ba:	40 e0       	ldi	r20, 0x00	; 0
    63bc:	be 01       	movw	r22, r28
    63be:	6d 5e       	subi	r22, 0xED	; 237
    63c0:	7f 4f       	sbci	r23, 0xFF	; 255
    63c2:	82 e0       	ldi	r24, 0x02	; 2
    63c4:	90 e0       	ldi	r25, 0x00	; 0
    63c6:	09 95       	icall
    63c8:	8e cf       	rjmp	.-228    	; 0x62e6 <_ZN3gel4Link18update_telecommandEv+0x5a>
    }

    if (radioState != Radio::Receiving)
        return radio->startReceive();
    63ca:	d8 01       	movw	r26, r16
    63cc:	11 96       	adiw	r26, 0x01	; 1
    63ce:	6d 91       	ld	r22, X+
    63d0:	7c 91       	ld	r23, X
    63d2:	c7 01       	movw	r24, r14
    63d4:	0e 94 a5 2e 	call	0x5d4a	; 0x5d4a <_ZN3gel5Radio12startReceiveEv>
    63d8:	86 cf       	rjmp	.-244    	; 0x62e6 <_ZN3gel4Link18update_telecommandEv+0x5a>

000063da <_ZN3gel4Link6updateEv>:

    return Error::None;
}

Error Link::update()
{
    63da:	8f 92       	push	r8
    63dc:	9f 92       	push	r9
    63de:	af 92       	push	r10
    63e0:	bf 92       	push	r11
    63e2:	cf 92       	push	r12
    63e4:	df 92       	push	r13
    63e6:	ef 92       	push	r14
    63e8:	ff 92       	push	r15
    63ea:	0f 93       	push	r16
    63ec:	1f 93       	push	r17
    63ee:	cf 93       	push	r28
    63f0:	df 93       	push	r29
    63f2:	8c 01       	movw	r16, r24
    63f4:	eb 01       	movw	r28, r22
    // Decide if "listening" must be toggled. Could also be implemented with interrupts -
    // we choose to use times with an "update" function instead to give the user the choice.
    uint32_t currentTime = millis();
    63f6:	0e 94 12 02 	call	0x424	; 0x424 <millis>
    if ((currentTime - prevListenTime) > config.listenWindow)
    63fa:	ce 88       	ldd	r12, Y+22	; 0x16
    63fc:	df 88       	ldd	r13, Y+23	; 0x17
    63fe:	e8 8c       	ldd	r14, Y+24	; 0x18
    6400:	f9 8c       	ldd	r15, Y+25	; 0x19
    6402:	4b 01       	movw	r8, r22
    6404:	5c 01       	movw	r10, r24
    6406:	8c 18       	sub	r8, r12
    6408:	9d 08       	sbc	r9, r13
    640a:	ae 08       	sbc	r10, r14
    640c:	bf 08       	sbc	r11, r15
    640e:	c8 84       	ldd	r12, Y+8	; 0x08
    6410:	d9 84       	ldd	r13, Y+9	; 0x09
    6412:	ea 84       	ldd	r14, Y+10	; 0x0a
    6414:	fb 84       	ldd	r15, Y+11	; 0x0b
    6416:	c8 14       	cp	r12, r8
    6418:	d9 04       	cpc	r13, r9
    641a:	ea 04       	cpc	r14, r10
    641c:	fb 04       	cpc	r15, r11
    641e:	58 f4       	brcc	.+22     	; 0x6436 <_ZN3gel4Link6updateEv+0x5c>
    {
        if (listening)
    6420:	2a 8d       	ldd	r18, Y+26	; 0x1a
    6422:	22 23       	and	r18, r18
    6424:	c9 f0       	breq	.+50     	; 0x6458 <_ZN3gel4Link6updateEv+0x7e>
    void setTelemetryCallback(TelemetryCallback callback) { this->telemetryCallback = callback; };

    void setState(State newState) { this->state = newState; }
    6426:	81 e0       	ldi	r24, 0x01	; 1
    6428:	90 e0       	ldi	r25, 0x00	; 0
    642a:	9d 87       	std	Y+13, r25	; 0x0d
    642c:	8c 87       	std	Y+12, r24	; 0x0c
        {
            setState(Telecommand);
            prevListenTime = currentTime;
        }

        listening = !listening;
    642e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    6430:	91 e0       	ldi	r25, 0x01	; 1
    6432:	89 27       	eor	r24, r25
    6434:	8a 8f       	std	Y+26, r24	; 0x1a
    }
    
    // Update for the relevant sub-state
    switch (state)
    6436:	8c 85       	ldd	r24, Y+12	; 0x0c
    6438:	9d 85       	ldd	r25, Y+13	; 0x0d
    643a:	81 30       	cpi	r24, 0x01	; 1
    643c:	91 05       	cpc	r25, r1
    643e:	a9 f0       	breq	.+42     	; 0x646a <_ZN3gel4Link6updateEv+0x90>
    6440:	02 97       	sbiw	r24, 0x02	; 2
    6442:	29 f1       	breq	.+74     	; 0x648e <_ZN3gel4Link6updateEv+0xb4>
    6444:	8c e8       	ldi	r24, 0x8C	; 140
    6446:	92 e0       	ldi	r25, 0x02	; 2
    6448:	f8 01       	movw	r30, r16
    644a:	91 83       	std	Z+1, r25	; 0x01
    644c:	80 83       	st	Z, r24
    644e:	13 82       	std	Z+3, r1	; 0x03
    6450:	12 82       	std	Z+2, r1	; 0x02
    6452:	15 82       	std	Z+5, r1	; 0x05
    6454:	14 82       	std	Z+4, r1	; 0x04
    6456:	0d c0       	rjmp	.+26     	; 0x6472 <_ZN3gel4Link6updateEv+0x98>
    6458:	22 e0       	ldi	r18, 0x02	; 2
    645a:	30 e0       	ldi	r19, 0x00	; 0
    645c:	3d 87       	std	Y+13, r19	; 0x0d
    645e:	2c 87       	std	Y+12, r18	; 0x0c
            setState(Telemetry);
        }
        else
        {
            setState(Telecommand);
            prevListenTime = currentTime;
    6460:	6e 8b       	std	Y+22, r22	; 0x16
    6462:	7f 8b       	std	Y+23, r23	; 0x17
    6464:	88 8f       	std	Y+24, r24	; 0x18
    6466:	99 8f       	std	Y+25, r25	; 0x19
    6468:	e2 cf       	rjmp	.-60     	; 0x642e <_ZN3gel4Link6updateEv+0x54>
    
    // Update for the relevant sub-state
    switch (state)
    {
        case Telemetry:
            return update_telemetry();
    646a:	be 01       	movw	r22, r28
    646c:	c8 01       	movw	r24, r16
    646e:	0e 94 5d 2d 	call	0x5aba	; 0x5aba <_ZN3gel4Link16update_telemetryEv>
        case Idle:
            break;
    }
    
    return Error::None;   
}
    6472:	c8 01       	movw	r24, r16
    6474:	df 91       	pop	r29
    6476:	cf 91       	pop	r28
    6478:	1f 91       	pop	r17
    647a:	0f 91       	pop	r16
    647c:	ff 90       	pop	r15
    647e:	ef 90       	pop	r14
    6480:	df 90       	pop	r13
    6482:	cf 90       	pop	r12
    6484:	bf 90       	pop	r11
    6486:	af 90       	pop	r10
    6488:	9f 90       	pop	r9
    648a:	8f 90       	pop	r8
    648c:	08 95       	ret
    {
        case Telemetry:
            return update_telemetry();
            
        case Telecommand:
            return update_telecommand();   
    648e:	be 01       	movw	r22, r28
    6490:	c8 01       	movw	r24, r16
    6492:	0e 94 46 31 	call	0x628c	; 0x628c <_ZN3gel4Link18update_telecommandEv>
    6496:	ed cf       	rjmp	.-38     	; 0x6472 <_ZN3gel4Link6updateEv+0x98>

00006498 <loop>:
    // else
        // Serial.println("GPS initialized.");
}

void loop()
{
    6498:	cf 93       	push	r28
    649a:	df 93       	push	r29
    649c:	00 d0       	rcall	.+0      	; 0x649e <loop+0x6>
    649e:	00 d0       	rcall	.+0      	; 0x64a0 <loop+0x8>
    64a0:	00 d0       	rcall	.+0      	; 0x64a2 <loop+0xa>
    64a2:	cd b7       	in	r28, 0x3d	; 61
    64a4:	de b7       	in	r29, 0x3e	; 62
    // gps.update();
    link.update();
    64a6:	62 e4       	ldi	r22, 0x42	; 66
    64a8:	73 e0       	ldi	r23, 0x03	; 3
    64aa:	ce 01       	movw	r24, r28
    64ac:	01 96       	adiw	r24, 0x01	; 1
    64ae:	0e 94 ed 31 	call	0x63da	; 0x63da <_ZN3gel4Link6updateEv>
    64b2:	26 96       	adiw	r28, 0x06	; 6
    64b4:	0f b6       	in	r0, 0x3f	; 63
    64b6:	f8 94       	cli
    64b8:	de bf       	out	0x3e, r29	; 62
    64ba:	0f be       	out	0x3f, r0	; 63
    64bc:	cd bf       	out	0x3d, r28	; 61
    64be:	df 91       	pop	r29
    64c0:	cf 91       	pop	r28
    64c2:	08 95       	ret

000064c4 <_ZN6SX12789errataFixEb>:
  // set fast PLL hop
  state = this->mod->SPIsetRegValue(RADIOLIB_SX1278_REG_PLL_HOP, RADIOLIB_SX127X_FAST_HOP_ON, 7, 7);
  return(state);
}

void SX1278::errataFix(bool rx) {
    64c4:	4f 92       	push	r4
    64c6:	5f 92       	push	r5
    64c8:	6f 92       	push	r6
    64ca:	7f 92       	push	r7
    64cc:	8f 92       	push	r8
    64ce:	9f 92       	push	r9
    64d0:	af 92       	push	r10
    64d2:	bf 92       	push	r11
    64d4:	cf 92       	push	r12
    64d6:	df 92       	push	r13
    64d8:	ef 92       	push	r14
    64da:	ff 92       	push	r15
    64dc:	0f 93       	push	r16
    64de:	1f 93       	push	r17
    64e0:	cf 93       	push	r28
    64e2:	df 93       	push	r29
    64e4:	ec 01       	movw	r28, r24
    64e6:	16 2f       	mov	r17, r22
  // only apply in LoRa mode
  if(getActiveModem() != RADIOLIB_SX127X_LORA) {
    64e8:	0e 94 ec 18 	call	0x31d8	; 0x31d8 <_ZN6SX127x14getActiveModemEv>
    64ec:	80 38       	cpi	r24, 0x80	; 128
    64ee:	91 05       	cpc	r25, r1
    64f0:	89 f0       	breq	.+34     	; 0x6514 <_ZN6SX12789errataFixEb+0x50>

  // finally, apply errata fixes
  this->mod->SPIsetRegValue(0x31, fixedRegs[0], 7, 7);
  this->mod->SPIsetRegValue(0x2F, fixedRegs[1]);
  this->mod->SPIsetRegValue(0x30, fixedRegs[2]);
}
    64f2:	df 91       	pop	r29
    64f4:	cf 91       	pop	r28
    64f6:	1f 91       	pop	r17
    64f8:	0f 91       	pop	r16
    64fa:	ff 90       	pop	r15
    64fc:	ef 90       	pop	r14
    64fe:	df 90       	pop	r13
    6500:	cf 90       	pop	r12
    6502:	bf 90       	pop	r11
    6504:	af 90       	pop	r10
    6506:	9f 90       	pop	r9
    6508:	8f 90       	pop	r8
    650a:	7f 90       	pop	r7
    650c:	6f 90       	pop	r6
    650e:	5f 90       	pop	r5
    6510:	4f 90       	pop	r4
    6512:	08 95       	ret
    return;
  }

  // sensitivity optimization for 500kHz bandwidth
  // see SX1276/77/78 Errata, section 2.1 for details
  if(fabs(SX127x::bandwidth - 500.0) <= 0.001) {
    6514:	fe 01       	movw	r30, r28
    6516:	e1 5e       	subi	r30, 0xE1	; 225
    6518:	fe 4f       	sbci	r31, 0xFE	; 254
    651a:	60 81       	ld	r22, Z
    651c:	71 81       	ldd	r23, Z+1	; 0x01
    651e:	82 81       	ldd	r24, Z+2	; 0x02
    6520:	93 81       	ldd	r25, Z+3	; 0x03
    6522:	20 e0       	ldi	r18, 0x00	; 0
    6524:	30 e0       	ldi	r19, 0x00	; 0
    6526:	4a ef       	ldi	r20, 0xFA	; 250
    6528:	53 e4       	ldi	r21, 0x43	; 67
    652a:	0e 94 6b 3b 	call	0x76d6	; 0x76d6 <__subsf3>
    652e:	9f 77       	andi	r25, 0x7F	; 127
    6530:	2f e6       	ldi	r18, 0x6F	; 111
    6532:	32 e1       	ldi	r19, 0x12	; 18
    6534:	43 e8       	ldi	r20, 0x83	; 131
    6536:	5a e3       	ldi	r21, 0x3A	; 58
    6538:	0e 94 71 39 	call	0x72e2	; 0x72e2 <__cmpsf2>
    653c:	18 16       	cp	r1, r24
    653e:	8c f1       	brlt	.+98     	; 0x65a2 <_ZN6SX12789errataFixEb+0xde>
    if((frequency >= 862.0) && (frequency <= 1020.0)) {
    6540:	fe 01       	movw	r30, r28
    6542:	e5 5e       	subi	r30, 0xE5	; 229
    6544:	fe 4f       	sbci	r31, 0xFE	; 254
    6546:	c0 80       	ld	r12, Z
    6548:	d1 80       	ldd	r13, Z+1	; 0x01
    654a:	e2 80       	ldd	r14, Z+2	; 0x02
    654c:	f3 80       	ldd	r15, Z+3	; 0x03
    654e:	20 e0       	ldi	r18, 0x00	; 0
    6550:	30 e8       	ldi	r19, 0x80	; 128
    6552:	47 e5       	ldi	r20, 0x57	; 87
    6554:	54 e4       	ldi	r21, 0x44	; 68
    6556:	c7 01       	movw	r24, r14
    6558:	b6 01       	movw	r22, r12
    655a:	0e 94 d1 3c 	call	0x79a2	; 0x79a2 <__gesf2>
    655e:	88 23       	and	r24, r24
    6560:	5c f0       	brlt	.+22     	; 0x6578 <_ZN6SX12789errataFixEb+0xb4>
    6562:	20 e0       	ldi	r18, 0x00	; 0
    6564:	30 e0       	ldi	r19, 0x00	; 0
    6566:	4f e7       	ldi	r20, 0x7F	; 127
    6568:	54 e4       	ldi	r21, 0x44	; 68
    656a:	c7 01       	movw	r24, r14
    656c:	b6 01       	movw	r22, r12
    656e:	0e 94 71 39 	call	0x72e2	; 0x72e2 <__cmpsf2>
    6572:	18 16       	cp	r1, r24
    6574:	0c f0       	brlt	.+2      	; 0x6578 <_ZN6SX12789errataFixEb+0xb4>
    6576:	74 c0       	rjmp	.+232    	; 0x6660 <_ZN6SX12789errataFixEb+0x19c>
      this->mod->SPIwriteRegister(0x36, 0x02);
      this->mod->SPIwriteRegister(0x3a, 0x64);
    } else if((frequency >= 410.0) && (frequency <= 525.0)) {
    6578:	20 e0       	ldi	r18, 0x00	; 0
    657a:	30 e0       	ldi	r19, 0x00	; 0
    657c:	4d ec       	ldi	r20, 0xCD	; 205
    657e:	53 e4       	ldi	r21, 0x43	; 67
    6580:	c7 01       	movw	r24, r14
    6582:	b6 01       	movw	r22, r12
    6584:	0e 94 d1 3c 	call	0x79a2	; 0x79a2 <__gesf2>
    6588:	88 23       	and	r24, r24
    658a:	5c f0       	brlt	.+22     	; 0x65a2 <_ZN6SX12789errataFixEb+0xde>
    658c:	20 e0       	ldi	r18, 0x00	; 0
    658e:	30 e4       	ldi	r19, 0x40	; 64
    6590:	43 e0       	ldi	r20, 0x03	; 3
    6592:	54 e4       	ldi	r21, 0x44	; 68
    6594:	c7 01       	movw	r24, r14
    6596:	b6 01       	movw	r22, r12
    6598:	0e 94 71 39 	call	0x72e2	; 0x72e2 <__cmpsf2>
    659c:	18 16       	cp	r1, r24
    659e:	0c f0       	brlt	.+2      	; 0x65a2 <_ZN6SX12789errataFixEb+0xde>
    65a0:	75 c0       	rjmp	.+234    	; 0x668c <_ZN6SX12789errataFixEb+0x1c8>

  // mitigation of receiver spurious response
  // see SX1276/77/78 Errata, section 2.3 for details

  // figure out what we need to set
  uint8_t fixedRegs[3] = { 0x00, 0x00, 0x00 };
    65a2:	b1 2c       	mov	r11, r1
    65a4:	a1 2c       	mov	r10, r1
  float rxFreq = frequency;
    65a6:	fe 01       	movw	r30, r28
    65a8:	e5 5e       	subi	r30, 0xE5	; 229
    65aa:	fe 4f       	sbci	r31, 0xFE	; 254
    65ac:	c0 80       	ld	r12, Z
    65ae:	d1 80       	ldd	r13, Z+1	; 0x01
    65b0:	e2 80       	ldd	r14, Z+2	; 0x02
    65b2:	f3 80       	ldd	r15, Z+3	; 0x03
  if(fabs(SX127x::bandwidth - 7.8) <= 0.001) {
    65b4:	34 96       	adiw	r30, 0x04	; 4
    65b6:	40 80       	ld	r4, Z
    65b8:	51 80       	ldd	r5, Z+1	; 0x01
    65ba:	62 80       	ldd	r6, Z+2	; 0x02
    65bc:	73 80       	ldd	r7, Z+3	; 0x03
    65be:	2a e9       	ldi	r18, 0x9A	; 154
    65c0:	39 e9       	ldi	r19, 0x99	; 153
    65c2:	49 ef       	ldi	r20, 0xF9	; 249
    65c4:	50 e4       	ldi	r21, 0x40	; 64
    65c6:	c3 01       	movw	r24, r6
    65c8:	b2 01       	movw	r22, r4
    65ca:	0e 94 6b 3b 	call	0x76d6	; 0x76d6 <__subsf3>
    65ce:	9f 77       	andi	r25, 0x7F	; 127
    65d0:	2f e6       	ldi	r18, 0x6F	; 111
    65d2:	32 e1       	ldi	r19, 0x12	; 18
    65d4:	43 e8       	ldi	r20, 0x83	; 131
    65d6:	5a e3       	ldi	r21, 0x3A	; 58
    65d8:	0e 94 71 39 	call	0x72e2	; 0x72e2 <__cmpsf2>
    65dc:	18 16       	cp	r1, r24
    65de:	0c f4       	brge	.+2      	; 0x65e2 <_ZN6SX12789errataFixEb+0x11e>
    65e0:	6b c0       	rjmp	.+214    	; 0x66b8 <_ZN6SX12789errataFixEb+0x1f4>
    fixedRegs[0] = 0b0000000;
    fixedRegs[1] = 0x48;
    65e2:	0f 2e       	mov	r0, r31
    65e4:	f8 e4       	ldi	r31, 0x48	; 72
    65e6:	7f 2e       	mov	r7, r31
    65e8:	f0 2d       	mov	r31, r0
    fixedRegs[2] = 0x00;
    rxFreq += 0.00781;
    65ea:	27 e0       	ldi	r18, 0x07	; 7
    65ec:	3b ee       	ldi	r19, 0xEB	; 235
    65ee:	4f ef       	ldi	r20, 0xFF	; 255
    65f0:	5b e3       	ldi	r21, 0x3B	; 59
    65f2:	c7 01       	movw	r24, r14
    65f4:	b6 01       	movw	r22, r12
    65f6:	0e 94 6c 3b 	call	0x76d8	; 0x76d8 <__addsf3>
    65fa:	6b 01       	movw	r12, r22
    65fc:	7c 01       	movw	r14, r24
  } else {
    return;
  }

  // first, go to standby
  standby();
    65fe:	e8 81       	ld	r30, Y
    6600:	f9 81       	ldd	r31, Y+1	; 0x01
    6602:	04 80       	ldd	r0, Z+4	; 0x04
    6604:	f5 81       	ldd	r31, Z+5	; 0x05
    6606:	e0 2d       	mov	r30, r0
    6608:	ce 01       	movw	r24, r28
    660a:	09 95       	icall

  // shift the freqency up when receiving, or restore the original when transmitting
  if(rx) {
    660c:	11 23       	and	r17, r17
    660e:	09 f4       	brne	.+2      	; 0x6612 <_ZN6SX12789errataFixEb+0x14e>
    6610:	5d c1       	rjmp	.+698    	; 0x68cc <_ZN6SX12789errataFixEb+0x408>
    SX127x::setFrequencyRaw(rxFreq);
    6612:	b7 01       	movw	r22, r14
    6614:	a6 01       	movw	r20, r12
    6616:	ce 01       	movw	r24, r28
    6618:	0e 94 36 2b 	call	0x566c	; 0x566c <_ZN6SX127x15setFrequencyRawEf>
  } else {
    SX127x::setFrequencyRaw(frequency);
  }

  // finally, apply errata fixes
  this->mod->SPIsetRegValue(0x31, fixedRegs[0], 7, 7);
    661c:	c7 5e       	subi	r28, 0xE7	; 231
    661e:	de 4f       	sbci	r29, 0xFE	; 254
    6620:	cc 24       	eor	r12, r12
    6622:	ca 94       	dec	r12
    6624:	68 94       	set
    6626:	ee 24       	eor	r14, r14
    6628:	e1 f8       	bld	r14, 1
    662a:	07 e0       	ldi	r16, 0x07	; 7
    662c:	27 e0       	ldi	r18, 0x07	; 7
    662e:	4b 2d       	mov	r20, r11
    6630:	61 e3       	ldi	r22, 0x31	; 49
    6632:	70 e0       	ldi	r23, 0x00	; 0
    6634:	88 81       	ld	r24, Y
    6636:	99 81       	ldd	r25, Y+1	; 0x01
    6638:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
  this->mod->SPIsetRegValue(0x2F, fixedRegs[1]);
    663c:	00 e0       	ldi	r16, 0x00	; 0
    663e:	27 e0       	ldi	r18, 0x07	; 7
    6640:	47 2d       	mov	r20, r7
    6642:	6f e2       	ldi	r22, 0x2F	; 47
    6644:	70 e0       	ldi	r23, 0x00	; 0
    6646:	88 81       	ld	r24, Y
    6648:	99 81       	ldd	r25, Y+1	; 0x01
    664a:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
  this->mod->SPIsetRegValue(0x30, fixedRegs[2]);
    664e:	27 e0       	ldi	r18, 0x07	; 7
    6650:	4a 2d       	mov	r20, r10
    6652:	60 e3       	ldi	r22, 0x30	; 48
    6654:	70 e0       	ldi	r23, 0x00	; 0
    6656:	88 81       	ld	r24, Y
    6658:	99 81       	ldd	r25, Y+1	; 0x01
    665a:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_ZN6Module14SPIsetRegValueEjhhhhh>
    665e:	49 cf       	rjmp	.-366    	; 0x64f2 <_ZN6SX12789errataFixEb+0x2e>

  // sensitivity optimization for 500kHz bandwidth
  // see SX1276/77/78 Errata, section 2.1 for details
  if(fabs(SX127x::bandwidth - 500.0) <= 0.001) {
    if((frequency >= 862.0) && (frequency <= 1020.0)) {
      this->mod->SPIwriteRegister(0x36, 0x02);
    6660:	42 e0       	ldi	r20, 0x02	; 2
    6662:	66 e3       	ldi	r22, 0x36	; 54
    6664:	70 e0       	ldi	r23, 0x00	; 0
    6666:	7e 01       	movw	r14, r28
    6668:	87 ee       	ldi	r24, 0xE7	; 231
    666a:	e8 1a       	sub	r14, r24
    666c:	8e ef       	ldi	r24, 0xFE	; 254
    666e:	f8 0a       	sbc	r15, r24
    6670:	f7 01       	movw	r30, r14
    6672:	80 81       	ld	r24, Z
    6674:	91 81       	ldd	r25, Z+1	; 0x01
    6676:	0e 94 ee 16 	call	0x2ddc	; 0x2ddc <_ZN6Module16SPIwriteRegisterEjh>
      this->mod->SPIwriteRegister(0x3a, 0x64);
    667a:	44 e6       	ldi	r20, 0x64	; 100
    667c:	6a e3       	ldi	r22, 0x3A	; 58
    667e:	70 e0       	ldi	r23, 0x00	; 0
    6680:	f7 01       	movw	r30, r14
    6682:	80 81       	ld	r24, Z
    6684:	91 81       	ldd	r25, Z+1	; 0x01
    6686:	0e 94 ee 16 	call	0x2ddc	; 0x2ddc <_ZN6Module16SPIwriteRegisterEjh>
    668a:	8b cf       	rjmp	.-234    	; 0x65a2 <_ZN6SX12789errataFixEb+0xde>
    } else if((frequency >= 410.0) && (frequency <= 525.0)) {
      this->mod->SPIwriteRegister(0x36, 0x02);
    668c:	42 e0       	ldi	r20, 0x02	; 2
    668e:	66 e3       	ldi	r22, 0x36	; 54
    6690:	70 e0       	ldi	r23, 0x00	; 0
    6692:	7e 01       	movw	r14, r28
    6694:	f7 ee       	ldi	r31, 0xE7	; 231
    6696:	ef 1a       	sub	r14, r31
    6698:	fe ef       	ldi	r31, 0xFE	; 254
    669a:	ff 0a       	sbc	r15, r31
    669c:	f7 01       	movw	r30, r14
    669e:	80 81       	ld	r24, Z
    66a0:	91 81       	ldd	r25, Z+1	; 0x01
    66a2:	0e 94 ee 16 	call	0x2ddc	; 0x2ddc <_ZN6Module16SPIwriteRegisterEjh>
      this->mod->SPIwriteRegister(0x3a, 0x7F);
    66a6:	4f e7       	ldi	r20, 0x7F	; 127
    66a8:	6a e3       	ldi	r22, 0x3A	; 58
    66aa:	70 e0       	ldi	r23, 0x00	; 0
    66ac:	f7 01       	movw	r30, r14
    66ae:	80 81       	ld	r24, Z
    66b0:	91 81       	ldd	r25, Z+1	; 0x01
    66b2:	0e 94 ee 16 	call	0x2ddc	; 0x2ddc <_ZN6Module16SPIwriteRegisterEjh>
    66b6:	75 cf       	rjmp	.-278    	; 0x65a2 <_ZN6SX12789errataFixEb+0xde>
  if(fabs(SX127x::bandwidth - 7.8) <= 0.001) {
    fixedRegs[0] = 0b0000000;
    fixedRegs[1] = 0x48;
    fixedRegs[2] = 0x00;
    rxFreq += 0.00781;
  } else if(fabs(SX127x::bandwidth - 10.4) <= 0.001) {
    66b8:	26 e6       	ldi	r18, 0x66	; 102
    66ba:	36 e6       	ldi	r19, 0x66	; 102
    66bc:	46 e2       	ldi	r20, 0x26	; 38
    66be:	51 e4       	ldi	r21, 0x41	; 65
    66c0:	c3 01       	movw	r24, r6
    66c2:	b2 01       	movw	r22, r4
    66c4:	0e 94 6b 3b 	call	0x76d6	; 0x76d6 <__subsf3>
    66c8:	9f 77       	andi	r25, 0x7F	; 127
    66ca:	2f e6       	ldi	r18, 0x6F	; 111
    66cc:	32 e1       	ldi	r19, 0x12	; 18
    66ce:	43 e8       	ldi	r20, 0x83	; 131
    66d0:	5a e3       	ldi	r21, 0x3A	; 58
    66d2:	0e 94 71 39 	call	0x72e2	; 0x72e2 <__cmpsf2>
    66d6:	18 16       	cp	r1, r24
    66d8:	7c f0       	brlt	.+30     	; 0x66f8 <_ZN6SX12789errataFixEb+0x234>
    fixedRegs[0] = 0b0000000;
    fixedRegs[1] = 0x44;
    66da:	0f 2e       	mov	r0, r31
    66dc:	f4 e4       	ldi	r31, 0x44	; 68
    66de:	7f 2e       	mov	r7, r31
    66e0:	f0 2d       	mov	r31, r0
    fixedRegs[2] = 0x00;
    rxFreq += 0.01042;
    66e2:	26 ea       	ldi	r18, 0xA6	; 166
    66e4:	38 eb       	ldi	r19, 0xB8	; 184
    66e6:	4a e2       	ldi	r20, 0x2A	; 42
    66e8:	5c e3       	ldi	r21, 0x3C	; 60
    66ea:	c7 01       	movw	r24, r14
    66ec:	b6 01       	movw	r22, r12
    66ee:	0e 94 6c 3b 	call	0x76d8	; 0x76d8 <__addsf3>
    66f2:	6b 01       	movw	r12, r22
    66f4:	7c 01       	movw	r14, r24
    66f6:	83 cf       	rjmp	.-250    	; 0x65fe <_ZN6SX12789errataFixEb+0x13a>
  } else if(fabs(SX127x::bandwidth - 15.6) <= 0.001) {
    66f8:	2a e9       	ldi	r18, 0x9A	; 154
    66fa:	39 e9       	ldi	r19, 0x99	; 153
    66fc:	49 e7       	ldi	r20, 0x79	; 121
    66fe:	51 e4       	ldi	r21, 0x41	; 65
    6700:	c3 01       	movw	r24, r6
    6702:	b2 01       	movw	r22, r4
    6704:	0e 94 6b 3b 	call	0x76d6	; 0x76d6 <__subsf3>
    6708:	9f 77       	andi	r25, 0x7F	; 127
    670a:	2f e6       	ldi	r18, 0x6F	; 111
    670c:	32 e1       	ldi	r19, 0x12	; 18
    670e:	43 e8       	ldi	r20, 0x83	; 131
    6710:	5a e3       	ldi	r21, 0x3A	; 58
    6712:	0e 94 71 39 	call	0x72e2	; 0x72e2 <__cmpsf2>
    6716:	18 16       	cp	r1, r24
    6718:	7c f0       	brlt	.+30     	; 0x6738 <_ZN6SX12789errataFixEb+0x274>
    fixedRegs[0] = 0b0000000;
    fixedRegs[1] = 0x44;
    671a:	0f 2e       	mov	r0, r31
    671c:	f4 e4       	ldi	r31, 0x44	; 68
    671e:	7f 2e       	mov	r7, r31
    6720:	f0 2d       	mov	r31, r0
    fixedRegs[2] = 0x00;
    rxFreq += 0.01562;
    6722:	27 e0       	ldi	r18, 0x07	; 7
    6724:	3b ee       	ldi	r19, 0xEB	; 235
    6726:	4f e7       	ldi	r20, 0x7F	; 127
    6728:	5c e3       	ldi	r21, 0x3C	; 60
    672a:	c7 01       	movw	r24, r14
    672c:	b6 01       	movw	r22, r12
    672e:	0e 94 6c 3b 	call	0x76d8	; 0x76d8 <__addsf3>
    6732:	6b 01       	movw	r12, r22
    6734:	7c 01       	movw	r14, r24
    6736:	63 cf       	rjmp	.-314    	; 0x65fe <_ZN6SX12789errataFixEb+0x13a>
  } else if(fabs(SX127x::bandwidth - 20.8) <= 0.001) {
    6738:	26 e6       	ldi	r18, 0x66	; 102
    673a:	36 e6       	ldi	r19, 0x66	; 102
    673c:	46 ea       	ldi	r20, 0xA6	; 166
    673e:	51 e4       	ldi	r21, 0x41	; 65
    6740:	c3 01       	movw	r24, r6
    6742:	b2 01       	movw	r22, r4
    6744:	0e 94 6b 3b 	call	0x76d6	; 0x76d6 <__subsf3>
    6748:	9f 77       	andi	r25, 0x7F	; 127
    674a:	2f e6       	ldi	r18, 0x6F	; 111
    674c:	32 e1       	ldi	r19, 0x12	; 18
    674e:	43 e8       	ldi	r20, 0x83	; 131
    6750:	5a e3       	ldi	r21, 0x3A	; 58
    6752:	0e 94 71 39 	call	0x72e2	; 0x72e2 <__cmpsf2>
    6756:	18 16       	cp	r1, r24
    6758:	7c f0       	brlt	.+30     	; 0x6778 <_ZN6SX12789errataFixEb+0x2b4>
    fixedRegs[0] = 0b0000000;
    fixedRegs[1] = 0x44;
    675a:	0f 2e       	mov	r0, r31
    675c:	f4 e4       	ldi	r31, 0x44	; 68
    675e:	7f 2e       	mov	r7, r31
    6760:	f0 2d       	mov	r31, r0
    fixedRegs[2] = 0x00;
    rxFreq += 0.02083;
    6762:	2d ea       	ldi	r18, 0xAD	; 173
    6764:	33 ea       	ldi	r19, 0xA3	; 163
    6766:	4a ea       	ldi	r20, 0xAA	; 170
    6768:	5c e3       	ldi	r21, 0x3C	; 60
    676a:	c7 01       	movw	r24, r14
    676c:	b6 01       	movw	r22, r12
    676e:	0e 94 6c 3b 	call	0x76d8	; 0x76d8 <__addsf3>
    6772:	6b 01       	movw	r12, r22
    6774:	7c 01       	movw	r14, r24
    6776:	43 cf       	rjmp	.-378    	; 0x65fe <_ZN6SX12789errataFixEb+0x13a>
  } else if(fabs(SX127x::bandwidth - 31.25) <= 0.001) {
    6778:	20 e0       	ldi	r18, 0x00	; 0
    677a:	30 e0       	ldi	r19, 0x00	; 0
    677c:	4a ef       	ldi	r20, 0xFA	; 250
    677e:	51 e4       	ldi	r21, 0x41	; 65
    6780:	c3 01       	movw	r24, r6
    6782:	b2 01       	movw	r22, r4
    6784:	0e 94 6b 3b 	call	0x76d6	; 0x76d6 <__subsf3>
    6788:	9f 77       	andi	r25, 0x7F	; 127
    678a:	2f e6       	ldi	r18, 0x6F	; 111
    678c:	32 e1       	ldi	r19, 0x12	; 18
    678e:	43 e8       	ldi	r20, 0x83	; 131
    6790:	5a e3       	ldi	r21, 0x3A	; 58
    6792:	0e 94 71 39 	call	0x72e2	; 0x72e2 <__cmpsf2>
    6796:	18 16       	cp	r1, r24
    6798:	7c f0       	brlt	.+30     	; 0x67b8 <_ZN6SX12789errataFixEb+0x2f4>
    fixedRegs[0] = 0b0000000;
    fixedRegs[1] = 0x44;
    679a:	0f 2e       	mov	r0, r31
    679c:	f4 e4       	ldi	r31, 0x44	; 68
    679e:	7f 2e       	mov	r7, r31
    67a0:	f0 2d       	mov	r31, r0
    fixedRegs[2] = 0x00;
    rxFreq += 0.03125;
    67a2:	20 e0       	ldi	r18, 0x00	; 0
    67a4:	30 e0       	ldi	r19, 0x00	; 0
    67a6:	40 e0       	ldi	r20, 0x00	; 0
    67a8:	5d e3       	ldi	r21, 0x3D	; 61
    67aa:	c7 01       	movw	r24, r14
    67ac:	b6 01       	movw	r22, r12
    67ae:	0e 94 6c 3b 	call	0x76d8	; 0x76d8 <__addsf3>
    67b2:	6b 01       	movw	r12, r22
    67b4:	7c 01       	movw	r14, r24
    67b6:	23 cf       	rjmp	.-442    	; 0x65fe <_ZN6SX12789errataFixEb+0x13a>
  } else if(fabs(SX127x::bandwidth - 41.7) <= 0.001) {
    67b8:	2d ec       	ldi	r18, 0xCD	; 205
    67ba:	3c ec       	ldi	r19, 0xCC	; 204
    67bc:	46 e2       	ldi	r20, 0x26	; 38
    67be:	52 e4       	ldi	r21, 0x42	; 66
    67c0:	c3 01       	movw	r24, r6
    67c2:	b2 01       	movw	r22, r4
    67c4:	0e 94 6b 3b 	call	0x76d6	; 0x76d6 <__subsf3>
    67c8:	9f 77       	andi	r25, 0x7F	; 127
    67ca:	2f e6       	ldi	r18, 0x6F	; 111
    67cc:	32 e1       	ldi	r19, 0x12	; 18
    67ce:	43 e8       	ldi	r20, 0x83	; 131
    67d0:	5a e3       	ldi	r21, 0x3A	; 58
    67d2:	0e 94 71 39 	call	0x72e2	; 0x72e2 <__cmpsf2>
    67d6:	18 16       	cp	r1, r24
    67d8:	7c f0       	brlt	.+30     	; 0x67f8 <_ZN6SX12789errataFixEb+0x334>
    fixedRegs[0] = 0b0000000;
    fixedRegs[1] = 0x44;
    67da:	0f 2e       	mov	r0, r31
    67dc:	f4 e4       	ldi	r31, 0x44	; 68
    67de:	7f 2e       	mov	r7, r31
    67e0:	f0 2d       	mov	r31, r0
    fixedRegs[2] = 0x00;
    rxFreq += 0.04167;
    67e2:	29 e2       	ldi	r18, 0x29	; 41
    67e4:	3e ea       	ldi	r19, 0xAE	; 174
    67e6:	4a e2       	ldi	r20, 0x2A	; 42
    67e8:	5d e3       	ldi	r21, 0x3D	; 61
    67ea:	c7 01       	movw	r24, r14
    67ec:	b6 01       	movw	r22, r12
    67ee:	0e 94 6c 3b 	call	0x76d8	; 0x76d8 <__addsf3>
    67f2:	6b 01       	movw	r12, r22
    67f4:	7c 01       	movw	r14, r24
    67f6:	03 cf       	rjmp	.-506    	; 0x65fe <_ZN6SX12789errataFixEb+0x13a>
  } else if(fabs(SX127x::bandwidth - 62.5) <= 0.001) {
    67f8:	20 e0       	ldi	r18, 0x00	; 0
    67fa:	30 e0       	ldi	r19, 0x00	; 0
    67fc:	4a e7       	ldi	r20, 0x7A	; 122
    67fe:	52 e4       	ldi	r21, 0x42	; 66
    6800:	c3 01       	movw	r24, r6
    6802:	b2 01       	movw	r22, r4
    6804:	0e 94 6b 3b 	call	0x76d6	; 0x76d6 <__subsf3>
    6808:	9f 77       	andi	r25, 0x7F	; 127
    680a:	2f e6       	ldi	r18, 0x6F	; 111
    680c:	32 e1       	ldi	r19, 0x12	; 18
    680e:	43 e8       	ldi	r20, 0x83	; 131
    6810:	5a e3       	ldi	r21, 0x3A	; 58
    6812:	0e 94 71 39 	call	0x72e2	; 0x72e2 <__cmpsf2>
    6816:	18 16       	cp	r1, r24
    6818:	24 f0       	brlt	.+8      	; 0x6822 <_ZN6SX12789errataFixEb+0x35e>
    fixedRegs[0] = 0b0000000;
    fixedRegs[1] = 0x40;
    681a:	68 94       	set
    681c:	77 24       	eor	r7, r7
    681e:	76 f8       	bld	r7, 6
    6820:	ee ce       	rjmp	.-548    	; 0x65fe <_ZN6SX12789errataFixEb+0x13a>
    fixedRegs[2] = 0x00;
  } else if(fabs(SX127x::bandwidth - 125.0) <= 0.001) {
    6822:	20 e0       	ldi	r18, 0x00	; 0
    6824:	30 e0       	ldi	r19, 0x00	; 0
    6826:	4a ef       	ldi	r20, 0xFA	; 250
    6828:	52 e4       	ldi	r21, 0x42	; 66
    682a:	c3 01       	movw	r24, r6
    682c:	b2 01       	movw	r22, r4
    682e:	0e 94 6b 3b 	call	0x76d6	; 0x76d6 <__subsf3>
    6832:	9f 77       	andi	r25, 0x7F	; 127
    6834:	2f e6       	ldi	r18, 0x6F	; 111
    6836:	32 e1       	ldi	r19, 0x12	; 18
    6838:	43 e8       	ldi	r20, 0x83	; 131
    683a:	5a e3       	ldi	r21, 0x3A	; 58
    683c:	0e 94 71 39 	call	0x72e2	; 0x72e2 <__cmpsf2>
    6840:	18 16       	cp	r1, r24
    6842:	24 f0       	brlt	.+8      	; 0x684c <_ZN6SX12789errataFixEb+0x388>
    fixedRegs[0] = 0b0000000;
    fixedRegs[1] = 0x40;
    6844:	68 94       	set
    6846:	77 24       	eor	r7, r7
    6848:	76 f8       	bld	r7, 6
    684a:	d9 ce       	rjmp	.-590    	; 0x65fe <_ZN6SX12789errataFixEb+0x13a>
    fixedRegs[2] = 0x00;
  } else if(fabs(SX127x::bandwidth - 250.0) <= 0.001) {
    684c:	20 e0       	ldi	r18, 0x00	; 0
    684e:	30 e0       	ldi	r19, 0x00	; 0
    6850:	4a e7       	ldi	r20, 0x7A	; 122
    6852:	53 e4       	ldi	r21, 0x43	; 67
    6854:	c3 01       	movw	r24, r6
    6856:	b2 01       	movw	r22, r4
    6858:	0e 94 6b 3b 	call	0x76d6	; 0x76d6 <__subsf3>
    685c:	9f 77       	andi	r25, 0x7F	; 127
    685e:	2f e6       	ldi	r18, 0x6F	; 111
    6860:	32 e1       	ldi	r19, 0x12	; 18
    6862:	43 e8       	ldi	r20, 0x83	; 131
    6864:	5a e3       	ldi	r21, 0x3A	; 58
    6866:	0e 94 71 39 	call	0x72e2	; 0x72e2 <__cmpsf2>
    686a:	18 16       	cp	r1, r24
    686c:	24 f0       	brlt	.+8      	; 0x6876 <_ZN6SX12789errataFixEb+0x3b2>
    fixedRegs[0] = 0b0000000;
    fixedRegs[1] = 0x40;
    686e:	68 94       	set
    6870:	77 24       	eor	r7, r7
    6872:	76 f8       	bld	r7, 6
    6874:	c4 ce       	rjmp	.-632    	; 0x65fe <_ZN6SX12789errataFixEb+0x13a>
    fixedRegs[2] = 0x00;
  } else if(fabs(SX127x::bandwidth - 500.0) <= 0.001) {
    6876:	20 e0       	ldi	r18, 0x00	; 0
    6878:	30 e0       	ldi	r19, 0x00	; 0
    687a:	4a ef       	ldi	r20, 0xFA	; 250
    687c:	53 e4       	ldi	r21, 0x43	; 67
    687e:	c3 01       	movw	r24, r6
    6880:	b2 01       	movw	r22, r4
    6882:	0e 94 6b 3b 	call	0x76d6	; 0x76d6 <__subsf3>
    6886:	9f 77       	andi	r25, 0x7F	; 127
    6888:	2f e6       	ldi	r18, 0x6F	; 111
    688a:	32 e1       	ldi	r19, 0x12	; 18
    688c:	43 e8       	ldi	r20, 0x83	; 131
    688e:	5a e3       	ldi	r21, 0x3A	; 58
    6890:	0e 94 71 39 	call	0x72e2	; 0x72e2 <__cmpsf2>
    6894:	18 16       	cp	r1, r24
    6896:	0c f4       	brge	.+2      	; 0x689a <_ZN6SX12789errataFixEb+0x3d6>
    6898:	2c ce       	rjmp	.-936    	; 0x64f2 <_ZN6SX12789errataFixEb+0x2e>
    fixedRegs[0] = 0b1000000;
    689a:	68 94       	set
    689c:	bb 24       	eor	r11, r11
    689e:	b6 f8       	bld	r11, 6
    fixedRegs[1] = this->mod->SPIreadRegister(0x2F);
    68a0:	6f e2       	ldi	r22, 0x2F	; 47
    68a2:	70 e0       	ldi	r23, 0x00	; 0
    68a4:	4e 01       	movw	r8, r28
    68a6:	f7 ee       	ldi	r31, 0xE7	; 231
    68a8:	8f 1a       	sub	r8, r31
    68aa:	fe ef       	ldi	r31, 0xFE	; 254
    68ac:	9f 0a       	sbc	r9, r31
    68ae:	f4 01       	movw	r30, r8
    68b0:	80 81       	ld	r24, Z
    68b2:	91 81       	ldd	r25, Z+1	; 0x01
    68b4:	0e 94 82 17 	call	0x2f04	; 0x2f04 <_ZN6Module15SPIreadRegisterEj>
    68b8:	78 2e       	mov	r7, r24
    fixedRegs[2] = this->mod->SPIreadRegister(0x30);
    68ba:	60 e3       	ldi	r22, 0x30	; 48
    68bc:	70 e0       	ldi	r23, 0x00	; 0
    68be:	f4 01       	movw	r30, r8
    68c0:	80 81       	ld	r24, Z
    68c2:	91 81       	ldd	r25, Z+1	; 0x01
    68c4:	0e 94 82 17 	call	0x2f04	; 0x2f04 <_ZN6Module15SPIreadRegisterEj>
    68c8:	a8 2e       	mov	r10, r24
    68ca:	99 ce       	rjmp	.-718    	; 0x65fe <_ZN6SX12789errataFixEb+0x13a>

  // shift the freqency up when receiving, or restore the original when transmitting
  if(rx) {
    SX127x::setFrequencyRaw(rxFreq);
  } else {
    SX127x::setFrequencyRaw(frequency);
    68cc:	fe 01       	movw	r30, r28
    68ce:	e5 5e       	subi	r30, 0xE5	; 229
    68d0:	fe 4f       	sbci	r31, 0xFE	; 254
    68d2:	40 81       	ld	r20, Z
    68d4:	51 81       	ldd	r21, Z+1	; 0x01
    68d6:	62 81       	ldd	r22, Z+2	; 0x02
    68d8:	73 81       	ldd	r23, Z+3	; 0x03
    68da:	ce 01       	movw	r24, r28
    68dc:	0e 94 36 2b 	call	0x566c	; 0x566c <_ZN6SX127x15setFrequencyRawEf>
    68e0:	9d ce       	rjmp	.-710    	; 0x661c <_ZN6SX12789errataFixEb+0x158>

000068e2 <_ZN6Module20SPIreadRegisterBurstEjjPh>:
  #else
    return(RADIOLIB_ERR_NONE);
  #endif
}

void Module::SPIreadRegisterBurst(uint16_t reg, size_t numBytes, uint8_t* inBytes) {
    68e2:	af 92       	push	r10
    68e4:	cf 92       	push	r12
    68e6:	df 92       	push	r13
    68e8:	ef 92       	push	r14
    68ea:	ff 92       	push	r15
    68ec:	0f 93       	push	r16
    68ee:	1f 93       	push	r17
    68f0:	cf 93       	push	r28
    68f2:	df 93       	push	r29
    68f4:	00 d0       	rcall	.+0      	; 0x68f6 <_ZN6Module20SPIreadRegisterBurstEjjPh+0x14>
    68f6:	1f 92       	push	r1
    68f8:	cd b7       	in	r28, 0x3d	; 61
    68fa:	de b7       	in	r29, 0x3e	; 62
  if(!SPIstreamType) {
    68fc:	dc 01       	movw	r26, r24
    68fe:	17 96       	adiw	r26, 0x07	; 7
    6900:	ec 91       	ld	r30, X
    6902:	17 97       	sbiw	r26, 0x07	; 7
    6904:	ee 23       	and	r30, r30
    6906:	49 f1       	breq	.+82     	; 0x695a <_ZN6Module20SPIreadRegisterBurstEjjPh+0x78>
    SPItransfer(SPIreadCommand, reg, NULL, inBytes, numBytes);
  } else {
    uint8_t cmd[] = { SPIreadCommand, (uint8_t)((reg >> 8) & 0xFF), (uint8_t)(reg & 0xFF) };
    6908:	12 96       	adiw	r26, 0x02	; 2
    690a:	ec 91       	ld	r30, X
    690c:	e9 83       	std	Y+1, r30	; 0x01
    690e:	7a 83       	std	Y+2, r23	; 0x02
    6910:	6b 83       	std	Y+3, r22	; 0x03
    SPItransferStream(cmd, 3, false, NULL, inBytes, numBytes, true, RADIOLIB_MODULE_SPI_TIMEOUT);
    6912:	1f 92       	push	r1
    6914:	1f 92       	push	r1
    6916:	63 e0       	ldi	r22, 0x03	; 3
    6918:	6f 93       	push	r22
    691a:	68 ee       	ldi	r22, 0xE8	; 232
    691c:	6f 93       	push	r22
    691e:	aa 24       	eor	r10, r10
    6920:	a3 94       	inc	r10
    6922:	6a 01       	movw	r12, r20
    6924:	79 01       	movw	r14, r18
    6926:	10 e0       	ldi	r17, 0x00	; 0
    6928:	00 e0       	ldi	r16, 0x00	; 0
    692a:	20 e0       	ldi	r18, 0x00	; 0
    692c:	43 e0       	ldi	r20, 0x03	; 3
    692e:	be 01       	movw	r22, r28
    6930:	6f 5f       	subi	r22, 0xFF	; 255
    6932:	7f 4f       	sbci	r23, 0xFF	; 255
    6934:	0e 94 22 14 	call	0x2844	; 0x2844 <_ZN6Module17SPItransferStreamEPhhbS0_S0_jbm>
    6938:	0f 90       	pop	r0
    693a:	0f 90       	pop	r0
    693c:	0f 90       	pop	r0
    693e:	0f 90       	pop	r0
  }
}
    6940:	0f 90       	pop	r0
    6942:	0f 90       	pop	r0
    6944:	0f 90       	pop	r0
    6946:	df 91       	pop	r29
    6948:	cf 91       	pop	r28
    694a:	1f 91       	pop	r17
    694c:	0f 91       	pop	r16
    694e:	ff 90       	pop	r15
    6950:	ef 90       	pop	r14
    6952:	df 90       	pop	r13
    6954:	cf 90       	pop	r12
    6956:	af 90       	pop	r10
    6958:	08 95       	ret
  #endif
}

void Module::SPIreadRegisterBurst(uint16_t reg, size_t numBytes, uint8_t* inBytes) {
  if(!SPIstreamType) {
    SPItransfer(SPIreadCommand, reg, NULL, inBytes, numBytes);
    695a:	7a 01       	movw	r14, r20
    695c:	89 01       	movw	r16, r18
    695e:	30 e0       	ldi	r19, 0x00	; 0
    6960:	20 e0       	ldi	r18, 0x00	; 0
    6962:	46 2f       	mov	r20, r22
    6964:	57 2f       	mov	r21, r23
    6966:	12 96       	adiw	r26, 0x02	; 2
    6968:	6c 91       	ld	r22, X
    696a:	0e 94 0f 16 	call	0x2c1e	; 0x2c1e <_ZN6Module11SPItransferEhjPhS0_j>
    696e:	e8 cf       	rjmp	.-48     	; 0x6940 <_ZN6Module20SPIreadRegisterBurstEjjPh+0x5e>

00006970 <_ZN6SX127x8readDataEPhj>:

  // set mode to standby to disable transmitter/RF switch
  return(standby());
}

int16_t SX127x::readData(uint8_t* data, size_t len) {
    6970:	8f 92       	push	r8
    6972:	9f 92       	push	r9
    6974:	af 92       	push	r10
    6976:	bf 92       	push	r11
    6978:	cf 92       	push	r12
    697a:	df 92       	push	r13
    697c:	ef 92       	push	r14
    697e:	ff 92       	push	r15
    6980:	0f 93       	push	r16
    6982:	1f 93       	push	r17
    6984:	cf 93       	push	r28
    6986:	df 93       	push	r29
    6988:	ec 01       	movw	r28, r24
    698a:	4b 01       	movw	r8, r22
    698c:	8a 01       	movw	r16, r20
  int16_t modem = getActiveModem();
    698e:	0e 94 ec 18 	call	0x31d8	; 0x31d8 <_ZN6SX127x14getActiveModemEv>
    6992:	6c 01       	movw	r12, r24

  // get packet length
  size_t length = getPacketLength();
    6994:	e8 81       	ld	r30, Y
    6996:	f9 81       	ldd	r31, Y+1	; 0x01
    6998:	04 a4       	ldd	r0, Z+44	; 0x2c
    699a:	f5 a5       	ldd	r31, Z+45	; 0x2d
    699c:	e0 2d       	mov	r30, r0
    699e:	61 e0       	ldi	r22, 0x01	; 1
    69a0:	ce 01       	movw	r24, r28
    69a2:	09 95       	icall
    69a4:	7c 01       	movw	r14, r24
  size_t dumpLen = 0;
  if((len != 0) && (len < length)) {
    69a6:	01 15       	cp	r16, r1
    69a8:	11 05       	cpc	r17, r1
    69aa:	39 f0       	breq	.+14     	; 0x69ba <_ZN6SX127x8readDataEPhj+0x4a>
    69ac:	08 17       	cp	r16, r24
    69ae:	19 07       	cpc	r17, r25
    69b0:	f0 f5       	brcc	.+124    	; 0x6a2e <_ZN6SX127x8readDataEPhj+0xbe>
    // user requested less data than we got, only return what was requested
    dumpLen = length - len;
    69b2:	80 1b       	sub	r24, r16
    69b4:	91 0b       	sbc	r25, r17
    length = len;
    69b6:	78 01       	movw	r14, r16
  // get packet length
  size_t length = getPacketLength();
  size_t dumpLen = 0;
  if((len != 0) && (len < length)) {
    // user requested less data than we got, only return what was requested
    dumpLen = length - len;
    69b8:	8c 01       	movw	r16, r24
    length = len;
  }

  // check payload CRC
  int16_t state = RADIOLIB_ERR_NONE;
  if(this->mod->SPIgetRegValue(RADIOLIB_SX127X_REG_IRQ_FLAGS, 5, 5) == RADIOLIB_SX127X_CLEAR_IRQ_FLAG_PAYLOAD_CRC_ERROR) {
    69ba:	25 e0       	ldi	r18, 0x05	; 5
    69bc:	45 e0       	ldi	r20, 0x05	; 5
    69be:	62 e1       	ldi	r22, 0x12	; 18
    69c0:	70 e0       	ldi	r23, 0x00	; 0
    69c2:	fe 01       	movw	r30, r28
    69c4:	e7 5e       	subi	r30, 0xE7	; 231
    69c6:	fe 4f       	sbci	r31, 0xFE	; 254
    69c8:	80 81       	ld	r24, Z
    69ca:	91 81       	ldd	r25, Z+1	; 0x01
    69cc:	0e 94 c0 18 	call	0x3180	; 0x3180 <_ZN6Module14SPIgetRegValueEjhh>
    69d0:	80 97       	sbiw	r24, 0x20	; 32
    69d2:	81 f1       	breq	.+96     	; 0x6a34 <_ZN6SX127x8readDataEPhj+0xc4>
    dumpLen = length - len;
    length = len;
  }

  // check payload CRC
  int16_t state = RADIOLIB_ERR_NONE;
    69d4:	b1 2c       	mov	r11, r1
    69d6:	a1 2c       	mov	r10, r1
  if(this->mod->SPIgetRegValue(RADIOLIB_SX127X_REG_IRQ_FLAGS, 5, 5) == RADIOLIB_SX127X_CLEAR_IRQ_FLAG_PAYLOAD_CRC_ERROR) {
    state = RADIOLIB_ERR_CRC_MISMATCH;
  }

  if(modem == RADIOLIB_SX127X_LORA) {
    69d8:	80 e8       	ldi	r24, 0x80	; 128
    69da:	c8 16       	cp	r12, r24
    69dc:	d1 04       	cpc	r13, r1
    69de:	89 f1       	breq	.+98     	; 0x6a42 <_ZN6SX127x8readDataEPhj+0xd2>
      // CRC is disabled according to packet header and enabled according to user
      // most likely damaged packet header
      state = RADIOLIB_ERR_LORA_HEADER_DAMAGED;
    }

  } else if(modem == RADIOLIB_SX127X_FSK_OOK) {
    69e0:	cd 28       	or	r12, r13
    69e2:	09 f4       	brne	.+2      	; 0x69e6 <_ZN6SX127x8readDataEPhj+0x76>
    69e4:	4a c0       	rjmp	.+148    	; 0x6a7a <_ZN6SX127x8readDataEPhj+0x10a>
      this->mod->SPIreadRegister(RADIOLIB_SX127X_REG_FIFO);
    }
  }

  // read packet data
  this->mod->SPIreadRegisterBurst(RADIOLIB_SX127X_REG_FIFO, length, data);
    69e6:	94 01       	movw	r18, r8
    69e8:	a7 01       	movw	r20, r14
    69ea:	70 e0       	ldi	r23, 0x00	; 0
    69ec:	60 e0       	ldi	r22, 0x00	; 0
    69ee:	fe 01       	movw	r30, r28
    69f0:	e7 5e       	subi	r30, 0xE7	; 231
    69f2:	fe 4f       	sbci	r31, 0xFE	; 254
    69f4:	80 81       	ld	r24, Z
    69f6:	91 81       	ldd	r25, Z+1	; 0x01
    69f8:	0e 94 71 34 	call	0x68e2	; 0x68e2 <_ZN6Module20SPIreadRegisterBurstEjjPh>

  // dump the bytes that weren't requested
  if(dumpLen != 0) {
    69fc:	01 15       	cp	r16, r1
    69fe:	11 05       	cpc	r17, r1
    6a00:	09 f0       	breq	.+2      	; 0x6a04 <_ZN6SX127x8readDataEPhj+0x94>
    6a02:	55 c0       	rjmp	.+170    	; 0x6aae <_ZN6SX127x8readDataEPhj+0x13e>
    clearFIFO(dumpLen);
  }

  // clear internal flag so getPacketLength can return the new packet length
  this->packetLengthQueried = false;
    6a04:	fe 01       	movw	r30, r28
    6a06:	ee 5c       	subi	r30, 0xCE	; 206
    6a08:	fe 4f       	sbci	r31, 0xFE	; 254
    6a0a:	10 82       	st	Z, r1

  // clear interrupt flags
  clearIRQFlags();
    6a0c:	ce 01       	movw	r24, r28
    6a0e:	0e 94 61 19 	call	0x32c2	; 0x32c2 <_ZN6SX127x13clearIRQFlagsEv>

  return(state);
}
    6a12:	c5 01       	movw	r24, r10
    6a14:	df 91       	pop	r29
    6a16:	cf 91       	pop	r28
    6a18:	1f 91       	pop	r17
    6a1a:	0f 91       	pop	r16
    6a1c:	ff 90       	pop	r15
    6a1e:	ef 90       	pop	r14
    6a20:	df 90       	pop	r13
    6a22:	cf 90       	pop	r12
    6a24:	bf 90       	pop	r11
    6a26:	af 90       	pop	r10
    6a28:	9f 90       	pop	r9
    6a2a:	8f 90       	pop	r8
    6a2c:	08 95       	ret
int16_t SX127x::readData(uint8_t* data, size_t len) {
  int16_t modem = getActiveModem();

  // get packet length
  size_t length = getPacketLength();
  size_t dumpLen = 0;
    6a2e:	10 e0       	ldi	r17, 0x00	; 0
    6a30:	00 e0       	ldi	r16, 0x00	; 0
    6a32:	c3 cf       	rjmp	.-122    	; 0x69ba <_ZN6SX127x8readDataEPhj+0x4a>
  }

  // check payload CRC
  int16_t state = RADIOLIB_ERR_NONE;
  if(this->mod->SPIgetRegValue(RADIOLIB_SX127X_REG_IRQ_FLAGS, 5, 5) == RADIOLIB_SX127X_CLEAR_IRQ_FLAG_PAYLOAD_CRC_ERROR) {
    state = RADIOLIB_ERR_CRC_MISMATCH;
    6a34:	0f 2e       	mov	r0, r31
    6a36:	f9 ef       	ldi	r31, 0xF9	; 249
    6a38:	af 2e       	mov	r10, r31
    6a3a:	bb 24       	eor	r11, r11
    6a3c:	ba 94       	dec	r11
    6a3e:	f0 2d       	mov	r31, r0
    6a40:	cb cf       	rjmp	.-106    	; 0x69d8 <_ZN6SX127x8readDataEPhj+0x68>
  }

  if(modem == RADIOLIB_SX127X_LORA) {
    // check packet header integrity
    if(this->crcEnabled && (state == RADIOLIB_ERR_NONE)  && (this->mod->SPIgetRegValue(RADIOLIB_SX127X_REG_HOP_CHANNEL, 6, 6) == 0)) {
    6a42:	fe 01       	movw	r30, r28
    6a44:	e6 5d       	subi	r30, 0xD6	; 214
    6a46:	fe 4f       	sbci	r31, 0xFE	; 254
    6a48:	80 81       	ld	r24, Z
    6a4a:	88 23       	and	r24, r24
    6a4c:	61 f2       	breq	.-104    	; 0x69e6 <_ZN6SX127x8readDataEPhj+0x76>
    6a4e:	a1 14       	cp	r10, r1
    6a50:	b1 04       	cpc	r11, r1
    6a52:	49 f6       	brne	.-110    	; 0x69e6 <_ZN6SX127x8readDataEPhj+0x76>
    6a54:	26 e0       	ldi	r18, 0x06	; 6
    6a56:	46 e0       	ldi	r20, 0x06	; 6
    6a58:	6c e1       	ldi	r22, 0x1C	; 28
    6a5a:	70 e0       	ldi	r23, 0x00	; 0
    6a5c:	71 97       	sbiw	r30, 0x11	; 17
    6a5e:	80 81       	ld	r24, Z
    6a60:	91 81       	ldd	r25, Z+1	; 0x01
    6a62:	0e 94 c0 18 	call	0x3180	; 0x3180 <_ZN6Module14SPIgetRegValueEjhh>
    6a66:	89 2b       	or	r24, r25
    6a68:	09 f0       	breq	.+2      	; 0x6a6c <_ZN6SX127x8readDataEPhj+0xfc>
    6a6a:	bd cf       	rjmp	.-134    	; 0x69e6 <_ZN6SX127x8readDataEPhj+0x76>
      // CRC is disabled according to packet header and enabled according to user
      // most likely damaged packet header
      state = RADIOLIB_ERR_LORA_HEADER_DAMAGED;
    6a6c:	0f 2e       	mov	r0, r31
    6a6e:	f8 ee       	ldi	r31, 0xE8	; 232
    6a70:	af 2e       	mov	r10, r31
    6a72:	bb 24       	eor	r11, r11
    6a74:	ba 94       	dec	r11
    6a76:	f0 2d       	mov	r31, r0
    6a78:	b6 cf       	rjmp	.-148    	; 0x69e6 <_ZN6SX127x8readDataEPhj+0x76>
    }

  } else if(modem == RADIOLIB_SX127X_FSK_OOK) {
    // check address filtering
    uint8_t filter = this->mod->SPIgetRegValue(RADIOLIB_SX127X_REG_PACKET_CONFIG_1, 2, 1);
    6a7a:	21 e0       	ldi	r18, 0x01	; 1
    6a7c:	42 e0       	ldi	r20, 0x02	; 2
    6a7e:	60 e3       	ldi	r22, 0x30	; 48
    6a80:	70 e0       	ldi	r23, 0x00	; 0
    6a82:	fe 01       	movw	r30, r28
    6a84:	e7 5e       	subi	r30, 0xE7	; 231
    6a86:	fe 4f       	sbci	r31, 0xFE	; 254
    6a88:	80 81       	ld	r24, Z
    6a8a:	91 81       	ldd	r25, Z+1	; 0x01
    6a8c:	0e 94 c0 18 	call	0x3180	; 0x3180 <_ZN6Module14SPIgetRegValueEjhh>
    if((filter == RADIOLIB_SX127X_ADDRESS_FILTERING_NODE) || (filter == RADIOLIB_SX127X_ADDRESS_FILTERING_NODE_BROADCAST)) {
    6a90:	82 30       	cpi	r24, 0x02	; 2
    6a92:	19 f0       	breq	.+6      	; 0x6a9a <_ZN6SX127x8readDataEPhj+0x12a>
    6a94:	84 30       	cpi	r24, 0x04	; 4
    6a96:	09 f0       	breq	.+2      	; 0x6a9a <_ZN6SX127x8readDataEPhj+0x12a>
    6a98:	a6 cf       	rjmp	.-180    	; 0x69e6 <_ZN6SX127x8readDataEPhj+0x76>
      this->mod->SPIreadRegister(RADIOLIB_SX127X_REG_FIFO);
    6a9a:	70 e0       	ldi	r23, 0x00	; 0
    6a9c:	60 e0       	ldi	r22, 0x00	; 0
    6a9e:	fe 01       	movw	r30, r28
    6aa0:	e7 5e       	subi	r30, 0xE7	; 231
    6aa2:	fe 4f       	sbci	r31, 0xFE	; 254
    6aa4:	80 81       	ld	r24, Z
    6aa6:	91 81       	ldd	r25, Z+1	; 0x01
    6aa8:	0e 94 82 17 	call	0x2f04	; 0x2f04 <_ZN6Module15SPIreadRegisterEj>
    6aac:	9c cf       	rjmp	.-200    	; 0x69e6 <_ZN6SX127x8readDataEPhj+0x76>
  // read packet data
  this->mod->SPIreadRegisterBurst(RADIOLIB_SX127X_REG_FIFO, length, data);

  // dump the bytes that weren't requested
  if(dumpLen != 0) {
    clearFIFO(dumpLen);
    6aae:	b8 01       	movw	r22, r16
    6ab0:	ce 01       	movw	r24, r28
    6ab2:	0e 94 32 30 	call	0x6064	; 0x6064 <_ZN6SX127x9clearFIFOEj>
    6ab6:	a6 cf       	rjmp	.-180    	; 0x6a04 <_ZN6SX127x8readDataEPhj+0x94>

00006ab8 <_ZN6SX127x12getTimeOnAirEj>:

int16_t SX127x::variablePacketLengthMode(uint8_t maxLen) {
  return(SX127x::setPacketMode(RADIOLIB_SX127X_PACKET_VARIABLE, maxLen));
}

uint32_t SX127x::getTimeOnAir(size_t len) {
    6ab8:	2f 92       	push	r2
    6aba:	3f 92       	push	r3
    6abc:	4f 92       	push	r4
    6abe:	5f 92       	push	r5
    6ac0:	6f 92       	push	r6
    6ac2:	7f 92       	push	r7
    6ac4:	8f 92       	push	r8
    6ac6:	9f 92       	push	r9
    6ac8:	af 92       	push	r10
    6aca:	bf 92       	push	r11
    6acc:	cf 92       	push	r12
    6ace:	df 92       	push	r13
    6ad0:	ef 92       	push	r14
    6ad2:	ff 92       	push	r15
    6ad4:	0f 93       	push	r16
    6ad6:	1f 93       	push	r17
    6ad8:	cf 93       	push	r28
    6ada:	df 93       	push	r29
    6adc:	cd b7       	in	r28, 0x3d	; 61
    6ade:	de b7       	in	r29, 0x3e	; 62
    6ae0:	60 97       	sbiw	r28, 0x10	; 16
    6ae2:	0f b6       	in	r0, 0x3f	; 63
    6ae4:	f8 94       	cli
    6ae6:	de bf       	out	0x3e, r29	; 62
    6ae8:	0f be       	out	0x3f, r0	; 63
    6aea:	cd bf       	out	0x3d, r28	; 61
    6aec:	1c 01       	movw	r2, r24
    6aee:	3b 01       	movw	r6, r22
  // check active modem
  uint8_t modem = getActiveModem();
    6af0:	0e 94 ec 18 	call	0x31d8	; 0x31d8 <_ZN6SX127x14getActiveModemEv>
  if (modem == RADIOLIB_SX127X_LORA) {
    6af4:	80 38       	cpi	r24, 0x80	; 128
    6af6:	09 f4       	brne	.+2      	; 0x6afa <_ZN6SX127x12getTimeOnAirEj+0x42>
    6af8:	b7 c0       	rjmp	.+366    	; 0x6c68 <_ZN6SX127x12getTimeOnAirEj+0x1b0>
    // Get number of bits payload
    float n_pay = 8.0 + RADIOLIB_MAX(ceil((8.0 * (float) len - 4.0 * (float) this->spreadingFactor + 28.0 + 16.0 * crc - 20.0 * ih) / (4.0 * (float) this->spreadingFactor - 8.0 * de)) * (float) this->codingRate, 0.0);

    // Get time-on-air in us
    return ceil(symbolLength * (n_pre + n_pay + 4.25)) * 1000;
  } else if(modem == RADIOLIB_SX127X_FSK_OOK) {
    6afa:	81 11       	cpse	r24, r1
    6afc:	f4 c1       	rjmp	.+1000   	; 0x6ee6 <_ZN6SX127x12getTimeOnAirEj+0x42e>
    // Get number of bits preamble
    float n_pre = (float) ((this->mod->SPIgetRegValue(RADIOLIB_SX127X_REG_PREAMBLE_MSB_FSK) << 8) | this->mod->SPIgetRegValue(RADIOLIB_SX127X_REG_PREAMBLE_LSB_FSK)) * 8;
    6afe:	20 e0       	ldi	r18, 0x00	; 0
    6b00:	47 e0       	ldi	r20, 0x07	; 7
    6b02:	65 e2       	ldi	r22, 0x25	; 37
    6b04:	70 e0       	ldi	r23, 0x00	; 0
    6b06:	c1 01       	movw	r24, r2
    6b08:	87 5e       	subi	r24, 0xE7	; 231
    6b0a:	9e 4f       	sbci	r25, 0xFE	; 254
    6b0c:	9e 83       	std	Y+6, r25	; 0x06
    6b0e:	8d 83       	std	Y+5, r24	; 0x05
    6b10:	fc 01       	movw	r30, r24
    6b12:	80 81       	ld	r24, Z
    6b14:	91 81       	ldd	r25, Z+1	; 0x01
    6b16:	0e 94 c0 18 	call	0x3180	; 0x3180 <_ZN6Module14SPIgetRegValueEjhh>
    6b1a:	00 e0       	ldi	r16, 0x00	; 0
    6b1c:	18 2f       	mov	r17, r24
    6b1e:	20 e0       	ldi	r18, 0x00	; 0
    6b20:	47 e0       	ldi	r20, 0x07	; 7
    6b22:	66 e2       	ldi	r22, 0x26	; 38
    6b24:	70 e0       	ldi	r23, 0x00	; 0
    6b26:	ed 81       	ldd	r30, Y+5	; 0x05
    6b28:	fe 81       	ldd	r31, Y+6	; 0x06
    6b2a:	80 81       	ld	r24, Z
    6b2c:	91 81       	ldd	r25, Z+1	; 0x01
    6b2e:	0e 94 c0 18 	call	0x3180	; 0x3180 <_ZN6Module14SPIgetRegValueEjhh>
    6b32:	b8 01       	movw	r22, r16
    6b34:	68 2b       	or	r22, r24
    6b36:	79 2b       	or	r23, r25
    6b38:	07 2e       	mov	r0, r23
    6b3a:	00 0c       	add	r0, r0
    6b3c:	88 0b       	sbc	r24, r24
    6b3e:	99 0b       	sbc	r25, r25
    6b40:	0e 94 78 39 	call	0x72f0	; 0x72f0 <__floatsisf>
    6b44:	20 e0       	ldi	r18, 0x00	; 0
    6b46:	30 e0       	ldi	r19, 0x00	; 0
    6b48:	40 e0       	ldi	r20, 0x00	; 0
    6b4a:	51 e4       	ldi	r21, 0x41	; 65
    6b4c:	0e 94 d7 39 	call	0x73ae	; 0x73ae <__mulsf3>
    6b50:	69 83       	std	Y+1, r22	; 0x01
    6b52:	7a 83       	std	Y+2, r23	; 0x02
    6b54:	8b 83       	std	Y+3, r24	; 0x03
    6b56:	9c 83       	std	Y+4, r25	; 0x04
    //Get the number of bits of the sync word
    float n_syncWord = (float) (this->mod->SPIgetRegValue(RADIOLIB_SX127X_REG_SYNC_CONFIG, 2, 0) + 1) * 8;
    6b58:	20 e0       	ldi	r18, 0x00	; 0
    6b5a:	42 e0       	ldi	r20, 0x02	; 2
    6b5c:	67 e2       	ldi	r22, 0x27	; 39
    6b5e:	70 e0       	ldi	r23, 0x00	; 0
    6b60:	ed 81       	ldd	r30, Y+5	; 0x05
    6b62:	fe 81       	ldd	r31, Y+6	; 0x06
    6b64:	80 81       	ld	r24, Z
    6b66:	91 81       	ldd	r25, Z+1	; 0x01
    6b68:	0e 94 c0 18 	call	0x3180	; 0x3180 <_ZN6Module14SPIgetRegValueEjhh>
    6b6c:	01 96       	adiw	r24, 0x01	; 1
    6b6e:	bc 01       	movw	r22, r24
    6b70:	99 0f       	add	r25, r25
    6b72:	88 0b       	sbc	r24, r24
    6b74:	99 0b       	sbc	r25, r25
    6b76:	0e 94 78 39 	call	0x72f0	; 0x72f0 <__floatsisf>
    6b7a:	20 e0       	ldi	r18, 0x00	; 0
    6b7c:	30 e0       	ldi	r19, 0x00	; 0
    6b7e:	40 e0       	ldi	r20, 0x00	; 0
    6b80:	51 e4       	ldi	r21, 0x41	; 65
    6b82:	0e 94 d7 39 	call	0x73ae	; 0x73ae <__mulsf3>
    6b86:	4b 01       	movw	r8, r22
    6b88:	5c 01       	movw	r10, r24
    //Get CRC bits
    float crc = (this->mod->SPIgetRegValue(RADIOLIB_SX127X_REG_PACKET_CONFIG_1, 4, 4) == RADIOLIB_SX127X_CRC_ON) * 16;
    6b8a:	24 e0       	ldi	r18, 0x04	; 4
    6b8c:	44 e0       	ldi	r20, 0x04	; 4
    6b8e:	60 e3       	ldi	r22, 0x30	; 48
    6b90:	70 e0       	ldi	r23, 0x00	; 0
    6b92:	ed 81       	ldd	r30, Y+5	; 0x05
    6b94:	fe 81       	ldd	r31, Y+6	; 0x06
    6b96:	80 81       	ld	r24, Z
    6b98:	91 81       	ldd	r25, Z+1	; 0x01
    6b9a:	0e 94 c0 18 	call	0x3180	; 0x3180 <_ZN6Module14SPIgetRegValueEjhh>
    6b9e:	40 97       	sbiw	r24, 0x10	; 16
    6ba0:	09 f4       	brne	.+2      	; 0x6ba4 <_ZN6SX127x12getTimeOnAirEj+0xec>
    6ba2:	8d c1       	rjmp	.+794    	; 0x6ebe <_ZN6SX127x12getTimeOnAirEj+0x406>
    6ba4:	c1 2c       	mov	r12, r1
    6ba6:	d1 2c       	mov	r13, r1
    6ba8:	76 01       	movw	r14, r12

    if (this->packetLengthConfig == RADIOLIB_SX127X_PACKET_FIXED) {
    6baa:	f1 01       	movw	r30, r2
    6bac:	ed 5c       	subi	r30, 0xCD	; 205
    6bae:	fe 4f       	sbci	r31, 0xFE	; 254
    6bb0:	80 81       	ld	r24, Z
    6bb2:	88 23       	and	r24, r24
    6bb4:	09 f4       	brne	.+2      	; 0x6bb8 <_ZN6SX127x12getTimeOnAirEj+0x100>
    6bb6:	8c c1       	rjmp	.+792    	; 0x6ed0 <_ZN6SX127x12getTimeOnAirEj+0x418>
      //If Packet size fixed -> len = fixed packet length
      len = this->mod->SPIgetRegValue(RADIOLIB_SX127X_REG_PAYLOAD_LENGTH_FSK);
    } else {
      //if packet variable -> Add 1 extra byte for payload length
      len += 1;
    6bb8:	ff ef       	ldi	r31, 0xFF	; 255
    6bba:	6f 1a       	sub	r6, r31
    6bbc:	7f 0a       	sbc	r7, r31
    }

    // Calculate time-on-air in us {[(length in bytes) * (8 bits / 1 byte)] / [(Bit Rate in kbps) * (1000 bps / 1 kbps)]} * (1000000 us in 1 sec)
    return (uint32_t) (((crc + n_syncWord + n_pre + (float) (len * 8)) / (this->bitRate * 1000.0)) * 1000000.0);
    6bbe:	a5 01       	movw	r20, r10
    6bc0:	94 01       	movw	r18, r8
    6bc2:	c7 01       	movw	r24, r14
    6bc4:	b6 01       	movw	r22, r12
    6bc6:	0e 94 6c 3b 	call	0x76d8	; 0x76d8 <__addsf3>
    6bca:	29 81       	ldd	r18, Y+1	; 0x01
    6bcc:	3a 81       	ldd	r19, Y+2	; 0x02
    6bce:	4b 81       	ldd	r20, Y+3	; 0x03
    6bd0:	5c 81       	ldd	r21, Y+4	; 0x04
    6bd2:	0e 94 6c 3b 	call	0x76d8	; 0x76d8 <__addsf3>
    6bd6:	6b 01       	movw	r12, r22
    6bd8:	7c 01       	movw	r14, r24
    6bda:	66 0c       	add	r6, r6
    6bdc:	77 1c       	adc	r7, r7
    6bde:	66 0c       	add	r6, r6
    6be0:	77 1c       	adc	r7, r7
    6be2:	66 0c       	add	r6, r6
    6be4:	77 1c       	adc	r7, r7
    6be6:	b3 01       	movw	r22, r6
    6be8:	90 e0       	ldi	r25, 0x00	; 0
    6bea:	80 e0       	ldi	r24, 0x00	; 0
    6bec:	0e 94 76 39 	call	0x72ec	; 0x72ec <__floatunsisf>
    6bf0:	9b 01       	movw	r18, r22
    6bf2:	ac 01       	movw	r20, r24
    6bf4:	c7 01       	movw	r24, r14
    6bf6:	b6 01       	movw	r22, r12
    6bf8:	0e 94 6c 3b 	call	0x76d8	; 0x76d8 <__addsf3>
    6bfc:	6b 01       	movw	r12, r22
    6bfe:	7c 01       	movw	r14, r24
    6c00:	f1 01       	movw	r30, r2
    6c02:	eb 5d       	subi	r30, 0xDB	; 219
    6c04:	fe 4f       	sbci	r31, 0xFE	; 254
    6c06:	60 81       	ld	r22, Z
    6c08:	71 81       	ldd	r23, Z+1	; 0x01
    6c0a:	82 81       	ldd	r24, Z+2	; 0x02
    6c0c:	93 81       	ldd	r25, Z+3	; 0x03
    6c0e:	20 e0       	ldi	r18, 0x00	; 0
    6c10:	30 e0       	ldi	r19, 0x00	; 0
    6c12:	4a e7       	ldi	r20, 0x7A	; 122
    6c14:	54 e4       	ldi	r21, 0x44	; 68
    6c16:	0e 94 d7 39 	call	0x73ae	; 0x73ae <__mulsf3>
    6c1a:	9b 01       	movw	r18, r22
    6c1c:	ac 01       	movw	r20, r24
    6c1e:	c7 01       	movw	r24, r14
    6c20:	b6 01       	movw	r22, r12
    6c22:	0e 94 ef 3b 	call	0x77de	; 0x77de <__divsf3>
    6c26:	20 e0       	ldi	r18, 0x00	; 0
    6c28:	34 e2       	ldi	r19, 0x24	; 36
    6c2a:	44 e7       	ldi	r20, 0x74	; 116
    6c2c:	59 e4       	ldi	r21, 0x49	; 73
    6c2e:	0e 94 d7 39 	call	0x73ae	; 0x73ae <__mulsf3>
    6c32:	0e 94 61 3c 	call	0x78c2	; 0x78c2 <__fixunssfsi>
  } else {
    return(RADIOLIB_ERR_UNKNOWN);
  }

}
    6c36:	60 96       	adiw	r28, 0x10	; 16
    6c38:	0f b6       	in	r0, 0x3f	; 63
    6c3a:	f8 94       	cli
    6c3c:	de bf       	out	0x3e, r29	; 62
    6c3e:	0f be       	out	0x3f, r0	; 63
    6c40:	cd bf       	out	0x3d, r28	; 61
    6c42:	df 91       	pop	r29
    6c44:	cf 91       	pop	r28
    6c46:	1f 91       	pop	r17
    6c48:	0f 91       	pop	r16
    6c4a:	ff 90       	pop	r15
    6c4c:	ef 90       	pop	r14
    6c4e:	df 90       	pop	r13
    6c50:	cf 90       	pop	r12
    6c52:	bf 90       	pop	r11
    6c54:	af 90       	pop	r10
    6c56:	9f 90       	pop	r9
    6c58:	8f 90       	pop	r8
    6c5a:	7f 90       	pop	r7
    6c5c:	6f 90       	pop	r6
    6c5e:	5f 90       	pop	r5
    6c60:	4f 90       	pop	r4
    6c62:	3f 90       	pop	r3
    6c64:	2f 90       	pop	r2
    6c66:	08 95       	ret
uint32_t SX127x::getTimeOnAir(size_t len) {
  // check active modem
  uint8_t modem = getActiveModem();
  if (modem == RADIOLIB_SX127X_LORA) {
    // Get symbol length in us
    float symbolLength = (float) (uint32_t(1) << this->spreadingFactor) / (float) this->bandwidth;
    6c68:	f1 01       	movw	r30, r2
    6c6a:	ed 5d       	subi	r30, 0xDD	; 221
    6c6c:	fe 4f       	sbci	r31, 0xFE	; 254
    6c6e:	20 81       	ld	r18, Z
    6c70:	61 e0       	ldi	r22, 0x01	; 1
    6c72:	70 e0       	ldi	r23, 0x00	; 0
    6c74:	80 e0       	ldi	r24, 0x00	; 0
    6c76:	90 e0       	ldi	r25, 0x00	; 0
    6c78:	04 c0       	rjmp	.+8      	; 0x6c82 <_ZN6SX127x12getTimeOnAirEj+0x1ca>
    6c7a:	66 0f       	add	r22, r22
    6c7c:	77 1f       	adc	r23, r23
    6c7e:	88 1f       	adc	r24, r24
    6c80:	99 1f       	adc	r25, r25
    6c82:	2a 95       	dec	r18
    6c84:	d2 f7       	brpl	.-12     	; 0x6c7a <_ZN6SX127x12getTimeOnAirEj+0x1c2>
    6c86:	0e 94 76 39 	call	0x72ec	; 0x72ec <__floatunsisf>
    6c8a:	f1 01       	movw	r30, r2
    6c8c:	e1 5e       	subi	r30, 0xE1	; 225
    6c8e:	fe 4f       	sbci	r31, 0xFE	; 254
    6c90:	20 81       	ld	r18, Z
    6c92:	31 81       	ldd	r19, Z+1	; 0x01
    6c94:	42 81       	ldd	r20, Z+2	; 0x02
    6c96:	53 81       	ldd	r21, Z+3	; 0x03
    6c98:	0e 94 ef 3b 	call	0x77de	; 0x77de <__divsf3>
    6c9c:	69 83       	std	Y+1, r22	; 0x01
    6c9e:	7a 83       	std	Y+2, r23	; 0x02
    6ca0:	8b 83       	std	Y+3, r24	; 0x03
    6ca2:	9c 83       	std	Y+4, r25	; 0x04
    // Get Low Data Rate optimization flag
    float de = 0;
    if (symbolLength >= 16.0) {
    6ca4:	20 e0       	ldi	r18, 0x00	; 0
    6ca6:	30 e0       	ldi	r19, 0x00	; 0
    6ca8:	40 e8       	ldi	r20, 0x80	; 128
    6caa:	51 e4       	ldi	r21, 0x41	; 65
    6cac:	0e 94 d1 3c 	call	0x79a2	; 0x79a2 <__gesf2>
    6cb0:	88 23       	and	r24, r24
    6cb2:	0c f0       	brlt	.+2      	; 0x6cb6 <_ZN6SX127x12getTimeOnAirEj+0x1fe>
    6cb4:	f6 c0       	rjmp	.+492    	; 0x6ea2 <_ZN6SX127x12getTimeOnAirEj+0x3ea>
  uint8_t modem = getActiveModem();
  if (modem == RADIOLIB_SX127X_LORA) {
    // Get symbol length in us
    float symbolLength = (float) (uint32_t(1) << this->spreadingFactor) / (float) this->bandwidth;
    // Get Low Data Rate optimization flag
    float de = 0;
    6cb6:	c1 2c       	mov	r12, r1
    6cb8:	d1 2c       	mov	r13, r1
    6cba:	76 01       	movw	r14, r12
    if (symbolLength >= 16.0) {
      de = 1;
    }
    // Get explicit/implicit header enabled flag
    float ih = (float) this->mod->SPIgetRegValue(RADIOLIB_SX127X_REG_MODEM_CONFIG_1, 0, 0);
    6cbc:	c1 01       	movw	r24, r2
    6cbe:	87 5e       	subi	r24, 0xE7	; 231
    6cc0:	9e 4f       	sbci	r25, 0xFE	; 254
    6cc2:	9e 83       	std	Y+6, r25	; 0x06
    6cc4:	8d 83       	std	Y+5, r24	; 0x05
    6cc6:	20 e0       	ldi	r18, 0x00	; 0
    6cc8:	40 e0       	ldi	r20, 0x00	; 0
    6cca:	6d e1       	ldi	r22, 0x1D	; 29
    6ccc:	70 e0       	ldi	r23, 0x00	; 0
    6cce:	fc 01       	movw	r30, r24
    6cd0:	80 81       	ld	r24, Z
    6cd2:	91 81       	ldd	r25, Z+1	; 0x01
    6cd4:	0e 94 c0 18 	call	0x3180	; 0x3180 <_ZN6Module14SPIgetRegValueEjhh>
    6cd8:	bc 01       	movw	r22, r24
    6cda:	99 0f       	add	r25, r25
    6cdc:	88 0b       	sbc	r24, r24
    6cde:	99 0b       	sbc	r25, r25
    6ce0:	0e 94 78 39 	call	0x72f0	; 0x72f0 <__floatsisf>
    6ce4:	6d 87       	std	Y+13, r22	; 0x0d
    6ce6:	7e 87       	std	Y+14, r23	; 0x0e
    6ce8:	8f 87       	std	Y+15, r24	; 0x0f
    6cea:	98 8b       	std	Y+16, r25	; 0x10
    // Get CRC enabled flag
    float crc = (float) (this->mod->SPIgetRegValue(RADIOLIB_SX127X_REG_MODEM_CONFIG_2, 2, 2) >> 2);
    6cec:	22 e0       	ldi	r18, 0x02	; 2
    6cee:	42 e0       	ldi	r20, 0x02	; 2
    6cf0:	6e e1       	ldi	r22, 0x1E	; 30
    6cf2:	70 e0       	ldi	r23, 0x00	; 0
    6cf4:	ed 81       	ldd	r30, Y+5	; 0x05
    6cf6:	fe 81       	ldd	r31, Y+6	; 0x06
    6cf8:	80 81       	ld	r24, Z
    6cfa:	91 81       	ldd	r25, Z+1	; 0x01
    6cfc:	0e 94 c0 18 	call	0x3180	; 0x3180 <_ZN6Module14SPIgetRegValueEjhh>
    6d00:	95 95       	asr	r25
    6d02:	87 95       	ror	r24
    6d04:	95 95       	asr	r25
    6d06:	87 95       	ror	r24
    6d08:	bc 01       	movw	r22, r24
    6d0a:	99 0f       	add	r25, r25
    6d0c:	88 0b       	sbc	r24, r24
    6d0e:	99 0b       	sbc	r25, r25
    6d10:	0e 94 78 39 	call	0x72f0	; 0x72f0 <__floatsisf>
    6d14:	4b 01       	movw	r8, r22
    6d16:	5c 01       	movw	r10, r24
    // Get number of bits preamble
    float n_pre = (float) ((this->mod->SPIgetRegValue(RADIOLIB_SX127X_REG_PREAMBLE_MSB) << 8) | this->mod->SPIgetRegValue(RADIOLIB_SX127X_REG_PREAMBLE_LSB));
    6d18:	20 e0       	ldi	r18, 0x00	; 0
    6d1a:	47 e0       	ldi	r20, 0x07	; 7
    6d1c:	60 e2       	ldi	r22, 0x20	; 32
    6d1e:	70 e0       	ldi	r23, 0x00	; 0
    6d20:	ed 81       	ldd	r30, Y+5	; 0x05
    6d22:	fe 81       	ldd	r31, Y+6	; 0x06
    6d24:	80 81       	ld	r24, Z
    6d26:	91 81       	ldd	r25, Z+1	; 0x01
    6d28:	0e 94 c0 18 	call	0x3180	; 0x3180 <_ZN6Module14SPIgetRegValueEjhh>
    6d2c:	00 e0       	ldi	r16, 0x00	; 0
    6d2e:	18 2f       	mov	r17, r24
    6d30:	20 e0       	ldi	r18, 0x00	; 0
    6d32:	47 e0       	ldi	r20, 0x07	; 7
    6d34:	61 e2       	ldi	r22, 0x21	; 33
    6d36:	70 e0       	ldi	r23, 0x00	; 0
    6d38:	ed 81       	ldd	r30, Y+5	; 0x05
    6d3a:	fe 81       	ldd	r31, Y+6	; 0x06
    6d3c:	80 81       	ld	r24, Z
    6d3e:	91 81       	ldd	r25, Z+1	; 0x01
    6d40:	0e 94 c0 18 	call	0x3180	; 0x3180 <_ZN6Module14SPIgetRegValueEjhh>
    6d44:	80 2b       	or	r24, r16
    6d46:	91 2b       	or	r25, r17
    6d48:	bc 01       	movw	r22, r24
    6d4a:	99 0f       	add	r25, r25
    6d4c:	88 0b       	sbc	r24, r24
    6d4e:	99 0b       	sbc	r25, r25
    6d50:	0e 94 78 39 	call	0x72f0	; 0x72f0 <__floatsisf>
    6d54:	69 87       	std	Y+9, r22	; 0x09
    6d56:	7a 87       	std	Y+10, r23	; 0x0a
    6d58:	8b 87       	std	Y+11, r24	; 0x0b
    6d5a:	9c 87       	std	Y+12, r25	; 0x0c
    // Get number of bits payload
    float n_pay = 8.0 + RADIOLIB_MAX(ceil((8.0 * (float) len - 4.0 * (float) this->spreadingFactor + 28.0 + 16.0 * crc - 20.0 * ih) / (4.0 * (float) this->spreadingFactor - 8.0 * de)) * (float) this->codingRate, 0.0);
    6d5c:	f1 01       	movw	r30, r2
    6d5e:	ed 5d       	subi	r30, 0xDD	; 221
    6d60:	fe 4f       	sbci	r31, 0xFE	; 254
    6d62:	60 81       	ld	r22, Z
    6d64:	70 e0       	ldi	r23, 0x00	; 0
    6d66:	90 e0       	ldi	r25, 0x00	; 0
    6d68:	80 e0       	ldi	r24, 0x00	; 0
    6d6a:	0e 94 76 39 	call	0x72ec	; 0x72ec <__floatunsisf>
    6d6e:	20 e0       	ldi	r18, 0x00	; 0
    6d70:	30 e0       	ldi	r19, 0x00	; 0
    6d72:	40 e8       	ldi	r20, 0x80	; 128
    6d74:	50 e4       	ldi	r21, 0x40	; 64
    6d76:	0e 94 d7 39 	call	0x73ae	; 0x73ae <__mulsf3>
    6d7a:	6d 83       	std	Y+5, r22	; 0x05
    6d7c:	7e 83       	std	Y+6, r23	; 0x06
    6d7e:	8f 83       	std	Y+7, r24	; 0x07
    6d80:	98 87       	std	Y+8, r25	; 0x08
    6d82:	b3 01       	movw	r22, r6
    6d84:	90 e0       	ldi	r25, 0x00	; 0
    6d86:	80 e0       	ldi	r24, 0x00	; 0
    6d88:	0e 94 76 39 	call	0x72ec	; 0x72ec <__floatunsisf>
    6d8c:	20 e0       	ldi	r18, 0x00	; 0
    6d8e:	30 e0       	ldi	r19, 0x00	; 0
    6d90:	40 e0       	ldi	r20, 0x00	; 0
    6d92:	51 e4       	ldi	r21, 0x41	; 65
    6d94:	0e 94 d7 39 	call	0x73ae	; 0x73ae <__mulsf3>
    6d98:	2d 81       	ldd	r18, Y+5	; 0x05
    6d9a:	3e 81       	ldd	r19, Y+6	; 0x06
    6d9c:	4f 81       	ldd	r20, Y+7	; 0x07
    6d9e:	58 85       	ldd	r21, Y+8	; 0x08
    6da0:	0e 94 6b 3b 	call	0x76d6	; 0x76d6 <__subsf3>
    6da4:	20 e0       	ldi	r18, 0x00	; 0
    6da6:	30 e0       	ldi	r19, 0x00	; 0
    6da8:	40 ee       	ldi	r20, 0xE0	; 224
    6daa:	51 e4       	ldi	r21, 0x41	; 65
    6dac:	0e 94 6c 3b 	call	0x76d8	; 0x76d8 <__addsf3>
    6db0:	2b 01       	movw	r4, r22
    6db2:	3c 01       	movw	r6, r24
    6db4:	20 e0       	ldi	r18, 0x00	; 0
    6db6:	30 e0       	ldi	r19, 0x00	; 0
    6db8:	40 e8       	ldi	r20, 0x80	; 128
    6dba:	51 e4       	ldi	r21, 0x41	; 65
    6dbc:	c5 01       	movw	r24, r10
    6dbe:	b4 01       	movw	r22, r8
    6dc0:	0e 94 d7 39 	call	0x73ae	; 0x73ae <__mulsf3>
    6dc4:	9b 01       	movw	r18, r22
    6dc6:	ac 01       	movw	r20, r24
    6dc8:	c3 01       	movw	r24, r6
    6dca:	b2 01       	movw	r22, r4
    6dcc:	0e 94 6c 3b 	call	0x76d8	; 0x76d8 <__addsf3>
    6dd0:	4b 01       	movw	r8, r22
    6dd2:	5c 01       	movw	r10, r24
    6dd4:	20 e0       	ldi	r18, 0x00	; 0
    6dd6:	30 e0       	ldi	r19, 0x00	; 0
    6dd8:	40 ea       	ldi	r20, 0xA0	; 160
    6dda:	51 e4       	ldi	r21, 0x41	; 65
    6ddc:	6d 85       	ldd	r22, Y+13	; 0x0d
    6dde:	7e 85       	ldd	r23, Y+14	; 0x0e
    6de0:	8f 85       	ldd	r24, Y+15	; 0x0f
    6de2:	98 89       	ldd	r25, Y+16	; 0x10
    6de4:	0e 94 d7 39 	call	0x73ae	; 0x73ae <__mulsf3>
    6de8:	9b 01       	movw	r18, r22
    6dea:	ac 01       	movw	r20, r24
    6dec:	c5 01       	movw	r24, r10
    6dee:	b4 01       	movw	r22, r8
    6df0:	0e 94 6b 3b 	call	0x76d6	; 0x76d6 <__subsf3>
    6df4:	4b 01       	movw	r8, r22
    6df6:	5c 01       	movw	r10, r24
    6df8:	20 e0       	ldi	r18, 0x00	; 0
    6dfa:	30 e0       	ldi	r19, 0x00	; 0
    6dfc:	40 e0       	ldi	r20, 0x00	; 0
    6dfe:	51 e4       	ldi	r21, 0x41	; 65
    6e00:	c7 01       	movw	r24, r14
    6e02:	b6 01       	movw	r22, r12
    6e04:	0e 94 d7 39 	call	0x73ae	; 0x73ae <__mulsf3>
    6e08:	9b 01       	movw	r18, r22
    6e0a:	ac 01       	movw	r20, r24
    6e0c:	6d 81       	ldd	r22, Y+5	; 0x05
    6e0e:	7e 81       	ldd	r23, Y+6	; 0x06
    6e10:	8f 81       	ldd	r24, Y+7	; 0x07
    6e12:	98 85       	ldd	r25, Y+8	; 0x08
    6e14:	0e 94 6b 3b 	call	0x76d6	; 0x76d6 <__subsf3>
    6e18:	9b 01       	movw	r18, r22
    6e1a:	ac 01       	movw	r20, r24
    6e1c:	c5 01       	movw	r24, r10
    6e1e:	b4 01       	movw	r22, r8
    6e20:	0e 94 ef 3b 	call	0x77de	; 0x77de <__divsf3>
    6e24:	0e 94 d8 3b 	call	0x77b0	; 0x77b0 <ceil>
    6e28:	6b 01       	movw	r12, r22
    6e2a:	7c 01       	movw	r14, r24
    6e2c:	f1 01       	movw	r30, r2
    6e2e:	ec 5d       	subi	r30, 0xDC	; 220
    6e30:	fe 4f       	sbci	r31, 0xFE	; 254
    6e32:	60 81       	ld	r22, Z
    6e34:	70 e0       	ldi	r23, 0x00	; 0
    6e36:	90 e0       	ldi	r25, 0x00	; 0
    6e38:	80 e0       	ldi	r24, 0x00	; 0
    6e3a:	0e 94 76 39 	call	0x72ec	; 0x72ec <__floatunsisf>
    6e3e:	a7 01       	movw	r20, r14
    6e40:	96 01       	movw	r18, r12
    6e42:	0e 94 d7 39 	call	0x73ae	; 0x73ae <__mulsf3>
    6e46:	6b 01       	movw	r12, r22
    6e48:	7c 01       	movw	r14, r24
    6e4a:	20 e0       	ldi	r18, 0x00	; 0
    6e4c:	30 e0       	ldi	r19, 0x00	; 0
    6e4e:	a9 01       	movw	r20, r18
    6e50:	0e 94 d1 3c 	call	0x79a2	; 0x79a2 <__gesf2>
    6e54:	18 16       	cp	r1, r24
    6e56:	74 f5       	brge	.+92     	; 0x6eb4 <_ZN6SX127x12getTimeOnAirEj+0x3fc>
    6e58:	20 e0       	ldi	r18, 0x00	; 0
    6e5a:	30 e0       	ldi	r19, 0x00	; 0
    6e5c:	40 e0       	ldi	r20, 0x00	; 0
    6e5e:	51 e4       	ldi	r21, 0x41	; 65
    6e60:	c7 01       	movw	r24, r14
    6e62:	b6 01       	movw	r22, r12
    6e64:	0e 94 6c 3b 	call	0x76d8	; 0x76d8 <__addsf3>

    // Get time-on-air in us
    return ceil(symbolLength * (n_pre + n_pay + 4.25)) * 1000;
    6e68:	29 85       	ldd	r18, Y+9	; 0x09
    6e6a:	3a 85       	ldd	r19, Y+10	; 0x0a
    6e6c:	4b 85       	ldd	r20, Y+11	; 0x0b
    6e6e:	5c 85       	ldd	r21, Y+12	; 0x0c
    6e70:	0e 94 6c 3b 	call	0x76d8	; 0x76d8 <__addsf3>
    6e74:	20 e0       	ldi	r18, 0x00	; 0
    6e76:	30 e0       	ldi	r19, 0x00	; 0
    6e78:	48 e8       	ldi	r20, 0x88	; 136
    6e7a:	50 e4       	ldi	r21, 0x40	; 64
    6e7c:	0e 94 6c 3b 	call	0x76d8	; 0x76d8 <__addsf3>
    6e80:	29 81       	ldd	r18, Y+1	; 0x01
    6e82:	3a 81       	ldd	r19, Y+2	; 0x02
    6e84:	4b 81       	ldd	r20, Y+3	; 0x03
    6e86:	5c 81       	ldd	r21, Y+4	; 0x04
    6e88:	0e 94 d7 39 	call	0x73ae	; 0x73ae <__mulsf3>
    6e8c:	0e 94 d8 3b 	call	0x77b0	; 0x77b0 <ceil>
    6e90:	20 e0       	ldi	r18, 0x00	; 0
    6e92:	30 e0       	ldi	r19, 0x00	; 0
    6e94:	4a e7       	ldi	r20, 0x7A	; 122
    6e96:	54 e4       	ldi	r21, 0x44	; 68
    6e98:	0e 94 d7 39 	call	0x73ae	; 0x73ae <__mulsf3>
    6e9c:	0e 94 61 3c 	call	0x78c2	; 0x78c2 <__fixunssfsi>
    6ea0:	ca ce       	rjmp	.-620    	; 0x6c36 <_ZN6SX127x12getTimeOnAirEj+0x17e>
    // Get symbol length in us
    float symbolLength = (float) (uint32_t(1) << this->spreadingFactor) / (float) this->bandwidth;
    // Get Low Data Rate optimization flag
    float de = 0;
    if (symbolLength >= 16.0) {
      de = 1;
    6ea2:	0f 2e       	mov	r0, r31
    6ea4:	c1 2c       	mov	r12, r1
    6ea6:	d1 2c       	mov	r13, r1
    6ea8:	f0 e8       	ldi	r31, 0x80	; 128
    6eaa:	ef 2e       	mov	r14, r31
    6eac:	ff e3       	ldi	r31, 0x3F	; 63
    6eae:	ff 2e       	mov	r15, r31
    6eb0:	f0 2d       	mov	r31, r0
    6eb2:	04 cf       	rjmp	.-504    	; 0x6cbc <_ZN6SX127x12getTimeOnAirEj+0x204>
    // Get CRC enabled flag
    float crc = (float) (this->mod->SPIgetRegValue(RADIOLIB_SX127X_REG_MODEM_CONFIG_2, 2, 2) >> 2);
    // Get number of bits preamble
    float n_pre = (float) ((this->mod->SPIgetRegValue(RADIOLIB_SX127X_REG_PREAMBLE_MSB) << 8) | this->mod->SPIgetRegValue(RADIOLIB_SX127X_REG_PREAMBLE_LSB));
    // Get number of bits payload
    float n_pay = 8.0 + RADIOLIB_MAX(ceil((8.0 * (float) len - 4.0 * (float) this->spreadingFactor + 28.0 + 16.0 * crc - 20.0 * ih) / (4.0 * (float) this->spreadingFactor - 8.0 * de)) * (float) this->codingRate, 0.0);
    6eb4:	60 e0       	ldi	r22, 0x00	; 0
    6eb6:	70 e0       	ldi	r23, 0x00	; 0
    6eb8:	80 e0       	ldi	r24, 0x00	; 0
    6eba:	91 e4       	ldi	r25, 0x41	; 65
    6ebc:	d5 cf       	rjmp	.-86     	; 0x6e68 <_ZN6SX127x12getTimeOnAirEj+0x3b0>
    // Get number of bits preamble
    float n_pre = (float) ((this->mod->SPIgetRegValue(RADIOLIB_SX127X_REG_PREAMBLE_MSB_FSK) << 8) | this->mod->SPIgetRegValue(RADIOLIB_SX127X_REG_PREAMBLE_LSB_FSK)) * 8;
    //Get the number of bits of the sync word
    float n_syncWord = (float) (this->mod->SPIgetRegValue(RADIOLIB_SX127X_REG_SYNC_CONFIG, 2, 0) + 1) * 8;
    //Get CRC bits
    float crc = (this->mod->SPIgetRegValue(RADIOLIB_SX127X_REG_PACKET_CONFIG_1, 4, 4) == RADIOLIB_SX127X_CRC_ON) * 16;
    6ebe:	0f 2e       	mov	r0, r31
    6ec0:	c1 2c       	mov	r12, r1
    6ec2:	d1 2c       	mov	r13, r1
    6ec4:	f0 e8       	ldi	r31, 0x80	; 128
    6ec6:	ef 2e       	mov	r14, r31
    6ec8:	f1 e4       	ldi	r31, 0x41	; 65
    6eca:	ff 2e       	mov	r15, r31
    6ecc:	f0 2d       	mov	r31, r0
    6ece:	6d ce       	rjmp	.-806    	; 0x6baa <_ZN6SX127x12getTimeOnAirEj+0xf2>

    if (this->packetLengthConfig == RADIOLIB_SX127X_PACKET_FIXED) {
      //If Packet size fixed -> len = fixed packet length
      len = this->mod->SPIgetRegValue(RADIOLIB_SX127X_REG_PAYLOAD_LENGTH_FSK);
    6ed0:	20 e0       	ldi	r18, 0x00	; 0
    6ed2:	47 e0       	ldi	r20, 0x07	; 7
    6ed4:	62 e3       	ldi	r22, 0x32	; 50
    6ed6:	70 e0       	ldi	r23, 0x00	; 0
    6ed8:	7a 97       	sbiw	r30, 0x1a	; 26
    6eda:	80 81       	ld	r24, Z
    6edc:	91 81       	ldd	r25, Z+1	; 0x01
    6ede:	0e 94 c0 18 	call	0x3180	; 0x3180 <_ZN6Module14SPIgetRegValueEjhh>
    6ee2:	3c 01       	movw	r6, r24
    6ee4:	6c ce       	rjmp	.-808    	; 0x6bbe <_ZN6SX127x12getTimeOnAirEj+0x106>
    }

    // Calculate time-on-air in us {[(length in bytes) * (8 bits / 1 byte)] / [(Bit Rate in kbps) * (1000 bps / 1 kbps)]} * (1000000 us in 1 sec)
    return (uint32_t) (((crc + n_syncWord + n_pre + (float) (len * 8)) / (this->bitRate * 1000.0)) * 1000000.0);
  } else {
    return(RADIOLIB_ERR_UNKNOWN);
    6ee6:	6f ef       	ldi	r22, 0xFF	; 255
    6ee8:	7f ef       	ldi	r23, 0xFF	; 255
    6eea:	cb 01       	movw	r24, r22
    6eec:	a4 ce       	rjmp	.-696    	; 0x6c36 <_ZN6SX127x12getTimeOnAirEj+0x17e>

00006eee <_GLOBAL__I_65535_0_Message.cpp.o.3952>:
    6eee:	6f ef       	ldi	r22, 0xFF	; 255
    6ef0:	7f ef       	ldi	r23, 0xFF	; 255
    6ef2:	81 e0       	ldi	r24, 0x01	; 1
    6ef4:	90 e0       	ldi	r25, 0x00	; 0
    6ef6:	0e 94 40 05 	call	0xa80	; 0xa80 <_Z41__static_initialization_and_destruction_0ii.lto_priv.1>
    6efa:	6f ef       	ldi	r22, 0xFF	; 255
    6efc:	7f ef       	ldi	r23, 0xFF	; 255
    6efe:	81 e0       	ldi	r24, 0x01	; 1
    6f00:	90 e0       	ldi	r25, 0x00	; 0
    6f02:	0e 94 dd 0d 	call	0x1bba	; 0x1bba <_Z41__static_initialization_and_destruction_0ii.lto_priv.0>
    6f06:	08 95       	ret

00006f08 <__vector_16>:
#if defined(TIM0_OVF_vect)
ISR(TIM0_OVF_vect)
#else
ISR(TIMER0_OVF_vect)
#endif
{
    6f08:	1f 92       	push	r1
    6f0a:	0f 92       	push	r0
    6f0c:	0f b6       	in	r0, 0x3f	; 63
    6f0e:	0f 92       	push	r0
    6f10:	11 24       	eor	r1, r1
    6f12:	0f 93       	push	r16
    6f14:	1f 93       	push	r17
    6f16:	2f 93       	push	r18
    6f18:	3f 93       	push	r19
    6f1a:	4f 93       	push	r20
    6f1c:	5f 93       	push	r21
    6f1e:	6f 93       	push	r22
    6f20:	7f 93       	push	r23
    6f22:	8f 93       	push	r24
    6f24:	9f 93       	push	r25
    6f26:	af 93       	push	r26
    6f28:	bf 93       	push	r27
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
    6f2a:	00 91 8f 07 	lds	r16, 0x078F	; 0x80078f <timer0_millis>
    6f2e:	10 91 90 07 	lds	r17, 0x0790	; 0x800790 <timer0_millis+0x1>
    6f32:	20 91 91 07 	lds	r18, 0x0791	; 0x800791 <timer0_millis+0x2>
    6f36:	30 91 92 07 	lds	r19, 0x0792	; 0x800792 <timer0_millis+0x3>
	unsigned char f = timer0_fract;
    6f3a:	90 91 8e 07 	lds	r25, 0x078E	; 0x80078e <timer0_fract>

	m += MILLIS_INC;
    6f3e:	b9 01       	movw	r22, r18
    6f40:	a8 01       	movw	r20, r16
    6f42:	4f 5f       	subi	r20, 0xFF	; 255
    6f44:	5f 4f       	sbci	r21, 0xFF	; 255
    6f46:	6f 4f       	sbci	r22, 0xFF	; 255
    6f48:	7f 4f       	sbci	r23, 0xFF	; 255
	f += FRACT_INC;
    6f4a:	83 e0       	ldi	r24, 0x03	; 3
    6f4c:	89 0f       	add	r24, r25
	if (f >= FRACT_MAX) {
    6f4e:	8d 37       	cpi	r24, 0x7D	; 125
    6f50:	40 f0       	brcs	.+16     	; 0x6f62 <__vector_16+0x5a>
		f -= FRACT_MAX;
    6f52:	86 e8       	ldi	r24, 0x86	; 134
    6f54:	89 0f       	add	r24, r25
		m += 1;
    6f56:	b9 01       	movw	r22, r18
    6f58:	a8 01       	movw	r20, r16
    6f5a:	4e 5f       	subi	r20, 0xFE	; 254
    6f5c:	5f 4f       	sbci	r21, 0xFF	; 255
    6f5e:	6f 4f       	sbci	r22, 0xFF	; 255
    6f60:	7f 4f       	sbci	r23, 0xFF	; 255
	}

	timer0_fract = f;
    6f62:	80 93 8e 07 	sts	0x078E, r24	; 0x80078e <timer0_fract>
	timer0_millis = m;
    6f66:	40 93 8f 07 	sts	0x078F, r20	; 0x80078f <timer0_millis>
    6f6a:	50 93 90 07 	sts	0x0790, r21	; 0x800790 <timer0_millis+0x1>
    6f6e:	60 93 91 07 	sts	0x0791, r22	; 0x800791 <timer0_millis+0x2>
    6f72:	70 93 92 07 	sts	0x0792, r23	; 0x800792 <timer0_millis+0x3>
	timer0_overflow_count++;
    6f76:	80 91 93 07 	lds	r24, 0x0793	; 0x800793 <timer0_overflow_count>
    6f7a:	90 91 94 07 	lds	r25, 0x0794	; 0x800794 <timer0_overflow_count+0x1>
    6f7e:	a0 91 95 07 	lds	r26, 0x0795	; 0x800795 <timer0_overflow_count+0x2>
    6f82:	b0 91 96 07 	lds	r27, 0x0796	; 0x800796 <timer0_overflow_count+0x3>
    6f86:	01 96       	adiw	r24, 0x01	; 1
    6f88:	a1 1d       	adc	r26, r1
    6f8a:	b1 1d       	adc	r27, r1
    6f8c:	80 93 93 07 	sts	0x0793, r24	; 0x800793 <timer0_overflow_count>
    6f90:	90 93 94 07 	sts	0x0794, r25	; 0x800794 <timer0_overflow_count+0x1>
    6f94:	a0 93 95 07 	sts	0x0795, r26	; 0x800795 <timer0_overflow_count+0x2>
    6f98:	b0 93 96 07 	sts	0x0796, r27	; 0x800796 <timer0_overflow_count+0x3>
}
    6f9c:	bf 91       	pop	r27
    6f9e:	af 91       	pop	r26
    6fa0:	9f 91       	pop	r25
    6fa2:	8f 91       	pop	r24
    6fa4:	7f 91       	pop	r23
    6fa6:	6f 91       	pop	r22
    6fa8:	5f 91       	pop	r21
    6faa:	4f 91       	pop	r20
    6fac:	3f 91       	pop	r19
    6fae:	2f 91       	pop	r18
    6fb0:	1f 91       	pop	r17
    6fb2:	0f 91       	pop	r16
    6fb4:	0f 90       	pop	r0
    6fb6:	0f be       	out	0x3f, r0	; 63
    6fb8:	0f 90       	pop	r0
    6fba:	1f 90       	pop	r1
    6fbc:	18 95       	reti

00006fbe <main>:
void setupUSB() __attribute__((weak));
void setupUSB() { }

int main(void)
{
	init();
    6fbe:	0e 94 a6 01 	call	0x34c	; 0x34c <init>

#if defined(USBCON)
	USBDevice.attach();
#endif
	
	setup();
    6fc2:	0e 94 d6 2a 	call	0x55ac	; 0x55ac <setup>
    
	for (;;) {
		loop();
    6fc6:	0e 94 4c 32 	call	0x6498	; 0x6498 <loop>
		if (serialEventRun) serialEventRun();
    6fca:	0e 94 ae 06 	call	0xd5c	; 0xd5c <_Z14serialEventRunv>
    6fce:	fb cf       	rjmp	.-10     	; 0x6fc6 <main+0x8>

00006fd0 <__vector_2>:
IMPLEMENT_ISR(INT7_vect, EXTERNAL_INT_7)

#else

IMPLEMENT_ISR(INT0_vect, EXTERNAL_INT_0)
IMPLEMENT_ISR(INT1_vect, EXTERNAL_INT_1)
    6fd0:	1f 92       	push	r1
    6fd2:	0f 92       	push	r0
    6fd4:	0f b6       	in	r0, 0x3f	; 63
    6fd6:	0f 92       	push	r0
    6fd8:	11 24       	eor	r1, r1
    6fda:	2f 93       	push	r18
    6fdc:	3f 93       	push	r19
    6fde:	4f 93       	push	r20
    6fe0:	5f 93       	push	r21
    6fe2:	6f 93       	push	r22
    6fe4:	7f 93       	push	r23
    6fe6:	8f 93       	push	r24
    6fe8:	9f 93       	push	r25
    6fea:	af 93       	push	r26
    6fec:	bf 93       	push	r27
    6fee:	ef 93       	push	r30
    6ff0:	ff 93       	push	r31
    6ff2:	e0 91 03 01 	lds	r30, 0x0103	; 0x800103 <intFunc+0x2>
    6ff6:	f0 91 04 01 	lds	r31, 0x0104	; 0x800104 <intFunc+0x3>
    6ffa:	09 95       	icall
    6ffc:	ff 91       	pop	r31
    6ffe:	ef 91       	pop	r30
    7000:	bf 91       	pop	r27
    7002:	af 91       	pop	r26
    7004:	9f 91       	pop	r25
    7006:	8f 91       	pop	r24
    7008:	7f 91       	pop	r23
    700a:	6f 91       	pop	r22
    700c:	5f 91       	pop	r21
    700e:	4f 91       	pop	r20
    7010:	3f 91       	pop	r19
    7012:	2f 91       	pop	r18
    7014:	0f 90       	pop	r0
    7016:	0f be       	out	0x3f, r0	; 63
    7018:	0f 90       	pop	r0
    701a:	1f 90       	pop	r1
    701c:	18 95       	reti

0000701e <__vector_1>:
IMPLEMENT_ISR(INT6_vect, EXTERNAL_INT_6)
IMPLEMENT_ISR(INT7_vect, EXTERNAL_INT_7)

#else

IMPLEMENT_ISR(INT0_vect, EXTERNAL_INT_0)
    701e:	1f 92       	push	r1
    7020:	0f 92       	push	r0
    7022:	0f b6       	in	r0, 0x3f	; 63
    7024:	0f 92       	push	r0
    7026:	11 24       	eor	r1, r1
    7028:	2f 93       	push	r18
    702a:	3f 93       	push	r19
    702c:	4f 93       	push	r20
    702e:	5f 93       	push	r21
    7030:	6f 93       	push	r22
    7032:	7f 93       	push	r23
    7034:	8f 93       	push	r24
    7036:	9f 93       	push	r25
    7038:	af 93       	push	r26
    703a:	bf 93       	push	r27
    703c:	ef 93       	push	r30
    703e:	ff 93       	push	r31
    7040:	e0 91 01 01 	lds	r30, 0x0101	; 0x800101 <intFunc>
    7044:	f0 91 02 01 	lds	r31, 0x0102	; 0x800102 <intFunc+0x1>
    7048:	09 95       	icall
    704a:	ff 91       	pop	r31
    704c:	ef 91       	pop	r30
    704e:	bf 91       	pop	r27
    7050:	af 91       	pop	r26
    7052:	9f 91       	pop	r25
    7054:	8f 91       	pop	r24
    7056:	7f 91       	pop	r23
    7058:	6f 91       	pop	r22
    705a:	5f 91       	pop	r21
    705c:	4f 91       	pop	r20
    705e:	3f 91       	pop	r19
    7060:	2f 91       	pop	r18
    7062:	0f 90       	pop	r0
    7064:	0f be       	out	0x3f, r0	; 63
    7066:	0f 90       	pop	r0
    7068:	1f 90       	pop	r1
    706a:	18 95       	reti

0000706c <__vector_7>:
#endif


#ifdef USE_TIMER2
ISR(TIMER2_COMPA_vect)
{
    706c:	1f 92       	push	r1
    706e:	0f 92       	push	r0
    7070:	0f b6       	in	r0, 0x3f	; 63
    7072:	0f 92       	push	r0
    7074:	11 24       	eor	r1, r1
    7076:	2f 93       	push	r18
    7078:	3f 93       	push	r19
    707a:	4f 93       	push	r20
    707c:	5f 93       	push	r21
    707e:	6f 93       	push	r22
    7080:	7f 93       	push	r23
    7082:	8f 93       	push	r24
    7084:	9f 93       	push	r25
    7086:	af 93       	push	r26
    7088:	bf 93       	push	r27
    708a:	ef 93       	push	r30
    708c:	ff 93       	push	r31

  if (timer2_toggle_count != 0)
    708e:	80 91 8a 07 	lds	r24, 0x078A	; 0x80078a <timer2_toggle_count>
    7092:	90 91 8b 07 	lds	r25, 0x078B	; 0x80078b <timer2_toggle_count+0x1>
    7096:	a0 91 8c 07 	lds	r26, 0x078C	; 0x80078c <timer2_toggle_count+0x2>
    709a:	b0 91 8d 07 	lds	r27, 0x078D	; 0x80078d <timer2_toggle_count+0x3>
    709e:	89 2b       	or	r24, r25
    70a0:	8a 2b       	or	r24, r26
    70a2:	8b 2b       	or	r24, r27
    70a4:	d1 f1       	breq	.+116    	; 0x711a <__vector_7+0xae>
  {
    // toggle the pin
    *timer2_pin_port ^= timer2_pin_mask;
    70a6:	90 91 89 07 	lds	r25, 0x0789	; 0x800789 <timer2_pin_mask>
    70aa:	e0 91 87 07 	lds	r30, 0x0787	; 0x800787 <timer2_pin_port>
    70ae:	f0 91 88 07 	lds	r31, 0x0788	; 0x800788 <timer2_pin_port+0x1>
    70b2:	80 81       	ld	r24, Z
    70b4:	89 27       	eor	r24, r25
    70b6:	80 83       	st	Z, r24

    if (timer2_toggle_count > 0)
    70b8:	80 91 8a 07 	lds	r24, 0x078A	; 0x80078a <timer2_toggle_count>
    70bc:	90 91 8b 07 	lds	r25, 0x078B	; 0x80078b <timer2_toggle_count+0x1>
    70c0:	a0 91 8c 07 	lds	r26, 0x078C	; 0x80078c <timer2_toggle_count+0x2>
    70c4:	b0 91 8d 07 	lds	r27, 0x078D	; 0x80078d <timer2_toggle_count+0x3>
    70c8:	18 16       	cp	r1, r24
    70ca:	19 06       	cpc	r1, r25
    70cc:	1a 06       	cpc	r1, r26
    70ce:	1b 06       	cpc	r1, r27
    70d0:	9c f4       	brge	.+38     	; 0x70f8 <__vector_7+0x8c>
      timer2_toggle_count--;
    70d2:	80 91 8a 07 	lds	r24, 0x078A	; 0x80078a <timer2_toggle_count>
    70d6:	90 91 8b 07 	lds	r25, 0x078B	; 0x80078b <timer2_toggle_count+0x1>
    70da:	a0 91 8c 07 	lds	r26, 0x078C	; 0x80078c <timer2_toggle_count+0x2>
    70de:	b0 91 8d 07 	lds	r27, 0x078D	; 0x80078d <timer2_toggle_count+0x3>
    70e2:	01 97       	sbiw	r24, 0x01	; 1
    70e4:	a1 09       	sbc	r26, r1
    70e6:	b1 09       	sbc	r27, r1
    70e8:	80 93 8a 07 	sts	0x078A, r24	; 0x80078a <timer2_toggle_count>
    70ec:	90 93 8b 07 	sts	0x078B, r25	; 0x80078b <timer2_toggle_count+0x1>
    70f0:	a0 93 8c 07 	sts	0x078C, r26	; 0x80078c <timer2_toggle_count+0x2>
    70f4:	b0 93 8d 07 	sts	0x078D, r27	; 0x80078d <timer2_toggle_count+0x3>
    // XXX: this assumes timer 2 is always the first one used.
    noTone(tone_pins[0]);
//    disableTimer(2);
//    *timer2_pin_port &= ~(timer2_pin_mask);  // keep pin low after stop
  }
}
    70f8:	ff 91       	pop	r31
    70fa:	ef 91       	pop	r30
    70fc:	bf 91       	pop	r27
    70fe:	af 91       	pop	r26
    7100:	9f 91       	pop	r25
    7102:	8f 91       	pop	r24
    7104:	7f 91       	pop	r23
    7106:	6f 91       	pop	r22
    7108:	5f 91       	pop	r21
    710a:	4f 91       	pop	r20
    710c:	3f 91       	pop	r19
    710e:	2f 91       	pop	r18
    7110:	0f 90       	pop	r0
    7112:	0f be       	out	0x3f, r0	; 63
    7114:	0f 90       	pop	r0
    7116:	1f 90       	pop	r1
    7118:	18 95       	reti
  else
  {
    // need to call noTone() so that the tone_pins[] entry is reset, so the
    // timer gets initialized next time we call tone().
    // XXX: this assumes timer 2 is always the first one used.
    noTone(tone_pins[0]);
    711a:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
    711e:	0e 94 be 02 	call	0x57c	; 0x57c <_Z6noToneh>
    7122:	ea cf       	rjmp	.-44     	; 0x70f8 <__vector_7+0x8c>

00007124 <__vector_19>:
#elif defined(USART_UDRE_vect)
ISR(USART_UDRE_vect)
#else
  #error "Don't know what the Data Register Empty vector is called for Serial"
#endif
{
    7124:	1f 92       	push	r1
    7126:	0f 92       	push	r0
    7128:	0f b6       	in	r0, 0x3f	; 63
    712a:	0f 92       	push	r0
    712c:	11 24       	eor	r1, r1
    712e:	2f 93       	push	r18
    7130:	3f 93       	push	r19
    7132:	4f 93       	push	r20
    7134:	5f 93       	push	r21
    7136:	6f 93       	push	r22
    7138:	7f 93       	push	r23
    713a:	8f 93       	push	r24
    713c:	9f 93       	push	r25
    713e:	af 93       	push	r26
    7140:	bf 93       	push	r27
    7142:	ef 93       	push	r30
    7144:	ff 93       	push	r31
  Serial._tx_udr_empty_irq();
    7146:	80 ee       	ldi	r24, 0xE0	; 224
    7148:	96 e0       	ldi	r25, 0x06	; 6
    714a:	0e 94 1f 06 	call	0xc3e	; 0xc3e <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
}
    714e:	ff 91       	pop	r31
    7150:	ef 91       	pop	r30
    7152:	bf 91       	pop	r27
    7154:	af 91       	pop	r26
    7156:	9f 91       	pop	r25
    7158:	8f 91       	pop	r24
    715a:	7f 91       	pop	r23
    715c:	6f 91       	pop	r22
    715e:	5f 91       	pop	r21
    7160:	4f 91       	pop	r20
    7162:	3f 91       	pop	r19
    7164:	2f 91       	pop	r18
    7166:	0f 90       	pop	r0
    7168:	0f be       	out	0x3f, r0	; 63
    716a:	0f 90       	pop	r0
    716c:	1f 90       	pop	r1
    716e:	18 95       	reti

00007170 <__vector_18>:
#elif defined(USART_RXC_vect)
  ISR(USART_RXC_vect) // ATmega8
#else
  #error "Don't know what the Data Received vector is called for Serial"
#endif
  {
    7170:	1f 92       	push	r1
    7172:	0f 92       	push	r0
    7174:	0f b6       	in	r0, 0x3f	; 63
    7176:	0f 92       	push	r0
    7178:	11 24       	eor	r1, r1
    717a:	2f 93       	push	r18
    717c:	8f 93       	push	r24
    717e:	9f 93       	push	r25
    7180:	af 93       	push	r26
    7182:	bf 93       	push	r27
    7184:	ef 93       	push	r30
    7186:	ff 93       	push	r31

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_rx_complete_irq(void)
{
  if (bit_is_clear(*_ucsra, UPE0)) {
    7188:	e0 91 f0 06 	lds	r30, 0x06F0	; 0x8006f0 <Serial+0x10>
    718c:	f0 91 f1 06 	lds	r31, 0x06F1	; 0x8006f1 <Serial+0x11>
    7190:	80 81       	ld	r24, Z
    7192:	82 fd       	sbrc	r24, 2
    7194:	14 c0       	rjmp	.+40     	; 0x71be <__vector_18+0x4e>
    // No Parity error, read byte and store it in the buffer if there is
    // room
    unsigned char c = *_udr;
    7196:	e0 ee       	ldi	r30, 0xE0	; 224
    7198:	f6 e0       	ldi	r31, 0x06	; 6
    719a:	a6 89       	ldd	r26, Z+22	; 0x16
    719c:	b7 89       	ldd	r27, Z+23	; 0x17
    719e:	2c 91       	ld	r18, X
    rx_buffer_index_t i = (unsigned int)(_rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;
    71a0:	81 8d       	ldd	r24, Z+25	; 0x19
    71a2:	8f 5f       	subi	r24, 0xFF	; 255
    71a4:	8f 73       	andi	r24, 0x3F	; 63

    // if we should be storing the received character into the location
    // just before the tail (meaning that the head would advance to the
    // current location of the tail), we're about to overflow the buffer
    // and so we don't write the character or advance the head.
    if (i != _rx_buffer_tail) {
    71a6:	92 8d       	ldd	r25, Z+26	; 0x1a
    71a8:	89 17       	cp	r24, r25
    71aa:	71 f0       	breq	.+28     	; 0x71c8 <__vector_18+0x58>
      _rx_buffer[_rx_buffer_head] = c;
    71ac:	df 01       	movw	r26, r30
    71ae:	e1 8d       	ldd	r30, Z+25	; 0x19
    71b0:	f0 e0       	ldi	r31, 0x00	; 0
    71b2:	e0 52       	subi	r30, 0x20	; 32
    71b4:	f9 4f       	sbci	r31, 0xF9	; 249
    71b6:	25 8f       	std	Z+29, r18	; 0x1d
      _rx_buffer_head = i;
    71b8:	59 96       	adiw	r26, 0x19	; 25
    71ba:	8c 93       	st	X, r24
    71bc:	05 c0       	rjmp	.+10     	; 0x71c8 <__vector_18+0x58>
    }
  } else {
    // Parity error, read byte but discard it
    *_udr;
    71be:	e0 91 f6 06 	lds	r30, 0x06F6	; 0x8006f6 <Serial+0x16>
    71c2:	f0 91 f7 06 	lds	r31, 0x06F7	; 0x8006f7 <Serial+0x17>
    71c6:	80 81       	ld	r24, Z
    Serial._rx_complete_irq();
  }
    71c8:	ff 91       	pop	r31
    71ca:	ef 91       	pop	r30
    71cc:	bf 91       	pop	r27
    71ce:	af 91       	pop	r26
    71d0:	9f 91       	pop	r25
    71d2:	8f 91       	pop	r24
    71d4:	2f 91       	pop	r18
    71d6:	0f 90       	pop	r0
    71d8:	0f be       	out	0x3f, r0	; 63
    71da:	0f 90       	pop	r0
    71dc:	1f 90       	pop	r1
    71de:	18 95       	reti

000071e0 <_GLOBAL__sub_D_radio>:
    71e0:	6f ef       	ldi	r22, 0xFF	; 255
    71e2:	7f ef       	ldi	r23, 0xFF	; 255
    71e4:	90 e0       	ldi	r25, 0x00	; 0
    71e6:	80 e0       	ldi	r24, 0x00	; 0
    71e8:	0e 94 dd 0d 	call	0x1bba	; 0x1bba <_Z41__static_initialization_and_destruction_0ii.lto_priv.0>
    71ec:	08 95       	ret

000071ee <countPulseASM>:

countPulseASM:

.LM0:
.LFBB1:
    push r12   ;   ;  130 pushqi1/1 [length = 1]
    71ee:	cf 92       	push	r12
    push r13   ;   ;  131 pushqi1/1 [length = 1]
    71f0:	df 92       	push	r13
    push r14   ;   ;  132 pushqi1/1 [length = 1]
    71f2:	ef 92       	push	r14
    push r15   ;   ;  133 pushqi1/1 [length = 1]
    71f4:	ff 92       	push	r15
    push r16   ;   ;  134 pushqi1/1 [length = 1]
    71f6:	0f 93       	push	r16
    push r17   ;   ;  135 pushqi1/1 [length = 1]
    71f8:	1f 93       	push	r17
/* prologue: function */
/* frame size = 0 */
/* stack size = 6 */
.L__stack_usage = 6
    mov r30,r24  ;  port, port   ;  2 *movhi/1  [length = 2]
    71fa:	e8 2f       	mov	r30, r24
    mov r31,r25  ;  port, port
    71fc:	f9 2f       	mov	r31, r25
/*     unsigned long width = 0;
***     // wait for any previous pulse to end
***     while ((*port & bit) == stateMask)
*/
.LM1:
    rjmp .L2   ;   ;  181 jump  [length = 1]
    71fe:	05 c0       	rjmp	.+10     	; 0x720a <countPulseASM+0x1c>
.L4:
/*         if (--maxloops == 0) */
.LM2:
    subi r16,1   ;  maxloops,  ;  17  addsi3/2  [length = 4]
    7200:	01 50       	subi	r16, 0x01	; 1
    sbc r17, r1   ;  maxloops
    7202:	11 09       	sbc	r17, r1
    sbc r18, r1   ;  maxloops
    7204:	21 09       	sbc	r18, r1
    sbc r19, r1   ;  maxloops
    7206:	31 09       	sbc	r19, r1
    breq .L13  ; ,   ;  19  branch  [length = 1]
    7208:	61 f1       	breq	.+88     	; 0x7262 <countPulseASM+0x74>
.L2:
/*         if (--maxloops == 0) */
.LM3:
    ld r25,Z   ;  D.1554, *port_7(D)   ;  22  movqi_insn/4  [length = 1]
    720a:	90 81       	ld	r25, Z
    and r25,r22  ;  D.1554, bit  ;  24  andqi3/1  [length = 1]
    720c:	96 23       	and	r25, r22
    cp r25,r20   ;  D.1554, stateMask  ;  25  *cmpqi/2  [length = 1]
    720e:	94 17       	cp	r25, r20
    breq .L4   ; ,   ;  26  branch  [length = 1]
    7210:	b9 f3       	breq	.-18     	; 0x7200 <countPulseASM+0x12>
    rjmp .L6   ;   ;  184 jump  [length = 1]
    7212:	05 c0       	rjmp	.+10     	; 0x721e <countPulseASM+0x30>
***     // wait for the pulse to start
***     while ((*port & bit) != stateMask)
***         if (--maxloops == 0)
*/
.LM4:
    subi r16,1   ;  maxloops,  ;  31  addsi3/2  [length = 4]
    7214:	01 50       	subi	r16, 0x01	; 1
    sbc r17, r1   ;  maxloops
    7216:	11 09       	sbc	r17, r1
    sbc r18, r1   ;  maxloops
    7218:	21 09       	sbc	r18, r1
    sbc r19, r1   ;  maxloops
    721a:	31 09       	sbc	r19, r1
    breq .L13  ; ,   ;  33  branch  [length = 1]
    721c:	11 f1       	breq	.+68     	; 0x7262 <countPulseASM+0x74>
.L6:
/*         if (--maxloops == 0) */
.LM5:
    ld r25,Z   ;  D.1554, *port_7(D)   ;  41  movqi_insn/4  [length = 1]
    721e:	90 81       	ld	r25, Z
    and r25,r22  ;  D.1554, bit  ;  43  andqi3/1  [length = 1]
    7220:	96 23       	and	r25, r22
    cpse r25,r20   ;  D.1554, stateMask  ;  44  enable_interrupt-3  [length = 1]
    7222:	94 13       	cpse	r25, r20
    rjmp .L7   ;
    7224:	f7 cf       	rjmp	.-18     	; 0x7214 <countPulseASM+0x26>
    mov r12, r1   ;  width  ;  7 *movsi/2  [length = 4]
    7226:	c1 2c       	mov	r12, r1
    mov r13, r1   ;  width
    7228:	d1 2c       	mov	r13, r1
    mov r14, r1   ;  width
    722a:	e1 2c       	mov	r14, r1
    mov r15, r1   ;  width
    722c:	f1 2c       	mov	r15, r1
    rjmp .L9   ;   ;  186 jump  [length = 1]
    722e:	0a c0       	rjmp	.+20     	; 0x7244 <countPulseASM+0x56>
***     // wait for the pulse to stop
***     while ((*port & bit) == stateMask) {
***         if (++width == maxloops)
*/
.LM6:
    ldi r24,-1   ; ,   ;  50  addsi3/3  [length = 5]
    7230:	8f ef       	ldi	r24, 0xFF	; 255
    sub r12,r24  ;  width,
    7232:	c8 1a       	sub	r12, r24
    sbc r13,r24  ;  width,
    7234:	d8 0a       	sbc	r13, r24
    sbc r14,r24  ;  width,
    7236:	e8 0a       	sbc	r14, r24
    sbc r15,r24  ;  width,
    7238:	f8 0a       	sbc	r15, r24
    cp r16,r12   ;  maxloops, width  ;  51  *cmpsi/2  [length = 4]
    723a:	0c 15       	cp	r16, r12
    cpc r17,r13  ;  maxloops, width
    723c:	1d 05       	cpc	r17, r13
    cpc r18,r14  ;  maxloops, width
    723e:	2e 05       	cpc	r18, r14
    cpc r19,r15  ;  maxloops, width
    7240:	3f 05       	cpc	r19, r15
    breq .L13  ; ,   ;  52  branch  [length = 1]
    7242:	79 f0       	breq	.+30     	; 0x7262 <countPulseASM+0x74>
.L9:
/*         if (++width == maxloops) */
.LM7:
    ld r24,Z   ;  D.1554, *port_7(D)   ;  60  movqi_insn/4  [length = 1]
    7244:	80 81       	ld	r24, Z
    and r24,r22  ;  D.1554, bit  ;  62  andqi3/1  [length = 1]
    7246:	86 23       	and	r24, r22
    cp r24,r20   ;  D.1554, stateMask  ;  63  *cmpqi/2  [length = 1]
    7248:	84 17       	cp	r24, r20
    breq .L10  ; ,   ;  64  branch  [length = 1]
    724a:	91 f3       	breq	.-28     	; 0x7230 <countPulseASM+0x42>
/*             return 0;
***     }
***     return width;
*/
.LM8:
    mov r22,r12  ;  D.1553, width  ;  108 movqi_insn/1  [length = 1]
    724c:	6c 2d       	mov	r22, r12
    mov r23,r13  ;  D.1553, width  ;  109 movqi_insn/1  [length = 1]
    724e:	7d 2d       	mov	r23, r13
    mov r24,r14  ;  D.1553, width  ;  110 movqi_insn/1  [length = 1]
    7250:	8e 2d       	mov	r24, r14
    mov r25,r15  ;  D.1553, width  ;  111 movqi_insn/1  [length = 1]
    7252:	9f 2d       	mov	r25, r15
/* epilogue start */
.LM9:
    pop r17  ;   ;  171 popqi [length = 1]
    7254:	1f 91       	pop	r17
    pop r16  ;   ;  172 popqi [length = 1]
    7256:	0f 91       	pop	r16
    pop r15  ;   ;  173 popqi [length = 1]
    7258:	ff 90       	pop	r15
    pop r14  ;   ;  174 popqi [length = 1]
    725a:	ef 90       	pop	r14
    pop r13  ;   ;  175 popqi [length = 1]
    725c:	df 90       	pop	r13
    pop r12  ;   ;  176 popqi [length = 1]
    725e:	cf 90       	pop	r12
    ret  ;  177 return_from_epilogue  [length = 1]
    7260:	08 95       	ret
.L13:
.LM10:
    ldi r22,0  ;  D.1553   ;  120 movqi_insn/1  [length = 1]
    7262:	60 e0       	ldi	r22, 0x00	; 0
    ldi r23,0  ;  D.1553   ;  121 movqi_insn/1  [length = 1]
    7264:	70 e0       	ldi	r23, 0x00	; 0
    ldi r24,0  ;  D.1553   ;  122 movqi_insn/1  [length = 1]
    7266:	80 e0       	ldi	r24, 0x00	; 0
    ldi r25,0  ;  D.1553   ;  123 movqi_insn/1  [length = 1]
    7268:	90 e0       	ldi	r25, 0x00	; 0
/* epilogue start */
.LM11:
    pop r17  ;   ;  138 popqi [length = 1]
    726a:	1f 91       	pop	r17
    pop r16  ;   ;  139 popqi [length = 1]
    726c:	0f 91       	pop	r16
    pop r15  ;   ;  140 popqi [length = 1]
    726e:	ff 90       	pop	r15
    pop r14  ;   ;  141 popqi [length = 1]
    7270:	ef 90       	pop	r14
    pop r13  ;   ;  142 popqi [length = 1]
    7272:	df 90       	pop	r13
    pop r12  ;   ;  143 popqi [length = 1]
    7274:	cf 90       	pop	r12
    ret  ;  144 return_from_epilogue  [length = 1]
    7276:	08 95       	ret

00007278 <utoa>:
    7278:	45 32       	cpi	r20, 0x25	; 37
    727a:	51 05       	cpc	r21, r1
    727c:	20 f4       	brcc	.+8      	; 0x7286 <utoa+0xe>
    727e:	42 30       	cpi	r20, 0x02	; 2
    7280:	10 f0       	brcs	.+4      	; 0x7286 <utoa+0xe>
    7282:	0c 94 47 39 	jmp	0x728e	; 0x728e <__utoa_ncheck>
    7286:	fb 01       	movw	r30, r22
    7288:	10 82       	st	Z, r1
    728a:	cb 01       	movw	r24, r22
    728c:	08 95       	ret

0000728e <__utoa_ncheck>:
    728e:	bb 27       	eor	r27, r27

00007290 <__utoa_common>:
    7290:	fb 01       	movw	r30, r22
    7292:	55 27       	eor	r21, r21
    7294:	aa 27       	eor	r26, r26
    7296:	88 0f       	add	r24, r24
    7298:	99 1f       	adc	r25, r25
    729a:	aa 1f       	adc	r26, r26
    729c:	a4 17       	cp	r26, r20
    729e:	10 f0       	brcs	.+4      	; 0x72a4 <__utoa_common+0x14>
    72a0:	a4 1b       	sub	r26, r20
    72a2:	83 95       	inc	r24
    72a4:	50 51       	subi	r21, 0x10	; 16
    72a6:	b9 f7       	brne	.-18     	; 0x7296 <__utoa_common+0x6>
    72a8:	a0 5d       	subi	r26, 0xD0	; 208
    72aa:	aa 33       	cpi	r26, 0x3A	; 58
    72ac:	08 f0       	brcs	.+2      	; 0x72b0 <__utoa_common+0x20>
    72ae:	a9 5d       	subi	r26, 0xD9	; 217
    72b0:	a1 93       	st	Z+, r26
    72b2:	00 97       	sbiw	r24, 0x00	; 0
    72b4:	79 f7       	brne	.-34     	; 0x7294 <__utoa_common+0x4>
    72b6:	b1 11       	cpse	r27, r1
    72b8:	b1 93       	st	Z+, r27
    72ba:	11 92       	st	Z+, r1
    72bc:	cb 01       	movw	r24, r22
    72be:	0c 94 61 39 	jmp	0x72c2	; 0x72c2 <strrev>

000072c2 <strrev>:
    72c2:	dc 01       	movw	r26, r24
    72c4:	fc 01       	movw	r30, r24
    72c6:	67 2f       	mov	r22, r23
    72c8:	71 91       	ld	r23, Z+
    72ca:	77 23       	and	r23, r23
    72cc:	e1 f7       	brne	.-8      	; 0x72c6 <strrev+0x4>
    72ce:	32 97       	sbiw	r30, 0x02	; 2
    72d0:	04 c0       	rjmp	.+8      	; 0x72da <strrev+0x18>
    72d2:	7c 91       	ld	r23, X
    72d4:	6d 93       	st	X+, r22
    72d6:	70 83       	st	Z, r23
    72d8:	62 91       	ld	r22, -Z
    72da:	ae 17       	cp	r26, r30
    72dc:	bf 07       	cpc	r27, r31
    72de:	c8 f3       	brcs	.-14     	; 0x72d2 <strrev+0x10>
    72e0:	08 95       	ret

000072e2 <__cmpsf2>:
    72e2:	0e 94 b3 39 	call	0x7366	; 0x7366 <__fp_cmp>
    72e6:	08 f4       	brcc	.+2      	; 0x72ea <__cmpsf2+0x8>
    72e8:	81 e0       	ldi	r24, 0x01	; 1
    72ea:	08 95       	ret

000072ec <__floatunsisf>:
    72ec:	e8 94       	clt
    72ee:	09 c0       	rjmp	.+18     	; 0x7302 <__floatsisf+0x12>

000072f0 <__floatsisf>:
    72f0:	97 fb       	bst	r25, 7
    72f2:	3e f4       	brtc	.+14     	; 0x7302 <__floatsisf+0x12>
    72f4:	90 95       	com	r25
    72f6:	80 95       	com	r24
    72f8:	70 95       	com	r23
    72fa:	61 95       	neg	r22
    72fc:	7f 4f       	sbci	r23, 0xFF	; 255
    72fe:	8f 4f       	sbci	r24, 0xFF	; 255
    7300:	9f 4f       	sbci	r25, 0xFF	; 255
    7302:	99 23       	and	r25, r25
    7304:	a9 f0       	breq	.+42     	; 0x7330 <__floatsisf+0x40>
    7306:	f9 2f       	mov	r31, r25
    7308:	96 e9       	ldi	r25, 0x96	; 150
    730a:	bb 27       	eor	r27, r27
    730c:	93 95       	inc	r25
    730e:	f6 95       	lsr	r31
    7310:	87 95       	ror	r24
    7312:	77 95       	ror	r23
    7314:	67 95       	ror	r22
    7316:	b7 95       	ror	r27
    7318:	f1 11       	cpse	r31, r1
    731a:	f8 cf       	rjmp	.-16     	; 0x730c <__floatsisf+0x1c>
    731c:	fa f4       	brpl	.+62     	; 0x735c <__floatsisf+0x6c>
    731e:	bb 0f       	add	r27, r27
    7320:	11 f4       	brne	.+4      	; 0x7326 <__floatsisf+0x36>
    7322:	60 ff       	sbrs	r22, 0
    7324:	1b c0       	rjmp	.+54     	; 0x735c <__floatsisf+0x6c>
    7326:	6f 5f       	subi	r22, 0xFF	; 255
    7328:	7f 4f       	sbci	r23, 0xFF	; 255
    732a:	8f 4f       	sbci	r24, 0xFF	; 255
    732c:	9f 4f       	sbci	r25, 0xFF	; 255
    732e:	16 c0       	rjmp	.+44     	; 0x735c <__floatsisf+0x6c>
    7330:	88 23       	and	r24, r24
    7332:	11 f0       	breq	.+4      	; 0x7338 <__floatsisf+0x48>
    7334:	96 e9       	ldi	r25, 0x96	; 150
    7336:	11 c0       	rjmp	.+34     	; 0x735a <__floatsisf+0x6a>
    7338:	77 23       	and	r23, r23
    733a:	21 f0       	breq	.+8      	; 0x7344 <__floatsisf+0x54>
    733c:	9e e8       	ldi	r25, 0x8E	; 142
    733e:	87 2f       	mov	r24, r23
    7340:	76 2f       	mov	r23, r22
    7342:	05 c0       	rjmp	.+10     	; 0x734e <__floatsisf+0x5e>
    7344:	66 23       	and	r22, r22
    7346:	71 f0       	breq	.+28     	; 0x7364 <__floatsisf+0x74>
    7348:	96 e8       	ldi	r25, 0x86	; 134
    734a:	86 2f       	mov	r24, r22
    734c:	70 e0       	ldi	r23, 0x00	; 0
    734e:	60 e0       	ldi	r22, 0x00	; 0
    7350:	2a f0       	brmi	.+10     	; 0x735c <__floatsisf+0x6c>
    7352:	9a 95       	dec	r25
    7354:	66 0f       	add	r22, r22
    7356:	77 1f       	adc	r23, r23
    7358:	88 1f       	adc	r24, r24
    735a:	da f7       	brpl	.-10     	; 0x7352 <__floatsisf+0x62>
    735c:	88 0f       	add	r24, r24
    735e:	96 95       	lsr	r25
    7360:	87 95       	ror	r24
    7362:	97 f9       	bld	r25, 7
    7364:	08 95       	ret

00007366 <__fp_cmp>:
    7366:	99 0f       	add	r25, r25
    7368:	00 08       	sbc	r0, r0
    736a:	55 0f       	add	r21, r21
    736c:	aa 0b       	sbc	r26, r26
    736e:	e0 e8       	ldi	r30, 0x80	; 128
    7370:	fe ef       	ldi	r31, 0xFE	; 254
    7372:	16 16       	cp	r1, r22
    7374:	17 06       	cpc	r1, r23
    7376:	e8 07       	cpc	r30, r24
    7378:	f9 07       	cpc	r31, r25
    737a:	c0 f0       	brcs	.+48     	; 0x73ac <__fp_cmp+0x46>
    737c:	12 16       	cp	r1, r18
    737e:	13 06       	cpc	r1, r19
    7380:	e4 07       	cpc	r30, r20
    7382:	f5 07       	cpc	r31, r21
    7384:	98 f0       	brcs	.+38     	; 0x73ac <__fp_cmp+0x46>
    7386:	62 1b       	sub	r22, r18
    7388:	73 0b       	sbc	r23, r19
    738a:	84 0b       	sbc	r24, r20
    738c:	95 0b       	sbc	r25, r21
    738e:	39 f4       	brne	.+14     	; 0x739e <__fp_cmp+0x38>
    7390:	0a 26       	eor	r0, r26
    7392:	61 f0       	breq	.+24     	; 0x73ac <__fp_cmp+0x46>
    7394:	23 2b       	or	r18, r19
    7396:	24 2b       	or	r18, r20
    7398:	25 2b       	or	r18, r21
    739a:	21 f4       	brne	.+8      	; 0x73a4 <__fp_cmp+0x3e>
    739c:	08 95       	ret
    739e:	0a 26       	eor	r0, r26
    73a0:	09 f4       	brne	.+2      	; 0x73a4 <__fp_cmp+0x3e>
    73a2:	a1 40       	sbci	r26, 0x01	; 1
    73a4:	a6 95       	lsr	r26
    73a6:	8f ef       	ldi	r24, 0xFF	; 255
    73a8:	81 1d       	adc	r24, r1
    73aa:	81 1d       	adc	r24, r1
    73ac:	08 95       	ret

000073ae <__mulsf3>:
    73ae:	0e 94 ea 39 	call	0x73d4	; 0x73d4 <__mulsf3x>
    73b2:	0c 94 5b 3a 	jmp	0x74b6	; 0x74b6 <__fp_round>
    73b6:	0e 94 4d 3a 	call	0x749a	; 0x749a <__fp_pscA>
    73ba:	38 f0       	brcs	.+14     	; 0x73ca <__mulsf3+0x1c>
    73bc:	0e 94 54 3a 	call	0x74a8	; 0x74a8 <__fp_pscB>
    73c0:	20 f0       	brcs	.+8      	; 0x73ca <__mulsf3+0x1c>
    73c2:	95 23       	and	r25, r21
    73c4:	11 f0       	breq	.+4      	; 0x73ca <__mulsf3+0x1c>
    73c6:	0c 94 44 3a 	jmp	0x7488	; 0x7488 <__fp_inf>
    73ca:	0c 94 4a 3a 	jmp	0x7494	; 0x7494 <__fp_nan>
    73ce:	11 24       	eor	r1, r1
    73d0:	0c 94 8f 3a 	jmp	0x751e	; 0x751e <__fp_szero>

000073d4 <__mulsf3x>:
    73d4:	0e 94 6c 3a 	call	0x74d8	; 0x74d8 <__fp_split3>
    73d8:	70 f3       	brcs	.-36     	; 0x73b6 <__mulsf3+0x8>

000073da <__mulsf3_pse>:
    73da:	95 9f       	mul	r25, r21
    73dc:	c1 f3       	breq	.-16     	; 0x73ce <__mulsf3+0x20>
    73de:	95 0f       	add	r25, r21
    73e0:	50 e0       	ldi	r21, 0x00	; 0
    73e2:	55 1f       	adc	r21, r21
    73e4:	62 9f       	mul	r22, r18
    73e6:	f0 01       	movw	r30, r0
    73e8:	72 9f       	mul	r23, r18
    73ea:	bb 27       	eor	r27, r27
    73ec:	f0 0d       	add	r31, r0
    73ee:	b1 1d       	adc	r27, r1
    73f0:	63 9f       	mul	r22, r19
    73f2:	aa 27       	eor	r26, r26
    73f4:	f0 0d       	add	r31, r0
    73f6:	b1 1d       	adc	r27, r1
    73f8:	aa 1f       	adc	r26, r26
    73fa:	64 9f       	mul	r22, r20
    73fc:	66 27       	eor	r22, r22
    73fe:	b0 0d       	add	r27, r0
    7400:	a1 1d       	adc	r26, r1
    7402:	66 1f       	adc	r22, r22
    7404:	82 9f       	mul	r24, r18
    7406:	22 27       	eor	r18, r18
    7408:	b0 0d       	add	r27, r0
    740a:	a1 1d       	adc	r26, r1
    740c:	62 1f       	adc	r22, r18
    740e:	73 9f       	mul	r23, r19
    7410:	b0 0d       	add	r27, r0
    7412:	a1 1d       	adc	r26, r1
    7414:	62 1f       	adc	r22, r18
    7416:	83 9f       	mul	r24, r19
    7418:	a0 0d       	add	r26, r0
    741a:	61 1d       	adc	r22, r1
    741c:	22 1f       	adc	r18, r18
    741e:	74 9f       	mul	r23, r20
    7420:	33 27       	eor	r19, r19
    7422:	a0 0d       	add	r26, r0
    7424:	61 1d       	adc	r22, r1
    7426:	23 1f       	adc	r18, r19
    7428:	84 9f       	mul	r24, r20
    742a:	60 0d       	add	r22, r0
    742c:	21 1d       	adc	r18, r1
    742e:	82 2f       	mov	r24, r18
    7430:	76 2f       	mov	r23, r22
    7432:	6a 2f       	mov	r22, r26
    7434:	11 24       	eor	r1, r1
    7436:	9f 57       	subi	r25, 0x7F	; 127
    7438:	50 40       	sbci	r21, 0x00	; 0
    743a:	9a f0       	brmi	.+38     	; 0x7462 <__mulsf3_pse+0x88>
    743c:	f1 f0       	breq	.+60     	; 0x747a <__mulsf3_pse+0xa0>
    743e:	88 23       	and	r24, r24
    7440:	4a f0       	brmi	.+18     	; 0x7454 <__mulsf3_pse+0x7a>
    7442:	ee 0f       	add	r30, r30
    7444:	ff 1f       	adc	r31, r31
    7446:	bb 1f       	adc	r27, r27
    7448:	66 1f       	adc	r22, r22
    744a:	77 1f       	adc	r23, r23
    744c:	88 1f       	adc	r24, r24
    744e:	91 50       	subi	r25, 0x01	; 1
    7450:	50 40       	sbci	r21, 0x00	; 0
    7452:	a9 f7       	brne	.-22     	; 0x743e <__mulsf3_pse+0x64>
    7454:	9e 3f       	cpi	r25, 0xFE	; 254
    7456:	51 05       	cpc	r21, r1
    7458:	80 f0       	brcs	.+32     	; 0x747a <__mulsf3_pse+0xa0>
    745a:	0c 94 44 3a 	jmp	0x7488	; 0x7488 <__fp_inf>
    745e:	0c 94 8f 3a 	jmp	0x751e	; 0x751e <__fp_szero>
    7462:	5f 3f       	cpi	r21, 0xFF	; 255
    7464:	e4 f3       	brlt	.-8      	; 0x745e <__mulsf3_pse+0x84>
    7466:	98 3e       	cpi	r25, 0xE8	; 232
    7468:	d4 f3       	brlt	.-12     	; 0x745e <__mulsf3_pse+0x84>
    746a:	86 95       	lsr	r24
    746c:	77 95       	ror	r23
    746e:	67 95       	ror	r22
    7470:	b7 95       	ror	r27
    7472:	f7 95       	ror	r31
    7474:	e7 95       	ror	r30
    7476:	9f 5f       	subi	r25, 0xFF	; 255
    7478:	c1 f7       	brne	.-16     	; 0x746a <__mulsf3_pse+0x90>
    747a:	fe 2b       	or	r31, r30
    747c:	88 0f       	add	r24, r24
    747e:	91 1d       	adc	r25, r1
    7480:	96 95       	lsr	r25
    7482:	87 95       	ror	r24
    7484:	97 f9       	bld	r25, 7
    7486:	08 95       	ret

00007488 <__fp_inf>:
    7488:	97 f9       	bld	r25, 7
    748a:	9f 67       	ori	r25, 0x7F	; 127
    748c:	80 e8       	ldi	r24, 0x80	; 128
    748e:	70 e0       	ldi	r23, 0x00	; 0
    7490:	60 e0       	ldi	r22, 0x00	; 0
    7492:	08 95       	ret

00007494 <__fp_nan>:
    7494:	9f ef       	ldi	r25, 0xFF	; 255
    7496:	80 ec       	ldi	r24, 0xC0	; 192
    7498:	08 95       	ret

0000749a <__fp_pscA>:
    749a:	00 24       	eor	r0, r0
    749c:	0a 94       	dec	r0
    749e:	16 16       	cp	r1, r22
    74a0:	17 06       	cpc	r1, r23
    74a2:	18 06       	cpc	r1, r24
    74a4:	09 06       	cpc	r0, r25
    74a6:	08 95       	ret

000074a8 <__fp_pscB>:
    74a8:	00 24       	eor	r0, r0
    74aa:	0a 94       	dec	r0
    74ac:	12 16       	cp	r1, r18
    74ae:	13 06       	cpc	r1, r19
    74b0:	14 06       	cpc	r1, r20
    74b2:	05 06       	cpc	r0, r21
    74b4:	08 95       	ret

000074b6 <__fp_round>:
    74b6:	09 2e       	mov	r0, r25
    74b8:	03 94       	inc	r0
    74ba:	00 0c       	add	r0, r0
    74bc:	11 f4       	brne	.+4      	; 0x74c2 <__fp_round+0xc>
    74be:	88 23       	and	r24, r24
    74c0:	52 f0       	brmi	.+20     	; 0x74d6 <__fp_round+0x20>
    74c2:	bb 0f       	add	r27, r27
    74c4:	40 f4       	brcc	.+16     	; 0x74d6 <__fp_round+0x20>
    74c6:	bf 2b       	or	r27, r31
    74c8:	11 f4       	brne	.+4      	; 0x74ce <__fp_round+0x18>
    74ca:	60 ff       	sbrs	r22, 0
    74cc:	04 c0       	rjmp	.+8      	; 0x74d6 <__fp_round+0x20>
    74ce:	6f 5f       	subi	r22, 0xFF	; 255
    74d0:	7f 4f       	sbci	r23, 0xFF	; 255
    74d2:	8f 4f       	sbci	r24, 0xFF	; 255
    74d4:	9f 4f       	sbci	r25, 0xFF	; 255
    74d6:	08 95       	ret

000074d8 <__fp_split3>:
    74d8:	57 fd       	sbrc	r21, 7
    74da:	90 58       	subi	r25, 0x80	; 128
    74dc:	44 0f       	add	r20, r20
    74de:	55 1f       	adc	r21, r21
    74e0:	59 f0       	breq	.+22     	; 0x74f8 <__fp_splitA+0x10>
    74e2:	5f 3f       	cpi	r21, 0xFF	; 255
    74e4:	71 f0       	breq	.+28     	; 0x7502 <__fp_splitA+0x1a>
    74e6:	47 95       	ror	r20

000074e8 <__fp_splitA>:
    74e8:	88 0f       	add	r24, r24
    74ea:	97 fb       	bst	r25, 7
    74ec:	99 1f       	adc	r25, r25
    74ee:	61 f0       	breq	.+24     	; 0x7508 <__fp_splitA+0x20>
    74f0:	9f 3f       	cpi	r25, 0xFF	; 255
    74f2:	79 f0       	breq	.+30     	; 0x7512 <__fp_splitA+0x2a>
    74f4:	87 95       	ror	r24
    74f6:	08 95       	ret
    74f8:	12 16       	cp	r1, r18
    74fa:	13 06       	cpc	r1, r19
    74fc:	14 06       	cpc	r1, r20
    74fe:	55 1f       	adc	r21, r21
    7500:	f2 cf       	rjmp	.-28     	; 0x74e6 <__fp_split3+0xe>
    7502:	46 95       	lsr	r20
    7504:	f1 df       	rcall	.-30     	; 0x74e8 <__fp_splitA>
    7506:	08 c0       	rjmp	.+16     	; 0x7518 <__fp_splitA+0x30>
    7508:	16 16       	cp	r1, r22
    750a:	17 06       	cpc	r1, r23
    750c:	18 06       	cpc	r1, r24
    750e:	99 1f       	adc	r25, r25
    7510:	f1 cf       	rjmp	.-30     	; 0x74f4 <__fp_splitA+0xc>
    7512:	86 95       	lsr	r24
    7514:	71 05       	cpc	r23, r1
    7516:	61 05       	cpc	r22, r1
    7518:	08 94       	sec
    751a:	08 95       	ret

0000751c <__fp_zero>:
    751c:	e8 94       	clt

0000751e <__fp_szero>:
    751e:	bb 27       	eor	r27, r27
    7520:	66 27       	eor	r22, r22
    7522:	77 27       	eor	r23, r23
    7524:	cb 01       	movw	r24, r22
    7526:	97 f9       	bld	r25, 7
    7528:	08 95       	ret

0000752a <eeprom_read_byte>:
    752a:	f9 99       	sbic	0x1f, 1	; 31
    752c:	fe cf       	rjmp	.-4      	; 0x752a <eeprom_read_byte>
    752e:	92 bd       	out	0x22, r25	; 34
    7530:	81 bd       	out	0x21, r24	; 33
    7532:	f8 9a       	sbi	0x1f, 0	; 31
    7534:	99 27       	eor	r25, r25
    7536:	80 b5       	in	r24, 0x20	; 32
    7538:	08 95       	ret

0000753a <eeprom_write_byte>:
    753a:	26 2f       	mov	r18, r22

0000753c <eeprom_write_r18>:
    753c:	f9 99       	sbic	0x1f, 1	; 31
    753e:	fe cf       	rjmp	.-4      	; 0x753c <eeprom_write_r18>
    7540:	1f ba       	out	0x1f, r1	; 31
    7542:	92 bd       	out	0x22, r25	; 34
    7544:	81 bd       	out	0x21, r24	; 33
    7546:	20 bd       	out	0x20, r18	; 32
    7548:	0f b6       	in	r0, 0x3f	; 63
    754a:	f8 94       	cli
    754c:	fa 9a       	sbi	0x1f, 2	; 31
    754e:	f9 9a       	sbi	0x1f, 1	; 31
    7550:	0f be       	out	0x3f, r0	; 63
    7552:	01 96       	adiw	r24, 0x01	; 1
    7554:	08 95       	ret

00007556 <__muluhisi3>:
    7556:	0e 94 ed 3a 	call	0x75da	; 0x75da <__umulhisi3>
    755a:	a5 9f       	mul	r26, r21
    755c:	90 0d       	add	r25, r0
    755e:	b4 9f       	mul	r27, r20
    7560:	90 0d       	add	r25, r0
    7562:	a4 9f       	mul	r26, r20
    7564:	80 0d       	add	r24, r0
    7566:	91 1d       	adc	r25, r1
    7568:	11 24       	eor	r1, r1
    756a:	08 95       	ret

0000756c <__prologue_saves__>:
    756c:	2f 92       	push	r2
    756e:	3f 92       	push	r3
    7570:	4f 92       	push	r4
    7572:	5f 92       	push	r5
    7574:	6f 92       	push	r6
    7576:	7f 92       	push	r7
    7578:	8f 92       	push	r8
    757a:	9f 92       	push	r9
    757c:	af 92       	push	r10
    757e:	bf 92       	push	r11
    7580:	cf 92       	push	r12
    7582:	df 92       	push	r13
    7584:	ef 92       	push	r14
    7586:	ff 92       	push	r15
    7588:	0f 93       	push	r16
    758a:	1f 93       	push	r17
    758c:	cf 93       	push	r28
    758e:	df 93       	push	r29
    7590:	cd b7       	in	r28, 0x3d	; 61
    7592:	de b7       	in	r29, 0x3e	; 62
    7594:	ca 1b       	sub	r28, r26
    7596:	db 0b       	sbc	r29, r27
    7598:	0f b6       	in	r0, 0x3f	; 63
    759a:	f8 94       	cli
    759c:	de bf       	out	0x3e, r29	; 62
    759e:	0f be       	out	0x3f, r0	; 63
    75a0:	cd bf       	out	0x3d, r28	; 61
    75a2:	09 94       	ijmp

000075a4 <__epilogue_restores__>:
    75a4:	2a 88       	ldd	r2, Y+18	; 0x12
    75a6:	39 88       	ldd	r3, Y+17	; 0x11
    75a8:	48 88       	ldd	r4, Y+16	; 0x10
    75aa:	5f 84       	ldd	r5, Y+15	; 0x0f
    75ac:	6e 84       	ldd	r6, Y+14	; 0x0e
    75ae:	7d 84       	ldd	r7, Y+13	; 0x0d
    75b0:	8c 84       	ldd	r8, Y+12	; 0x0c
    75b2:	9b 84       	ldd	r9, Y+11	; 0x0b
    75b4:	aa 84       	ldd	r10, Y+10	; 0x0a
    75b6:	b9 84       	ldd	r11, Y+9	; 0x09
    75b8:	c8 84       	ldd	r12, Y+8	; 0x08
    75ba:	df 80       	ldd	r13, Y+7	; 0x07
    75bc:	ee 80       	ldd	r14, Y+6	; 0x06
    75be:	fd 80       	ldd	r15, Y+5	; 0x05
    75c0:	0c 81       	ldd	r16, Y+4	; 0x04
    75c2:	1b 81       	ldd	r17, Y+3	; 0x03
    75c4:	aa 81       	ldd	r26, Y+2	; 0x02
    75c6:	b9 81       	ldd	r27, Y+1	; 0x01
    75c8:	ce 0f       	add	r28, r30
    75ca:	d1 1d       	adc	r29, r1
    75cc:	0f b6       	in	r0, 0x3f	; 63
    75ce:	f8 94       	cli
    75d0:	de bf       	out	0x3e, r29	; 62
    75d2:	0f be       	out	0x3f, r0	; 63
    75d4:	cd bf       	out	0x3d, r28	; 61
    75d6:	ed 01       	movw	r28, r26
    75d8:	08 95       	ret

000075da <__umulhisi3>:
    75da:	a2 9f       	mul	r26, r18
    75dc:	b0 01       	movw	r22, r0
    75de:	b3 9f       	mul	r27, r19
    75e0:	c0 01       	movw	r24, r0
    75e2:	a3 9f       	mul	r26, r19
    75e4:	70 0d       	add	r23, r0
    75e6:	81 1d       	adc	r24, r1
    75e8:	11 24       	eor	r1, r1
    75ea:	91 1d       	adc	r25, r1
    75ec:	b2 9f       	mul	r27, r18
    75ee:	70 0d       	add	r23, r0
    75f0:	81 1d       	adc	r24, r1
    75f2:	11 24       	eor	r1, r1
    75f4:	91 1d       	adc	r25, r1
    75f6:	08 95       	ret

000075f8 <__divmodhi4>:
    75f8:	97 fb       	bst	r25, 7
    75fa:	07 2e       	mov	r0, r23
    75fc:	16 f4       	brtc	.+4      	; 0x7602 <__divmodhi4+0xa>
    75fe:	00 94       	com	r0
    7600:	07 d0       	rcall	.+14     	; 0x7610 <__divmodhi4_neg1>
    7602:	77 fd       	sbrc	r23, 7
    7604:	09 d0       	rcall	.+18     	; 0x7618 <__divmodhi4_neg2>
    7606:	0e 94 57 3b 	call	0x76ae	; 0x76ae <__udivmodhi4>
    760a:	07 fc       	sbrc	r0, 7
    760c:	05 d0       	rcall	.+10     	; 0x7618 <__divmodhi4_neg2>
    760e:	3e f4       	brtc	.+14     	; 0x761e <__divmodhi4_exit>

00007610 <__divmodhi4_neg1>:
    7610:	90 95       	com	r25
    7612:	81 95       	neg	r24
    7614:	9f 4f       	sbci	r25, 0xFF	; 255
    7616:	08 95       	ret

00007618 <__divmodhi4_neg2>:
    7618:	70 95       	com	r23
    761a:	61 95       	neg	r22
    761c:	7f 4f       	sbci	r23, 0xFF	; 255

0000761e <__divmodhi4_exit>:
    761e:	08 95       	ret

00007620 <__udivmodsi4>:
    7620:	a1 e2       	ldi	r26, 0x21	; 33
    7622:	1a 2e       	mov	r1, r26
    7624:	aa 1b       	sub	r26, r26
    7626:	bb 1b       	sub	r27, r27
    7628:	fd 01       	movw	r30, r26
    762a:	0d c0       	rjmp	.+26     	; 0x7646 <__udivmodsi4_ep>

0000762c <__udivmodsi4_loop>:
    762c:	aa 1f       	adc	r26, r26
    762e:	bb 1f       	adc	r27, r27
    7630:	ee 1f       	adc	r30, r30
    7632:	ff 1f       	adc	r31, r31
    7634:	a2 17       	cp	r26, r18
    7636:	b3 07       	cpc	r27, r19
    7638:	e4 07       	cpc	r30, r20
    763a:	f5 07       	cpc	r31, r21
    763c:	20 f0       	brcs	.+8      	; 0x7646 <__udivmodsi4_ep>
    763e:	a2 1b       	sub	r26, r18
    7640:	b3 0b       	sbc	r27, r19
    7642:	e4 0b       	sbc	r30, r20
    7644:	f5 0b       	sbc	r31, r21

00007646 <__udivmodsi4_ep>:
    7646:	66 1f       	adc	r22, r22
    7648:	77 1f       	adc	r23, r23
    764a:	88 1f       	adc	r24, r24
    764c:	99 1f       	adc	r25, r25
    764e:	1a 94       	dec	r1
    7650:	69 f7       	brne	.-38     	; 0x762c <__udivmodsi4_loop>
    7652:	60 95       	com	r22
    7654:	70 95       	com	r23
    7656:	80 95       	com	r24
    7658:	90 95       	com	r25
    765a:	9b 01       	movw	r18, r22
    765c:	ac 01       	movw	r20, r24
    765e:	bd 01       	movw	r22, r26
    7660:	cf 01       	movw	r24, r30
    7662:	08 95       	ret

00007664 <__divmodsi4>:
    7664:	05 2e       	mov	r0, r21
    7666:	97 fb       	bst	r25, 7
    7668:	1e f4       	brtc	.+6      	; 0x7670 <__divmodsi4+0xc>
    766a:	00 94       	com	r0
    766c:	0e 94 49 3b 	call	0x7692	; 0x7692 <__negsi2>
    7670:	57 fd       	sbrc	r21, 7
    7672:	07 d0       	rcall	.+14     	; 0x7682 <__divmodsi4_neg2>
    7674:	0e 94 10 3b 	call	0x7620	; 0x7620 <__udivmodsi4>
    7678:	07 fc       	sbrc	r0, 7
    767a:	03 d0       	rcall	.+6      	; 0x7682 <__divmodsi4_neg2>
    767c:	4e f4       	brtc	.+18     	; 0x7690 <__divmodsi4_exit>
    767e:	0c 94 49 3b 	jmp	0x7692	; 0x7692 <__negsi2>

00007682 <__divmodsi4_neg2>:
    7682:	50 95       	com	r21
    7684:	40 95       	com	r20
    7686:	30 95       	com	r19
    7688:	21 95       	neg	r18
    768a:	3f 4f       	sbci	r19, 0xFF	; 255
    768c:	4f 4f       	sbci	r20, 0xFF	; 255
    768e:	5f 4f       	sbci	r21, 0xFF	; 255

00007690 <__divmodsi4_exit>:
    7690:	08 95       	ret

00007692 <__negsi2>:
    7692:	90 95       	com	r25
    7694:	80 95       	com	r24
    7696:	70 95       	com	r23
    7698:	61 95       	neg	r22
    769a:	7f 4f       	sbci	r23, 0xFF	; 255
    769c:	8f 4f       	sbci	r24, 0xFF	; 255
    769e:	9f 4f       	sbci	r25, 0xFF	; 255
    76a0:	08 95       	ret

000076a2 <__tablejump2__>:
    76a2:	ee 0f       	add	r30, r30
    76a4:	ff 1f       	adc	r31, r31
    76a6:	05 90       	lpm	r0, Z+
    76a8:	f4 91       	lpm	r31, Z
    76aa:	e0 2d       	mov	r30, r0
    76ac:	09 94       	ijmp

000076ae <__udivmodhi4>:
    76ae:	aa 1b       	sub	r26, r26
    76b0:	bb 1b       	sub	r27, r27
    76b2:	51 e1       	ldi	r21, 0x11	; 17
    76b4:	07 c0       	rjmp	.+14     	; 0x76c4 <__udivmodhi4_ep>

000076b6 <__udivmodhi4_loop>:
    76b6:	aa 1f       	adc	r26, r26
    76b8:	bb 1f       	adc	r27, r27
    76ba:	a6 17       	cp	r26, r22
    76bc:	b7 07       	cpc	r27, r23
    76be:	10 f0       	brcs	.+4      	; 0x76c4 <__udivmodhi4_ep>
    76c0:	a6 1b       	sub	r26, r22
    76c2:	b7 0b       	sbc	r27, r23

000076c4 <__udivmodhi4_ep>:
    76c4:	88 1f       	adc	r24, r24
    76c6:	99 1f       	adc	r25, r25
    76c8:	5a 95       	dec	r21
    76ca:	a9 f7       	brne	.-22     	; 0x76b6 <__udivmodhi4_loop>
    76cc:	80 95       	com	r24
    76ce:	90 95       	com	r25
    76d0:	bc 01       	movw	r22, r24
    76d2:	cd 01       	movw	r24, r26
    76d4:	08 95       	ret

000076d6 <__subsf3>:
    76d6:	50 58       	subi	r21, 0x80	; 128

000076d8 <__addsf3>:
    76d8:	bb 27       	eor	r27, r27
    76da:	aa 27       	eor	r26, r26
    76dc:	0e 94 83 3b 	call	0x7706	; 0x7706 <__addsf3x>
    76e0:	0c 94 5b 3a 	jmp	0x74b6	; 0x74b6 <__fp_round>
    76e4:	0e 94 4d 3a 	call	0x749a	; 0x749a <__fp_pscA>
    76e8:	38 f0       	brcs	.+14     	; 0x76f8 <__addsf3+0x20>
    76ea:	0e 94 54 3a 	call	0x74a8	; 0x74a8 <__fp_pscB>
    76ee:	20 f0       	brcs	.+8      	; 0x76f8 <__addsf3+0x20>
    76f0:	39 f4       	brne	.+14     	; 0x7700 <__addsf3+0x28>
    76f2:	9f 3f       	cpi	r25, 0xFF	; 255
    76f4:	19 f4       	brne	.+6      	; 0x76fc <__addsf3+0x24>
    76f6:	26 f4       	brtc	.+8      	; 0x7700 <__addsf3+0x28>
    76f8:	0c 94 4a 3a 	jmp	0x7494	; 0x7494 <__fp_nan>
    76fc:	0e f4       	brtc	.+2      	; 0x7700 <__addsf3+0x28>
    76fe:	e0 95       	com	r30
    7700:	e7 fb       	bst	r30, 7
    7702:	0c 94 44 3a 	jmp	0x7488	; 0x7488 <__fp_inf>

00007706 <__addsf3x>:
    7706:	e9 2f       	mov	r30, r25
    7708:	0e 94 6c 3a 	call	0x74d8	; 0x74d8 <__fp_split3>
    770c:	58 f3       	brcs	.-42     	; 0x76e4 <__addsf3+0xc>
    770e:	ba 17       	cp	r27, r26
    7710:	62 07       	cpc	r22, r18
    7712:	73 07       	cpc	r23, r19
    7714:	84 07       	cpc	r24, r20
    7716:	95 07       	cpc	r25, r21
    7718:	20 f0       	brcs	.+8      	; 0x7722 <__addsf3x+0x1c>
    771a:	79 f4       	brne	.+30     	; 0x773a <__addsf3x+0x34>
    771c:	a6 f5       	brtc	.+104    	; 0x7786 <__addsf3x+0x80>
    771e:	0c 94 8e 3a 	jmp	0x751c	; 0x751c <__fp_zero>
    7722:	0e f4       	brtc	.+2      	; 0x7726 <__addsf3x+0x20>
    7724:	e0 95       	com	r30
    7726:	0b 2e       	mov	r0, r27
    7728:	ba 2f       	mov	r27, r26
    772a:	a0 2d       	mov	r26, r0
    772c:	0b 01       	movw	r0, r22
    772e:	b9 01       	movw	r22, r18
    7730:	90 01       	movw	r18, r0
    7732:	0c 01       	movw	r0, r24
    7734:	ca 01       	movw	r24, r20
    7736:	a0 01       	movw	r20, r0
    7738:	11 24       	eor	r1, r1
    773a:	ff 27       	eor	r31, r31
    773c:	59 1b       	sub	r21, r25
    773e:	99 f0       	breq	.+38     	; 0x7766 <__addsf3x+0x60>
    7740:	59 3f       	cpi	r21, 0xF9	; 249
    7742:	50 f4       	brcc	.+20     	; 0x7758 <__addsf3x+0x52>
    7744:	50 3e       	cpi	r21, 0xE0	; 224
    7746:	68 f1       	brcs	.+90     	; 0x77a2 <__addsf3x+0x9c>
    7748:	1a 16       	cp	r1, r26
    774a:	f0 40       	sbci	r31, 0x00	; 0
    774c:	a2 2f       	mov	r26, r18
    774e:	23 2f       	mov	r18, r19
    7750:	34 2f       	mov	r19, r20
    7752:	44 27       	eor	r20, r20
    7754:	58 5f       	subi	r21, 0xF8	; 248
    7756:	f3 cf       	rjmp	.-26     	; 0x773e <__addsf3x+0x38>
    7758:	46 95       	lsr	r20
    775a:	37 95       	ror	r19
    775c:	27 95       	ror	r18
    775e:	a7 95       	ror	r26
    7760:	f0 40       	sbci	r31, 0x00	; 0
    7762:	53 95       	inc	r21
    7764:	c9 f7       	brne	.-14     	; 0x7758 <__addsf3x+0x52>
    7766:	7e f4       	brtc	.+30     	; 0x7786 <__addsf3x+0x80>
    7768:	1f 16       	cp	r1, r31
    776a:	ba 0b       	sbc	r27, r26
    776c:	62 0b       	sbc	r22, r18
    776e:	73 0b       	sbc	r23, r19
    7770:	84 0b       	sbc	r24, r20
    7772:	ba f0       	brmi	.+46     	; 0x77a2 <__addsf3x+0x9c>
    7774:	91 50       	subi	r25, 0x01	; 1
    7776:	a1 f0       	breq	.+40     	; 0x77a0 <__addsf3x+0x9a>
    7778:	ff 0f       	add	r31, r31
    777a:	bb 1f       	adc	r27, r27
    777c:	66 1f       	adc	r22, r22
    777e:	77 1f       	adc	r23, r23
    7780:	88 1f       	adc	r24, r24
    7782:	c2 f7       	brpl	.-16     	; 0x7774 <__addsf3x+0x6e>
    7784:	0e c0       	rjmp	.+28     	; 0x77a2 <__addsf3x+0x9c>
    7786:	ba 0f       	add	r27, r26
    7788:	62 1f       	adc	r22, r18
    778a:	73 1f       	adc	r23, r19
    778c:	84 1f       	adc	r24, r20
    778e:	48 f4       	brcc	.+18     	; 0x77a2 <__addsf3x+0x9c>
    7790:	87 95       	ror	r24
    7792:	77 95       	ror	r23
    7794:	67 95       	ror	r22
    7796:	b7 95       	ror	r27
    7798:	f7 95       	ror	r31
    779a:	9e 3f       	cpi	r25, 0xFE	; 254
    779c:	08 f0       	brcs	.+2      	; 0x77a0 <__addsf3x+0x9a>
    779e:	b0 cf       	rjmp	.-160    	; 0x7700 <__addsf3+0x28>
    77a0:	93 95       	inc	r25
    77a2:	88 0f       	add	r24, r24
    77a4:	08 f0       	brcs	.+2      	; 0x77a8 <__addsf3x+0xa2>
    77a6:	99 27       	eor	r25, r25
    77a8:	ee 0f       	add	r30, r30
    77aa:	97 95       	ror	r25
    77ac:	87 95       	ror	r24
    77ae:	08 95       	ret

000077b0 <ceil>:
    77b0:	0e 94 b9 3c 	call	0x7972	; 0x7972 <__fp_trunc>
    77b4:	90 f0       	brcs	.+36     	; 0x77da <ceil+0x2a>
    77b6:	9f 37       	cpi	r25, 0x7F	; 127
    77b8:	48 f4       	brcc	.+18     	; 0x77cc <ceil+0x1c>
    77ba:	91 11       	cpse	r25, r1
    77bc:	16 f4       	brtc	.+4      	; 0x77c2 <ceil+0x12>
    77be:	0c 94 8f 3a 	jmp	0x751e	; 0x751e <__fp_szero>
    77c2:	60 e0       	ldi	r22, 0x00	; 0
    77c4:	70 e0       	ldi	r23, 0x00	; 0
    77c6:	80 e8       	ldi	r24, 0x80	; 128
    77c8:	9f e3       	ldi	r25, 0x3F	; 63
    77ca:	08 95       	ret
    77cc:	26 f0       	brts	.+8      	; 0x77d6 <ceil+0x26>
    77ce:	1b 16       	cp	r1, r27
    77d0:	61 1d       	adc	r22, r1
    77d2:	71 1d       	adc	r23, r1
    77d4:	81 1d       	adc	r24, r1
    77d6:	0c 94 90 3c 	jmp	0x7920	; 0x7920 <__fp_mintl>
    77da:	0c 94 ab 3c 	jmp	0x7956	; 0x7956 <__fp_mpack>

000077de <__divsf3>:
    77de:	0e 94 03 3c 	call	0x7806	; 0x7806 <__divsf3x>
    77e2:	0c 94 5b 3a 	jmp	0x74b6	; 0x74b6 <__fp_round>
    77e6:	0e 94 54 3a 	call	0x74a8	; 0x74a8 <__fp_pscB>
    77ea:	58 f0       	brcs	.+22     	; 0x7802 <__divsf3+0x24>
    77ec:	0e 94 4d 3a 	call	0x749a	; 0x749a <__fp_pscA>
    77f0:	40 f0       	brcs	.+16     	; 0x7802 <__divsf3+0x24>
    77f2:	29 f4       	brne	.+10     	; 0x77fe <__divsf3+0x20>
    77f4:	5f 3f       	cpi	r21, 0xFF	; 255
    77f6:	29 f0       	breq	.+10     	; 0x7802 <__divsf3+0x24>
    77f8:	0c 94 44 3a 	jmp	0x7488	; 0x7488 <__fp_inf>
    77fc:	51 11       	cpse	r21, r1
    77fe:	0c 94 8f 3a 	jmp	0x751e	; 0x751e <__fp_szero>
    7802:	0c 94 4a 3a 	jmp	0x7494	; 0x7494 <__fp_nan>

00007806 <__divsf3x>:
    7806:	0e 94 6c 3a 	call	0x74d8	; 0x74d8 <__fp_split3>
    780a:	68 f3       	brcs	.-38     	; 0x77e6 <__divsf3+0x8>

0000780c <__divsf3_pse>:
    780c:	99 23       	and	r25, r25
    780e:	b1 f3       	breq	.-20     	; 0x77fc <__divsf3+0x1e>
    7810:	55 23       	and	r21, r21
    7812:	91 f3       	breq	.-28     	; 0x77f8 <__divsf3+0x1a>
    7814:	95 1b       	sub	r25, r21
    7816:	55 0b       	sbc	r21, r21
    7818:	bb 27       	eor	r27, r27
    781a:	aa 27       	eor	r26, r26
    781c:	62 17       	cp	r22, r18
    781e:	73 07       	cpc	r23, r19
    7820:	84 07       	cpc	r24, r20
    7822:	38 f0       	brcs	.+14     	; 0x7832 <__divsf3_pse+0x26>
    7824:	9f 5f       	subi	r25, 0xFF	; 255
    7826:	5f 4f       	sbci	r21, 0xFF	; 255
    7828:	22 0f       	add	r18, r18
    782a:	33 1f       	adc	r19, r19
    782c:	44 1f       	adc	r20, r20
    782e:	aa 1f       	adc	r26, r26
    7830:	a9 f3       	breq	.-22     	; 0x781c <__divsf3_pse+0x10>
    7832:	35 d0       	rcall	.+106    	; 0x789e <__divsf3_pse+0x92>
    7834:	0e 2e       	mov	r0, r30
    7836:	3a f0       	brmi	.+14     	; 0x7846 <__divsf3_pse+0x3a>
    7838:	e0 e8       	ldi	r30, 0x80	; 128
    783a:	32 d0       	rcall	.+100    	; 0x78a0 <__divsf3_pse+0x94>
    783c:	91 50       	subi	r25, 0x01	; 1
    783e:	50 40       	sbci	r21, 0x00	; 0
    7840:	e6 95       	lsr	r30
    7842:	00 1c       	adc	r0, r0
    7844:	ca f7       	brpl	.-14     	; 0x7838 <__divsf3_pse+0x2c>
    7846:	2b d0       	rcall	.+86     	; 0x789e <__divsf3_pse+0x92>
    7848:	fe 2f       	mov	r31, r30
    784a:	29 d0       	rcall	.+82     	; 0x789e <__divsf3_pse+0x92>
    784c:	66 0f       	add	r22, r22
    784e:	77 1f       	adc	r23, r23
    7850:	88 1f       	adc	r24, r24
    7852:	bb 1f       	adc	r27, r27
    7854:	26 17       	cp	r18, r22
    7856:	37 07       	cpc	r19, r23
    7858:	48 07       	cpc	r20, r24
    785a:	ab 07       	cpc	r26, r27
    785c:	b0 e8       	ldi	r27, 0x80	; 128
    785e:	09 f0       	breq	.+2      	; 0x7862 <__divsf3_pse+0x56>
    7860:	bb 0b       	sbc	r27, r27
    7862:	80 2d       	mov	r24, r0
    7864:	bf 01       	movw	r22, r30
    7866:	ff 27       	eor	r31, r31
    7868:	93 58       	subi	r25, 0x83	; 131
    786a:	5f 4f       	sbci	r21, 0xFF	; 255
    786c:	3a f0       	brmi	.+14     	; 0x787c <__divsf3_pse+0x70>
    786e:	9e 3f       	cpi	r25, 0xFE	; 254
    7870:	51 05       	cpc	r21, r1
    7872:	78 f0       	brcs	.+30     	; 0x7892 <__divsf3_pse+0x86>
    7874:	0c 94 44 3a 	jmp	0x7488	; 0x7488 <__fp_inf>
    7878:	0c 94 8f 3a 	jmp	0x751e	; 0x751e <__fp_szero>
    787c:	5f 3f       	cpi	r21, 0xFF	; 255
    787e:	e4 f3       	brlt	.-8      	; 0x7878 <__divsf3_pse+0x6c>
    7880:	98 3e       	cpi	r25, 0xE8	; 232
    7882:	d4 f3       	brlt	.-12     	; 0x7878 <__divsf3_pse+0x6c>
    7884:	86 95       	lsr	r24
    7886:	77 95       	ror	r23
    7888:	67 95       	ror	r22
    788a:	b7 95       	ror	r27
    788c:	f7 95       	ror	r31
    788e:	9f 5f       	subi	r25, 0xFF	; 255
    7890:	c9 f7       	brne	.-14     	; 0x7884 <__divsf3_pse+0x78>
    7892:	88 0f       	add	r24, r24
    7894:	91 1d       	adc	r25, r1
    7896:	96 95       	lsr	r25
    7898:	87 95       	ror	r24
    789a:	97 f9       	bld	r25, 7
    789c:	08 95       	ret
    789e:	e1 e0       	ldi	r30, 0x01	; 1
    78a0:	66 0f       	add	r22, r22
    78a2:	77 1f       	adc	r23, r23
    78a4:	88 1f       	adc	r24, r24
    78a6:	bb 1f       	adc	r27, r27
    78a8:	62 17       	cp	r22, r18
    78aa:	73 07       	cpc	r23, r19
    78ac:	84 07       	cpc	r24, r20
    78ae:	ba 07       	cpc	r27, r26
    78b0:	20 f0       	brcs	.+8      	; 0x78ba <__divsf3_pse+0xae>
    78b2:	62 1b       	sub	r22, r18
    78b4:	73 0b       	sbc	r23, r19
    78b6:	84 0b       	sbc	r24, r20
    78b8:	ba 0b       	sbc	r27, r26
    78ba:	ee 1f       	adc	r30, r30
    78bc:	88 f7       	brcc	.-30     	; 0x78a0 <__divsf3_pse+0x94>
    78be:	e0 95       	com	r30
    78c0:	08 95       	ret

000078c2 <__fixunssfsi>:
    78c2:	0e 94 74 3a 	call	0x74e8	; 0x74e8 <__fp_splitA>
    78c6:	88 f0       	brcs	.+34     	; 0x78ea <__fixunssfsi+0x28>
    78c8:	9f 57       	subi	r25, 0x7F	; 127
    78ca:	98 f0       	brcs	.+38     	; 0x78f2 <__fixunssfsi+0x30>
    78cc:	b9 2f       	mov	r27, r25
    78ce:	99 27       	eor	r25, r25
    78d0:	b7 51       	subi	r27, 0x17	; 23
    78d2:	b0 f0       	brcs	.+44     	; 0x7900 <__fixunssfsi+0x3e>
    78d4:	e1 f0       	breq	.+56     	; 0x790e <__fixunssfsi+0x4c>
    78d6:	66 0f       	add	r22, r22
    78d8:	77 1f       	adc	r23, r23
    78da:	88 1f       	adc	r24, r24
    78dc:	99 1f       	adc	r25, r25
    78de:	1a f0       	brmi	.+6      	; 0x78e6 <__fixunssfsi+0x24>
    78e0:	ba 95       	dec	r27
    78e2:	c9 f7       	brne	.-14     	; 0x78d6 <__fixunssfsi+0x14>
    78e4:	14 c0       	rjmp	.+40     	; 0x790e <__fixunssfsi+0x4c>
    78e6:	b1 30       	cpi	r27, 0x01	; 1
    78e8:	91 f0       	breq	.+36     	; 0x790e <__fixunssfsi+0x4c>
    78ea:	0e 94 8e 3a 	call	0x751c	; 0x751c <__fp_zero>
    78ee:	b1 e0       	ldi	r27, 0x01	; 1
    78f0:	08 95       	ret
    78f2:	0c 94 8e 3a 	jmp	0x751c	; 0x751c <__fp_zero>
    78f6:	67 2f       	mov	r22, r23
    78f8:	78 2f       	mov	r23, r24
    78fa:	88 27       	eor	r24, r24
    78fc:	b8 5f       	subi	r27, 0xF8	; 248
    78fe:	39 f0       	breq	.+14     	; 0x790e <__fixunssfsi+0x4c>
    7900:	b9 3f       	cpi	r27, 0xF9	; 249
    7902:	cc f3       	brlt	.-14     	; 0x78f6 <__fixunssfsi+0x34>
    7904:	86 95       	lsr	r24
    7906:	77 95       	ror	r23
    7908:	67 95       	ror	r22
    790a:	b3 95       	inc	r27
    790c:	d9 f7       	brne	.-10     	; 0x7904 <__fixunssfsi+0x42>
    790e:	3e f4       	brtc	.+14     	; 0x791e <__fixunssfsi+0x5c>
    7910:	90 95       	com	r25
    7912:	80 95       	com	r24
    7914:	70 95       	com	r23
    7916:	61 95       	neg	r22
    7918:	7f 4f       	sbci	r23, 0xFF	; 255
    791a:	8f 4f       	sbci	r24, 0xFF	; 255
    791c:	9f 4f       	sbci	r25, 0xFF	; 255
    791e:	08 95       	ret

00007920 <__fp_mintl>:
    7920:	88 23       	and	r24, r24
    7922:	71 f4       	brne	.+28     	; 0x7940 <__fp_mintl+0x20>
    7924:	77 23       	and	r23, r23
    7926:	21 f0       	breq	.+8      	; 0x7930 <__fp_mintl+0x10>
    7928:	98 50       	subi	r25, 0x08	; 8
    792a:	87 2b       	or	r24, r23
    792c:	76 2f       	mov	r23, r22
    792e:	07 c0       	rjmp	.+14     	; 0x793e <__fp_mintl+0x1e>
    7930:	66 23       	and	r22, r22
    7932:	11 f4       	brne	.+4      	; 0x7938 <__fp_mintl+0x18>
    7934:	99 27       	eor	r25, r25
    7936:	0d c0       	rjmp	.+26     	; 0x7952 <__fp_mintl+0x32>
    7938:	90 51       	subi	r25, 0x10	; 16
    793a:	86 2b       	or	r24, r22
    793c:	70 e0       	ldi	r23, 0x00	; 0
    793e:	60 e0       	ldi	r22, 0x00	; 0
    7940:	2a f0       	brmi	.+10     	; 0x794c <__fp_mintl+0x2c>
    7942:	9a 95       	dec	r25
    7944:	66 0f       	add	r22, r22
    7946:	77 1f       	adc	r23, r23
    7948:	88 1f       	adc	r24, r24
    794a:	da f7       	brpl	.-10     	; 0x7942 <__fp_mintl+0x22>
    794c:	88 0f       	add	r24, r24
    794e:	96 95       	lsr	r25
    7950:	87 95       	ror	r24
    7952:	97 f9       	bld	r25, 7
    7954:	08 95       	ret

00007956 <__fp_mpack>:
    7956:	9f 3f       	cpi	r25, 0xFF	; 255
    7958:	31 f0       	breq	.+12     	; 0x7966 <__fp_mpack_finite+0xc>

0000795a <__fp_mpack_finite>:
    795a:	91 50       	subi	r25, 0x01	; 1
    795c:	20 f4       	brcc	.+8      	; 0x7966 <__fp_mpack_finite+0xc>
    795e:	87 95       	ror	r24
    7960:	77 95       	ror	r23
    7962:	67 95       	ror	r22
    7964:	b7 95       	ror	r27
    7966:	88 0f       	add	r24, r24
    7968:	91 1d       	adc	r25, r1
    796a:	96 95       	lsr	r25
    796c:	87 95       	ror	r24
    796e:	97 f9       	bld	r25, 7
    7970:	08 95       	ret

00007972 <__fp_trunc>:
    7972:	0e 94 74 3a 	call	0x74e8	; 0x74e8 <__fp_splitA>
    7976:	a0 f0       	brcs	.+40     	; 0x79a0 <__fp_trunc+0x2e>
    7978:	be e7       	ldi	r27, 0x7E	; 126
    797a:	b9 17       	cp	r27, r25
    797c:	88 f4       	brcc	.+34     	; 0x79a0 <__fp_trunc+0x2e>
    797e:	bb 27       	eor	r27, r27
    7980:	9f 38       	cpi	r25, 0x8F	; 143
    7982:	60 f4       	brcc	.+24     	; 0x799c <__fp_trunc+0x2a>
    7984:	16 16       	cp	r1, r22
    7986:	b1 1d       	adc	r27, r1
    7988:	67 2f       	mov	r22, r23
    798a:	78 2f       	mov	r23, r24
    798c:	88 27       	eor	r24, r24
    798e:	98 5f       	subi	r25, 0xF8	; 248
    7990:	f7 cf       	rjmp	.-18     	; 0x7980 <__fp_trunc+0xe>
    7992:	86 95       	lsr	r24
    7994:	77 95       	ror	r23
    7996:	67 95       	ror	r22
    7998:	b1 1d       	adc	r27, r1
    799a:	93 95       	inc	r25
    799c:	96 39       	cpi	r25, 0x96	; 150
    799e:	c8 f3       	brcs	.-14     	; 0x7992 <__fp_trunc+0x20>
    79a0:	08 95       	ret

000079a2 <__gesf2>:
    79a2:	0e 94 b3 39 	call	0x7366	; 0x7366 <__fp_cmp>
    79a6:	08 f4       	brcc	.+2      	; 0x79aa <__gesf2+0x8>
    79a8:	8f ef       	ldi	r24, 0xFF	; 255
    79aa:	08 95       	ret

000079ac <malloc>:
    79ac:	0f 93       	push	r16
    79ae:	1f 93       	push	r17
    79b0:	cf 93       	push	r28
    79b2:	df 93       	push	r29
    79b4:	82 30       	cpi	r24, 0x02	; 2
    79b6:	91 05       	cpc	r25, r1
    79b8:	10 f4       	brcc	.+4      	; 0x79be <malloc+0x12>
    79ba:	82 e0       	ldi	r24, 0x02	; 2
    79bc:	90 e0       	ldi	r25, 0x00	; 0
    79be:	e0 91 9b 07 	lds	r30, 0x079B	; 0x80079b <__flp>
    79c2:	f0 91 9c 07 	lds	r31, 0x079C	; 0x80079c <__flp+0x1>
    79c6:	30 e0       	ldi	r19, 0x00	; 0
    79c8:	20 e0       	ldi	r18, 0x00	; 0
    79ca:	b0 e0       	ldi	r27, 0x00	; 0
    79cc:	a0 e0       	ldi	r26, 0x00	; 0
    79ce:	30 97       	sbiw	r30, 0x00	; 0
    79d0:	99 f4       	brne	.+38     	; 0x79f8 <malloc+0x4c>
    79d2:	21 15       	cp	r18, r1
    79d4:	31 05       	cpc	r19, r1
    79d6:	09 f4       	brne	.+2      	; 0x79da <malloc+0x2e>
    79d8:	4a c0       	rjmp	.+148    	; 0x7a6e <malloc+0xc2>
    79da:	28 1b       	sub	r18, r24
    79dc:	39 0b       	sbc	r19, r25
    79de:	24 30       	cpi	r18, 0x04	; 4
    79e0:	31 05       	cpc	r19, r1
    79e2:	d8 f5       	brcc	.+118    	; 0x7a5a <malloc+0xae>
    79e4:	8a 81       	ldd	r24, Y+2	; 0x02
    79e6:	9b 81       	ldd	r25, Y+3	; 0x03
    79e8:	61 15       	cp	r22, r1
    79ea:	71 05       	cpc	r23, r1
    79ec:	89 f1       	breq	.+98     	; 0x7a50 <malloc+0xa4>
    79ee:	fb 01       	movw	r30, r22
    79f0:	93 83       	std	Z+3, r25	; 0x03
    79f2:	82 83       	std	Z+2, r24	; 0x02
    79f4:	fe 01       	movw	r30, r28
    79f6:	11 c0       	rjmp	.+34     	; 0x7a1a <malloc+0x6e>
    79f8:	40 81       	ld	r20, Z
    79fa:	51 81       	ldd	r21, Z+1	; 0x01
    79fc:	02 81       	ldd	r16, Z+2	; 0x02
    79fe:	13 81       	ldd	r17, Z+3	; 0x03
    7a00:	48 17       	cp	r20, r24
    7a02:	59 07       	cpc	r21, r25
    7a04:	e0 f0       	brcs	.+56     	; 0x7a3e <malloc+0x92>
    7a06:	48 17       	cp	r20, r24
    7a08:	59 07       	cpc	r21, r25
    7a0a:	99 f4       	brne	.+38     	; 0x7a32 <malloc+0x86>
    7a0c:	10 97       	sbiw	r26, 0x00	; 0
    7a0e:	61 f0       	breq	.+24     	; 0x7a28 <malloc+0x7c>
    7a10:	12 96       	adiw	r26, 0x02	; 2
    7a12:	0c 93       	st	X, r16
    7a14:	12 97       	sbiw	r26, 0x02	; 2
    7a16:	13 96       	adiw	r26, 0x03	; 3
    7a18:	1c 93       	st	X, r17
    7a1a:	32 96       	adiw	r30, 0x02	; 2
    7a1c:	cf 01       	movw	r24, r30
    7a1e:	df 91       	pop	r29
    7a20:	cf 91       	pop	r28
    7a22:	1f 91       	pop	r17
    7a24:	0f 91       	pop	r16
    7a26:	08 95       	ret
    7a28:	00 93 9b 07 	sts	0x079B, r16	; 0x80079b <__flp>
    7a2c:	10 93 9c 07 	sts	0x079C, r17	; 0x80079c <__flp+0x1>
    7a30:	f4 cf       	rjmp	.-24     	; 0x7a1a <malloc+0x6e>
    7a32:	21 15       	cp	r18, r1
    7a34:	31 05       	cpc	r19, r1
    7a36:	51 f0       	breq	.+20     	; 0x7a4c <malloc+0xa0>
    7a38:	42 17       	cp	r20, r18
    7a3a:	53 07       	cpc	r21, r19
    7a3c:	38 f0       	brcs	.+14     	; 0x7a4c <malloc+0xa0>
    7a3e:	a9 01       	movw	r20, r18
    7a40:	db 01       	movw	r26, r22
    7a42:	9a 01       	movw	r18, r20
    7a44:	bd 01       	movw	r22, r26
    7a46:	df 01       	movw	r26, r30
    7a48:	f8 01       	movw	r30, r16
    7a4a:	c1 cf       	rjmp	.-126    	; 0x79ce <malloc+0x22>
    7a4c:	ef 01       	movw	r28, r30
    7a4e:	f9 cf       	rjmp	.-14     	; 0x7a42 <malloc+0x96>
    7a50:	90 93 9c 07 	sts	0x079C, r25	; 0x80079c <__flp+0x1>
    7a54:	80 93 9b 07 	sts	0x079B, r24	; 0x80079b <__flp>
    7a58:	cd cf       	rjmp	.-102    	; 0x79f4 <malloc+0x48>
    7a5a:	fe 01       	movw	r30, r28
    7a5c:	e2 0f       	add	r30, r18
    7a5e:	f3 1f       	adc	r31, r19
    7a60:	81 93       	st	Z+, r24
    7a62:	91 93       	st	Z+, r25
    7a64:	22 50       	subi	r18, 0x02	; 2
    7a66:	31 09       	sbc	r19, r1
    7a68:	39 83       	std	Y+1, r19	; 0x01
    7a6a:	28 83       	st	Y, r18
    7a6c:	d7 cf       	rjmp	.-82     	; 0x7a1c <malloc+0x70>
    7a6e:	20 91 99 07 	lds	r18, 0x0799	; 0x800799 <__brkval>
    7a72:	30 91 9a 07 	lds	r19, 0x079A	; 0x80079a <__brkval+0x1>
    7a76:	23 2b       	or	r18, r19
    7a78:	41 f4       	brne	.+16     	; 0x7a8a <malloc+0xde>
    7a7a:	20 91 07 01 	lds	r18, 0x0107	; 0x800107 <__malloc_heap_start>
    7a7e:	30 91 08 01 	lds	r19, 0x0108	; 0x800108 <__malloc_heap_start+0x1>
    7a82:	30 93 9a 07 	sts	0x079A, r19	; 0x80079a <__brkval+0x1>
    7a86:	20 93 99 07 	sts	0x0799, r18	; 0x800799 <__brkval>
    7a8a:	20 91 05 01 	lds	r18, 0x0105	; 0x800105 <__malloc_heap_end>
    7a8e:	30 91 06 01 	lds	r19, 0x0106	; 0x800106 <__malloc_heap_end+0x1>
    7a92:	21 15       	cp	r18, r1
    7a94:	31 05       	cpc	r19, r1
    7a96:	41 f4       	brne	.+16     	; 0x7aa8 <malloc+0xfc>
    7a98:	2d b7       	in	r18, 0x3d	; 61
    7a9a:	3e b7       	in	r19, 0x3e	; 62
    7a9c:	40 91 09 01 	lds	r20, 0x0109	; 0x800109 <__malloc_margin>
    7aa0:	50 91 0a 01 	lds	r21, 0x010A	; 0x80010a <__malloc_margin+0x1>
    7aa4:	24 1b       	sub	r18, r20
    7aa6:	35 0b       	sbc	r19, r21
    7aa8:	e0 91 99 07 	lds	r30, 0x0799	; 0x800799 <__brkval>
    7aac:	f0 91 9a 07 	lds	r31, 0x079A	; 0x80079a <__brkval+0x1>
    7ab0:	e2 17       	cp	r30, r18
    7ab2:	f3 07       	cpc	r31, r19
    7ab4:	a0 f4       	brcc	.+40     	; 0x7ade <malloc+0x132>
    7ab6:	2e 1b       	sub	r18, r30
    7ab8:	3f 0b       	sbc	r19, r31
    7aba:	28 17       	cp	r18, r24
    7abc:	39 07       	cpc	r19, r25
    7abe:	78 f0       	brcs	.+30     	; 0x7ade <malloc+0x132>
    7ac0:	ac 01       	movw	r20, r24
    7ac2:	4e 5f       	subi	r20, 0xFE	; 254
    7ac4:	5f 4f       	sbci	r21, 0xFF	; 255
    7ac6:	24 17       	cp	r18, r20
    7ac8:	35 07       	cpc	r19, r21
    7aca:	48 f0       	brcs	.+18     	; 0x7ade <malloc+0x132>
    7acc:	4e 0f       	add	r20, r30
    7ace:	5f 1f       	adc	r21, r31
    7ad0:	50 93 9a 07 	sts	0x079A, r21	; 0x80079a <__brkval+0x1>
    7ad4:	40 93 99 07 	sts	0x0799, r20	; 0x800799 <__brkval>
    7ad8:	81 93       	st	Z+, r24
    7ada:	91 93       	st	Z+, r25
    7adc:	9f cf       	rjmp	.-194    	; 0x7a1c <malloc+0x70>
    7ade:	f0 e0       	ldi	r31, 0x00	; 0
    7ae0:	e0 e0       	ldi	r30, 0x00	; 0
    7ae2:	9c cf       	rjmp	.-200    	; 0x7a1c <malloc+0x70>

00007ae4 <free>:
    7ae4:	cf 93       	push	r28
    7ae6:	df 93       	push	r29
    7ae8:	00 97       	sbiw	r24, 0x00	; 0
    7aea:	e9 f0       	breq	.+58     	; 0x7b26 <free+0x42>
    7aec:	fc 01       	movw	r30, r24
    7aee:	32 97       	sbiw	r30, 0x02	; 2
    7af0:	13 82       	std	Z+3, r1	; 0x03
    7af2:	12 82       	std	Z+2, r1	; 0x02
    7af4:	a0 91 9b 07 	lds	r26, 0x079B	; 0x80079b <__flp>
    7af8:	b0 91 9c 07 	lds	r27, 0x079C	; 0x80079c <__flp+0x1>
    7afc:	ed 01       	movw	r28, r26
    7afe:	30 e0       	ldi	r19, 0x00	; 0
    7b00:	20 e0       	ldi	r18, 0x00	; 0
    7b02:	10 97       	sbiw	r26, 0x00	; 0
    7b04:	a1 f4       	brne	.+40     	; 0x7b2e <free+0x4a>
    7b06:	20 81       	ld	r18, Z
    7b08:	31 81       	ldd	r19, Z+1	; 0x01
    7b0a:	82 0f       	add	r24, r18
    7b0c:	93 1f       	adc	r25, r19
    7b0e:	20 91 99 07 	lds	r18, 0x0799	; 0x800799 <__brkval>
    7b12:	30 91 9a 07 	lds	r19, 0x079A	; 0x80079a <__brkval+0x1>
    7b16:	28 17       	cp	r18, r24
    7b18:	39 07       	cpc	r19, r25
    7b1a:	09 f0       	breq	.+2      	; 0x7b1e <free+0x3a>
    7b1c:	61 c0       	rjmp	.+194    	; 0x7be0 <free+0xfc>
    7b1e:	f0 93 9a 07 	sts	0x079A, r31	; 0x80079a <__brkval+0x1>
    7b22:	e0 93 99 07 	sts	0x0799, r30	; 0x800799 <__brkval>
    7b26:	df 91       	pop	r29
    7b28:	cf 91       	pop	r28
    7b2a:	08 95       	ret
    7b2c:	ea 01       	movw	r28, r20
    7b2e:	ce 17       	cp	r28, r30
    7b30:	df 07       	cpc	r29, r31
    7b32:	e8 f5       	brcc	.+122    	; 0x7bae <free+0xca>
    7b34:	4a 81       	ldd	r20, Y+2	; 0x02
    7b36:	5b 81       	ldd	r21, Y+3	; 0x03
    7b38:	9e 01       	movw	r18, r28
    7b3a:	41 15       	cp	r20, r1
    7b3c:	51 05       	cpc	r21, r1
    7b3e:	b1 f7       	brne	.-20     	; 0x7b2c <free+0x48>
    7b40:	e9 01       	movw	r28, r18
    7b42:	fb 83       	std	Y+3, r31	; 0x03
    7b44:	ea 83       	std	Y+2, r30	; 0x02
    7b46:	49 91       	ld	r20, Y+
    7b48:	59 91       	ld	r21, Y+
    7b4a:	c4 0f       	add	r28, r20
    7b4c:	d5 1f       	adc	r29, r21
    7b4e:	ec 17       	cp	r30, r28
    7b50:	fd 07       	cpc	r31, r29
    7b52:	61 f4       	brne	.+24     	; 0x7b6c <free+0x88>
    7b54:	80 81       	ld	r24, Z
    7b56:	91 81       	ldd	r25, Z+1	; 0x01
    7b58:	02 96       	adiw	r24, 0x02	; 2
    7b5a:	84 0f       	add	r24, r20
    7b5c:	95 1f       	adc	r25, r21
    7b5e:	e9 01       	movw	r28, r18
    7b60:	99 83       	std	Y+1, r25	; 0x01
    7b62:	88 83       	st	Y, r24
    7b64:	82 81       	ldd	r24, Z+2	; 0x02
    7b66:	93 81       	ldd	r25, Z+3	; 0x03
    7b68:	9b 83       	std	Y+3, r25	; 0x03
    7b6a:	8a 83       	std	Y+2, r24	; 0x02
    7b6c:	f0 e0       	ldi	r31, 0x00	; 0
    7b6e:	e0 e0       	ldi	r30, 0x00	; 0
    7b70:	12 96       	adiw	r26, 0x02	; 2
    7b72:	8d 91       	ld	r24, X+
    7b74:	9c 91       	ld	r25, X
    7b76:	13 97       	sbiw	r26, 0x03	; 3
    7b78:	00 97       	sbiw	r24, 0x00	; 0
    7b7a:	b9 f5       	brne	.+110    	; 0x7bea <free+0x106>
    7b7c:	2d 91       	ld	r18, X+
    7b7e:	3c 91       	ld	r19, X
    7b80:	11 97       	sbiw	r26, 0x01	; 1
    7b82:	cd 01       	movw	r24, r26
    7b84:	02 96       	adiw	r24, 0x02	; 2
    7b86:	82 0f       	add	r24, r18
    7b88:	93 1f       	adc	r25, r19
    7b8a:	20 91 99 07 	lds	r18, 0x0799	; 0x800799 <__brkval>
    7b8e:	30 91 9a 07 	lds	r19, 0x079A	; 0x80079a <__brkval+0x1>
    7b92:	28 17       	cp	r18, r24
    7b94:	39 07       	cpc	r19, r25
    7b96:	39 f6       	brne	.-114    	; 0x7b26 <free+0x42>
    7b98:	30 97       	sbiw	r30, 0x00	; 0
    7b9a:	51 f5       	brne	.+84     	; 0x7bf0 <free+0x10c>
    7b9c:	10 92 9c 07 	sts	0x079C, r1	; 0x80079c <__flp+0x1>
    7ba0:	10 92 9b 07 	sts	0x079B, r1	; 0x80079b <__flp>
    7ba4:	b0 93 9a 07 	sts	0x079A, r27	; 0x80079a <__brkval+0x1>
    7ba8:	a0 93 99 07 	sts	0x0799, r26	; 0x800799 <__brkval>
    7bac:	bc cf       	rjmp	.-136    	; 0x7b26 <free+0x42>
    7bae:	d3 83       	std	Z+3, r29	; 0x03
    7bb0:	c2 83       	std	Z+2, r28	; 0x02
    7bb2:	40 81       	ld	r20, Z
    7bb4:	51 81       	ldd	r21, Z+1	; 0x01
    7bb6:	84 0f       	add	r24, r20
    7bb8:	95 1f       	adc	r25, r21
    7bba:	c8 17       	cp	r28, r24
    7bbc:	d9 07       	cpc	r29, r25
    7bbe:	61 f4       	brne	.+24     	; 0x7bd8 <free+0xf4>
    7bc0:	4e 5f       	subi	r20, 0xFE	; 254
    7bc2:	5f 4f       	sbci	r21, 0xFF	; 255
    7bc4:	88 81       	ld	r24, Y
    7bc6:	99 81       	ldd	r25, Y+1	; 0x01
    7bc8:	48 0f       	add	r20, r24
    7bca:	59 1f       	adc	r21, r25
    7bcc:	51 83       	std	Z+1, r21	; 0x01
    7bce:	40 83       	st	Z, r20
    7bd0:	8a 81       	ldd	r24, Y+2	; 0x02
    7bd2:	9b 81       	ldd	r25, Y+3	; 0x03
    7bd4:	93 83       	std	Z+3, r25	; 0x03
    7bd6:	82 83       	std	Z+2, r24	; 0x02
    7bd8:	21 15       	cp	r18, r1
    7bda:	31 05       	cpc	r19, r1
    7bdc:	09 f0       	breq	.+2      	; 0x7be0 <free+0xfc>
    7bde:	b0 cf       	rjmp	.-160    	; 0x7b40 <free+0x5c>
    7be0:	f0 93 9c 07 	sts	0x079C, r31	; 0x80079c <__flp+0x1>
    7be4:	e0 93 9b 07 	sts	0x079B, r30	; 0x80079b <__flp>
    7be8:	9e cf       	rjmp	.-196    	; 0x7b26 <free+0x42>
    7bea:	fd 01       	movw	r30, r26
    7bec:	dc 01       	movw	r26, r24
    7bee:	c0 cf       	rjmp	.-128    	; 0x7b70 <free+0x8c>
    7bf0:	13 82       	std	Z+3, r1	; 0x03
    7bf2:	12 82       	std	Z+2, r1	; 0x02
    7bf4:	d7 cf       	rjmp	.-82     	; 0x7ba4 <free+0xc0>

00007bf6 <realloc>:
    7bf6:	b0 e0       	ldi	r27, 0x00	; 0
    7bf8:	a0 e0       	ldi	r26, 0x00	; 0
    7bfa:	e1 e0       	ldi	r30, 0x01	; 1
    7bfc:	fe e3       	ldi	r31, 0x3E	; 62
    7bfe:	0c 94 b8 3a 	jmp	0x7570	; 0x7570 <__prologue_saves__+0x4>
    7c02:	8c 01       	movw	r16, r24
    7c04:	00 97       	sbiw	r24, 0x00	; 0
    7c06:	51 f4       	brne	.+20     	; 0x7c1c <realloc+0x26>
    7c08:	cb 01       	movw	r24, r22
    7c0a:	0e 94 d6 3c 	call	0x79ac	; 0x79ac <malloc>
    7c0e:	8c 01       	movw	r16, r24
    7c10:	c8 01       	movw	r24, r16
    7c12:	cd b7       	in	r28, 0x3d	; 61
    7c14:	de b7       	in	r29, 0x3e	; 62
    7c16:	e0 e1       	ldi	r30, 0x10	; 16
    7c18:	0c 94 d4 3a 	jmp	0x75a8	; 0x75a8 <__epilogue_restores__+0x4>
    7c1c:	fc 01       	movw	r30, r24
    7c1e:	e6 0f       	add	r30, r22
    7c20:	f7 1f       	adc	r31, r23
    7c22:	9c 01       	movw	r18, r24
    7c24:	22 50       	subi	r18, 0x02	; 2
    7c26:	31 09       	sbc	r19, r1
    7c28:	e2 17       	cp	r30, r18
    7c2a:	f3 07       	cpc	r31, r19
    7c2c:	08 f4       	brcc	.+2      	; 0x7c30 <realloc+0x3a>
    7c2e:	9d c0       	rjmp	.+314    	; 0x7d6a <realloc+0x174>
    7c30:	d9 01       	movw	r26, r18
    7c32:	cd 91       	ld	r28, X+
    7c34:	dc 91       	ld	r29, X
    7c36:	11 97       	sbiw	r26, 0x01	; 1
    7c38:	c6 17       	cp	r28, r22
    7c3a:	d7 07       	cpc	r29, r23
    7c3c:	98 f0       	brcs	.+38     	; 0x7c64 <realloc+0x6e>
    7c3e:	c5 30       	cpi	r28, 0x05	; 5
    7c40:	d1 05       	cpc	r29, r1
    7c42:	30 f3       	brcs	.-52     	; 0x7c10 <realloc+0x1a>
    7c44:	ce 01       	movw	r24, r28
    7c46:	04 97       	sbiw	r24, 0x04	; 4
    7c48:	86 17       	cp	r24, r22
    7c4a:	97 07       	cpc	r25, r23
    7c4c:	08 f3       	brcs	.-62     	; 0x7c10 <realloc+0x1a>
    7c4e:	c6 1b       	sub	r28, r22
    7c50:	d7 0b       	sbc	r29, r23
    7c52:	22 97       	sbiw	r28, 0x02	; 2
    7c54:	c1 93       	st	Z+, r28
    7c56:	d1 93       	st	Z+, r29
    7c58:	6d 93       	st	X+, r22
    7c5a:	7c 93       	st	X, r23
    7c5c:	cf 01       	movw	r24, r30
    7c5e:	0e 94 72 3d 	call	0x7ae4	; 0x7ae4 <free>
    7c62:	d6 cf       	rjmp	.-84     	; 0x7c10 <realloc+0x1a>
    7c64:	5b 01       	movw	r10, r22
    7c66:	ac 1a       	sub	r10, r28
    7c68:	bd 0a       	sbc	r11, r29
    7c6a:	4c 01       	movw	r8, r24
    7c6c:	8c 0e       	add	r8, r28
    7c6e:	9d 1e       	adc	r9, r29
    7c70:	a0 91 9b 07 	lds	r26, 0x079B	; 0x80079b <__flp>
    7c74:	b0 91 9c 07 	lds	r27, 0x079C	; 0x80079c <__flp+0x1>
    7c78:	51 2c       	mov	r5, r1
    7c7a:	41 2c       	mov	r4, r1
    7c7c:	f1 2c       	mov	r15, r1
    7c7e:	e1 2c       	mov	r14, r1
    7c80:	10 97       	sbiw	r26, 0x00	; 0
    7c82:	31 f5       	brne	.+76     	; 0x7cd0 <realloc+0xda>
    7c84:	80 91 99 07 	lds	r24, 0x0799	; 0x800799 <__brkval>
    7c88:	90 91 9a 07 	lds	r25, 0x079A	; 0x80079a <__brkval+0x1>
    7c8c:	88 15       	cp	r24, r8
    7c8e:	99 05       	cpc	r25, r9
    7c90:	09 f0       	breq	.+2      	; 0x7c94 <realloc+0x9e>
    7c92:	5c c0       	rjmp	.+184    	; 0x7d4c <realloc+0x156>
    7c94:	46 16       	cp	r4, r22
    7c96:	57 06       	cpc	r5, r23
    7c98:	08 f0       	brcs	.+2      	; 0x7c9c <realloc+0xa6>
    7c9a:	58 c0       	rjmp	.+176    	; 0x7d4c <realloc+0x156>
    7c9c:	80 91 05 01 	lds	r24, 0x0105	; 0x800105 <__malloc_heap_end>
    7ca0:	90 91 06 01 	lds	r25, 0x0106	; 0x800106 <__malloc_heap_end+0x1>
    7ca4:	00 97       	sbiw	r24, 0x00	; 0
    7ca6:	41 f4       	brne	.+16     	; 0x7cb8 <realloc+0xc2>
    7ca8:	8d b7       	in	r24, 0x3d	; 61
    7caa:	9e b7       	in	r25, 0x3e	; 62
    7cac:	40 91 09 01 	lds	r20, 0x0109	; 0x800109 <__malloc_margin>
    7cb0:	50 91 0a 01 	lds	r21, 0x010A	; 0x80010a <__malloc_margin+0x1>
    7cb4:	84 1b       	sub	r24, r20
    7cb6:	95 0b       	sbc	r25, r21
    7cb8:	e8 17       	cp	r30, r24
    7cba:	f9 07       	cpc	r31, r25
    7cbc:	08 f0       	brcs	.+2      	; 0x7cc0 <realloc+0xca>
    7cbe:	55 c0       	rjmp	.+170    	; 0x7d6a <realloc+0x174>
    7cc0:	f0 93 9a 07 	sts	0x079A, r31	; 0x80079a <__brkval+0x1>
    7cc4:	e0 93 99 07 	sts	0x0799, r30	; 0x800799 <__brkval>
    7cc8:	f9 01       	movw	r30, r18
    7cca:	71 83       	std	Z+1, r23	; 0x01
    7ccc:	60 83       	st	Z, r22
    7cce:	a0 cf       	rjmp	.-192    	; 0x7c10 <realloc+0x1a>
    7cd0:	8d 91       	ld	r24, X+
    7cd2:	9c 91       	ld	r25, X
    7cd4:	11 97       	sbiw	r26, 0x01	; 1
    7cd6:	12 96       	adiw	r26, 0x02	; 2
    7cd8:	6c 90       	ld	r6, X
    7cda:	12 97       	sbiw	r26, 0x02	; 2
    7cdc:	13 96       	adiw	r26, 0x03	; 3
    7cde:	7c 90       	ld	r7, X
    7ce0:	13 97       	sbiw	r26, 0x03	; 3
    7ce2:	a8 15       	cp	r26, r8
    7ce4:	b9 05       	cpc	r27, r9
    7ce6:	59 f5       	brne	.+86     	; 0x7d3e <realloc+0x148>
    7ce8:	6c 01       	movw	r12, r24
    7cea:	42 e0       	ldi	r20, 0x02	; 2
    7cec:	c4 0e       	add	r12, r20
    7cee:	d1 1c       	adc	r13, r1
    7cf0:	ca 14       	cp	r12, r10
    7cf2:	db 04       	cpc	r13, r11
    7cf4:	20 f1       	brcs	.+72     	; 0x7d3e <realloc+0x148>
    7cf6:	ac 01       	movw	r20, r24
    7cf8:	4a 19       	sub	r20, r10
    7cfa:	5b 09       	sbc	r21, r11
    7cfc:	da 01       	movw	r26, r20
    7cfe:	12 96       	adiw	r26, 0x02	; 2
    7d00:	15 97       	sbiw	r26, 0x05	; 5
    7d02:	80 f0       	brcs	.+32     	; 0x7d24 <realloc+0x12e>
    7d04:	62 82       	std	Z+2, r6	; 0x02
    7d06:	73 82       	std	Z+3, r7	; 0x03
    7d08:	51 83       	std	Z+1, r21	; 0x01
    7d0a:	40 83       	st	Z, r20
    7d0c:	d9 01       	movw	r26, r18
    7d0e:	6d 93       	st	X+, r22
    7d10:	7c 93       	st	X, r23
    7d12:	e1 14       	cp	r14, r1
    7d14:	f1 04       	cpc	r15, r1
    7d16:	71 f0       	breq	.+28     	; 0x7d34 <realloc+0x13e>
    7d18:	d7 01       	movw	r26, r14
    7d1a:	13 96       	adiw	r26, 0x03	; 3
    7d1c:	fc 93       	st	X, r31
    7d1e:	ee 93       	st	-X, r30
    7d20:	12 97       	sbiw	r26, 0x02	; 2
    7d22:	76 cf       	rjmp	.-276    	; 0x7c10 <realloc+0x1a>
    7d24:	22 96       	adiw	r28, 0x02	; 2
    7d26:	8c 0f       	add	r24, r28
    7d28:	9d 1f       	adc	r25, r29
    7d2a:	f9 01       	movw	r30, r18
    7d2c:	91 83       	std	Z+1, r25	; 0x01
    7d2e:	80 83       	st	Z, r24
    7d30:	f3 01       	movw	r30, r6
    7d32:	ef cf       	rjmp	.-34     	; 0x7d12 <realloc+0x11c>
    7d34:	f0 93 9c 07 	sts	0x079C, r31	; 0x80079c <__flp+0x1>
    7d38:	e0 93 9b 07 	sts	0x079B, r30	; 0x80079b <__flp>
    7d3c:	69 cf       	rjmp	.-302    	; 0x7c10 <realloc+0x1a>
    7d3e:	48 16       	cp	r4, r24
    7d40:	59 06       	cpc	r5, r25
    7d42:	08 f4       	brcc	.+2      	; 0x7d46 <realloc+0x150>
    7d44:	2c 01       	movw	r4, r24
    7d46:	7d 01       	movw	r14, r26
    7d48:	d3 01       	movw	r26, r6
    7d4a:	9a cf       	rjmp	.-204    	; 0x7c80 <realloc+0x8a>
    7d4c:	cb 01       	movw	r24, r22
    7d4e:	0e 94 d6 3c 	call	0x79ac	; 0x79ac <malloc>
    7d52:	7c 01       	movw	r14, r24
    7d54:	00 97       	sbiw	r24, 0x00	; 0
    7d56:	49 f0       	breq	.+18     	; 0x7d6a <realloc+0x174>
    7d58:	ae 01       	movw	r20, r28
    7d5a:	b8 01       	movw	r22, r16
    7d5c:	0e 94 bd 3e 	call	0x7d7a	; 0x7d7a <memcpy>
    7d60:	c8 01       	movw	r24, r16
    7d62:	0e 94 72 3d 	call	0x7ae4	; 0x7ae4 <free>
    7d66:	87 01       	movw	r16, r14
    7d68:	53 cf       	rjmp	.-346    	; 0x7c10 <realloc+0x1a>
    7d6a:	10 e0       	ldi	r17, 0x00	; 0
    7d6c:	00 e0       	ldi	r16, 0x00	; 0
    7d6e:	50 cf       	rjmp	.-352    	; 0x7c10 <realloc+0x1a>

00007d70 <abort>:
    7d70:	81 e0       	ldi	r24, 0x01	; 1
    7d72:	90 e0       	ldi	r25, 0x00	; 0
    7d74:	f8 94       	cli
    7d76:	0c 94 d4 3e 	jmp	0x7da8	; 0x7da8 <__do_global_dtors>

00007d7a <memcpy>:
    7d7a:	fb 01       	movw	r30, r22
    7d7c:	dc 01       	movw	r26, r24
    7d7e:	02 c0       	rjmp	.+4      	; 0x7d84 <memcpy+0xa>
    7d80:	01 90       	ld	r0, Z+
    7d82:	0d 92       	st	X+, r0
    7d84:	41 50       	subi	r20, 0x01	; 1
    7d86:	50 40       	sbci	r21, 0x00	; 0
    7d88:	d8 f7       	brcc	.-10     	; 0x7d80 <memcpy+0x6>
    7d8a:	08 95       	ret

00007d8c <memset>:
    7d8c:	dc 01       	movw	r26, r24
    7d8e:	01 c0       	rjmp	.+2      	; 0x7d92 <memset+0x6>
    7d90:	6d 93       	st	X+, r22
    7d92:	41 50       	subi	r20, 0x01	; 1
    7d94:	50 40       	sbci	r21, 0x00	; 0
    7d96:	e0 f7       	brcc	.-8      	; 0x7d90 <memset+0x4>
    7d98:	08 95       	ret

00007d9a <strcpy>:
    7d9a:	fb 01       	movw	r30, r22
    7d9c:	dc 01       	movw	r26, r24
    7d9e:	01 90       	ld	r0, Z+
    7da0:	0d 92       	st	X+, r0
    7da2:	00 20       	and	r0, r0
    7da4:	e1 f7       	brne	.-8      	; 0x7d9e <strcpy+0x4>
    7da6:	08 95       	ret

00007da8 <__do_global_dtors>:
    7da8:	10 e0       	ldi	r17, 0x00	; 0
    7daa:	c3 e6       	ldi	r28, 0x63	; 99
    7dac:	d0 e0       	ldi	r29, 0x00	; 0
    7dae:	04 c0       	rjmp	.+8      	; 0x7db8 <__do_global_dtors+0x10>
    7db0:	fe 01       	movw	r30, r28
    7db2:	0e 94 51 3b 	call	0x76a2	; 0x76a2 <__tablejump2__>
    7db6:	21 96       	adiw	r28, 0x01	; 1
    7db8:	c4 36       	cpi	r28, 0x64	; 100
    7dba:	d1 07       	cpc	r29, r17
    7dbc:	c9 f7       	brne	.-14     	; 0x7db0 <__do_global_dtors+0x8>
    7dbe:	f8 94       	cli

00007dc0 <__stop_program>:
    7dc0:	ff cf       	rjmp	.-2      	; 0x7dc0 <__stop_program>
